*PROCESS     OPTIONS,SOURCE,LINECOUNT(60),NOMARGINI,MARGINS(010,100,009),NEST;
*PROCESS     FLAG(I),NOCOMPILE(E),LMESSAGE;
*PROCESS     AGGREGATE,ATTRIBUTES(SHORT),MAP,OFFSET,STORAGE,XREF(SHORT);
*PROCESS     GOSTMT,OPTIMIZE(TIME);
*PROCESS     COUNT,FLOW(25,10);
 SMPSCAN:  /*COMMERCIAL UNION SMP/E LIST ENTRY SELECTION UTILITY PROGRAM*/
 PROC(SYSPARM) OPTIONS(MAIN) REORDER;
    /*******************************************************************************/
    /*   NAME      .SMPSCAN   VERSION 02.00                                        */
    /*                                                                             */
    /*                                                                             */
    /*   TITLE     .COMMERCIAL UNION SMP/E LIST ENTRY SELECTION UTILITY.           */
    /*                                                                             */
    /*                                                                             */
    /*   PROGRAM OBJECTIVES                                                        */
    /*                                                                             */
    /*             .COMPENSATE FOR SOME OF THE LIMITATIONS OF THE SMP/E "LIST"     */
    /*              COMMAND, ESPECIALLY IN THE AREAS OF CROSS-ZONE ENTRY           */
    /*              MATCHING, DATE/TIME RANGE CONTROL OF LISTINGS, AND FMID        */
    /*              ASSOCIATION FOR ASSEMBLER AND LOAD MODULE ENTRIES.             */
    /*                                                                             */
    /*             .PROVIDE A UTILITY PROGRAM WRITTEN IN A HIGH LEVEL LANGUAGE     */
    /*              TO PROCESS THE "SMPLIST" OUTPUT FROM AN SMP/E                  */
    /*              "SET_BDY(ZONENAME)./LIST." EXECUTION FOR ONE OR MORE ZONES     */
    /*              AND, USING A USER-SUPPLIED CONTROL VARIABLE INPUT FILE:        */
    /*                                                                             */
    /*                -PROVIDE CROSS-ZONE ENTRY MATCHING BASED ON SMP/E ENTRY      */
    /*                 TYPE, ENTRY NAME, AND ON CHARACTER STRING SCAN SELECTION.   */
    /*                                                                             */
    /*                -IDENTIFY ENTRIES SATISFYING SPECIFIED ENTRY TYPE/NAME       */
    /*                 MATCHING AND CHARACTER STRING SCAN SELECTION CRITERIA.      */
    /*                                                                             */
    /*                -GENERATE A RUN-TIME REPORT TO IDENTIFY EXECUTION CONTROL    */
    /*                 VALUES AND MATCH/SELECTION CRITERIA, PROVIDE A DIRECTORY    */
    /*                 TO MATCHING ENTRIES IN THE INPUT AND OUTPUT DATA SETS,      */
    /*                 AND REPORT FINAL PROCESSING TOTALS ONCE EXECUTION IS        */
    /*                 COMPLETE.                                                   */
    /*                                                                             */
    /*                -GENERATE LISTINGS OF THE MATCHING ENTRIES, BY FILE,         */
    /*                 SHOWING HOW CHARACTER STRING SELECTION CRITERIA HAVE BEEN   */
    /*                 APPLIED, AND IDENTIFYING WHERE THE SELECTION CRITERIA       */
    /*                 HAVE BEEN SATISFIED.                                        */
    /*                                                                             */
    /*                -GENERATE OUTPUT DATA SETS, ONE FOR EACH SMP/E LIST INPUT    */
    /*                 FILE, HAVING THE SAME FORMAT AND ATTRIBUTES AS THE          */
    /*                 "SMPLIST" INPUT DATA SET, TO ALLOW REPROCESSING OF THE      */
    /*                 MATCHING ENTRIES BY SMPSCAN WITH DIFFERENT SELECTION        */
    /*                 CRITERIA, OR TO PROVIDE INPUT TO ANY PROGRAM WHICH          */
    /*                 PROCESSES SMP/E LIST COMMAND OUTPUT AS INPUT.               */
    /*                                                                             */
    /*                -GENERATE 80-BYTE CARD-IMAGE OUTPUT DATA SETS, ONE FOR       */
    /*                 EACH SMP/E LIST INPUT DATA SET, CONTAINING DATA FROM THE    */
    /*                 MATCHING ENTRIES IN A FORMAT SUITABLE FOR USE IN AN SMP/E   */
    /*                 CONTROL STATEMENT, OR FOR FURTHER EDITING USING AN          */
    /*                 INTERACTIVE EDITOR.                                         */
    /*                                                                             */
    /*             .SUPPORT ALL OF THE ENTRY TYPES IN AN SMP/E GLOBAL, DLIB, OR    */
    /*              TARGET ZONE THAT CAN BE LISTED BY THE SMP/E "LIST" COMMAND,    */
    /*              WITH OR WITHOUT THE "XREF" OPTION.                             */
    /*                                                                             */
    /*             .USE CHARACTER STRING SELECTION AND ENTRY MATCHING TECHNIQUES   */
    /*              WHICH ARE GENERAL, AND RELATIVELY INSENSITIVE TO THE FORMAT    */
    /*              AND VALUES OF INDIVIDUAL DATA FIELDS WITHIN THE SMP/E          */
    /*              LISTING ENTRY LINES.  MOREOVER, IT WAS DEEMED IMPORTANT TO     */
    /*              REMAIN INDEPENDENT OF SMP/E INTERNALS OR KNOWLEDGE OF THOSE    */
    /*              INTERNALS.  THE CHARACTER STRING SCAN SELECTION TECHNIQUE IS   */
    /*              BASED ON PRESENCE OR ABSENCE OF SPECIFIED CHARACTER STRINGS    */
    /*              IN THE PRINT LINES DESCRIBING EACH INDIVIDUAL ENTRY.  THE      */
    /*              ENTRY MATCHING TECHNIQUE USED BY SMPSCAN IS BASED ON ENTRY     */
    /*              TYPE AND ON ENTRY NAME WITHIN TYPE.  THE ADVANTAGES OF USING   */
    /*              A CHARACTER STRING SCAN APPROACH ARE THAT ALTHOUGH CONTROL     */
    /*              FILES MAY REQUIRE CHANGE TO ACCOMMODATE NEW RELEASES OR        */
    /*              LEVELS OF SMP/E, THE PROGRAM ITSELF WILL NOT, IN GENERAL, BE   */
    /*              SENSITIVE TO CHANGES IN THE NAMES OF DATA FIELDS NOR WILL IT   */
    /*              BE HIGHLY SENSITIVE TO THE COLUMN LOCATIONS IN WHICH GIVEN     */
    /*              VALUES APPEAR.                                                 */
    /*                                                                             */
    /*             .THE MAJOR DISADVANTAGE FROM PROCESSING LISTINGS RATHER THAN    */
    /*              THE ZONE DATA BASES DIRECTLY IS THAT THE RESULTING             */
    /*              IMPLEMENTATION IS BATCH-ONLY.  THERE ARE ADDITIONAL RESOURCE   */
    /*              COSTS BOTH FOR LISTING THE ENIRE ZONE CONTENTS OF POSSIBLE     */
    /*              INTEREST TO DISK DATA SETS, AND FOR USING CHARACTER STRING     */
    /*              SCAN TECHNIQUES RATHER THAN INDEX SEARCHES TO TRACK DOWN THE   */
    /*              ENTRIES OF INTEREST.                                           */
    /*                                                                             */
    /*                                                                             */
    /*   SOURCE    .IBM PLI OPTIMIZING COMPILER AT VERSION 1 RELEASE 5.1 LEVEL.    */
    /*   LANGUAGE                                                                  */
    /*                                                                             */
    /*                                                                             */
    /*   MODULE    .NOT REENTRANT.  THE MODULE IS CODED REENTRANTLY WITHOUT        */
    /*   ATTRIBUTES     MODIFICATIONS TO STATIC STORAGE, BUT SEVERAL FILES ARE     */
    /*              OPENED AND USED BY THE PROGRAM.  ALSO, WITH PLI VERSION 1      */
    /*              RELEASE 5.1, THE RESULTING LOAD MODULE HAS AMODE=31,           */
    /*              RMODE=ANY.                                                     */
    /*                                                                             */
    /*             .THE COMPILE-TIME OPTIONS USED AT COMMERCIAL UNION FOR          */
    /*              COMPILING THIS PROGRAM WERE SPECIFIED USING "*PROCESS"         */
    /*              STATEMENTS.  THESE ARE INCLUDED AT THE BEGINNING OF THE        */
    /*              SOURCE PROGRAM.  EXECUTION TIME PERFORMANCE MAY BE IMPROVED    */
    /*              IF DESIRED BY DELETING THE "*PROCESS" STATEMENT REQUESTING     */
    /*              THE COUNT AND FLOW OPTIONS.                                    */
    /*                                                                             */
    /*             .THE EXECUTION-TIME PLI OPTIONS FOR THIS PROGRAM AT             */
    /*              COMMERCIAL UNION WERE INCORPORATED INTO THE PROGRAM VIA A      */
    /*              DECLARATION FOR THE STATIC VARIABLE "PLIXOPT".  AN ISASIZE     */
    /*              HAS BEEN SPECIFIED TO ELIMINATE THE NEED FOR USE OF THE        */
    /*              SYSTEM GETMAIN/FREEMAIN ROUTINES TO SATISFY STORAGE            */
    /*              REQUESTS, AND THE HEAP OPTION HAS BEEN SPECIFIED TO ALLOW      */
    /*              VIRTUAL STORAGE USE ABOVE THE 16 MEGABYTE LINE.                */
    /*                                                                             */
    /*                                                                             */
    /*   ENTRY     .THIS PROGRAM IS NAMED "SMPSCAN", ALTHOUGH                      */
    /*   POINT      PLI LOAD MODULES USE AN ENTRY POINT OF "PLISTART".             */
    /*                                                                             */
    /*                                                                             */
    /*   INPUT     .THE PARM FIELD OF THE EXEC STATEMENT IS NOT CURRENTLY USED     */
    /*              TO PASS EXECUTION-TIME VALUES TO SMPSCAN.  PRELIMINARY         */
    /*              SUPPORT HAS BEEN INCLUDED IN THE PROGRAM TO MAKE IT FAIRLY     */
    /*              EASY TO PROVIDE THIS SUPPORT LATER ON IF DESIRED.  VARIABLES   */
    /*              THAT MIGHT BE GOOD CANDIDATES FOR INCLUSION IN THIS TYPE OF    */
    /*              SUPPORT INCLUDE: DDIPFX, DDOPFX, IFILE_MAX, IPLANE_MAX,        */
    /*              IROW_MAX, ICOL_MAX, AND IMATCH_MAX.  THE "SYSIN" CONTROL       */
    /*              CARD DATA SET COULD ALSO BE ADAPTED TO USE A WIDER OR          */
    /*              VARIABLE RECORD SIZE.                                          */
    /*                                                                             */
    /*             .INPUT TO SMPSCAN IS PROVIDED BY THE FOLLOWING INPUT DATA       */
    /*              SETS:                                                          */
    /*                                                                             */
    /*                -THE CONTROL VARIABLE INPUT DATA SET, DDNAME=SYSIN           */
    /*                 (RECFM=FB, LRECL=80), CONTAINS VALUES TO DESIGNATE WHICH    */
    /*                 FILES ARE TO BE ACTIVE (UP TO 16 ARE SUPPORTED).  OTHER     */
    /*                 VARIABLES FROM THIS INPUT DATA SET CONTROL THE SCAN         */
    /*                 SELECTION AND MATCHING OF ENTRIES FROM EACH OF THE          */
    /*                 SMPLIST INPUT DATA SETS, AND VARY THE AMOUNT OF OUTPUT      */
    /*                 GENERATED TO EACH CORRESPONDING "SMPDATA" DATA SET.  FOR    */
    /*                 PROGRAMMING SIMPLICITY AND TO AVOID THIS PROGRAM'S          */
    /*                 BECOMMING A MAJOR DEVELOPMENT EFFORT, PLI GET DATA MODE     */
    /*                 WAS USED TO PROCESS EACH "SYSIN" INPUT RECORD.              */
    /*                 CONSEQUENTLY, ALL CHARACTER STRING VALUES MUST BE           */
    /*                 ENCLOSED IN QUOTES.  THE FOLLOWING PROGRAM CONTROL          */
    /*                 VARIABLES ARE READ FROM "SYSIN":                            */
    /*                                                                             */
    /*                    FILE_ACTIVE_OPTION(FILE#)                                */
    /*                    DATA_OUTPUT_OPTION(FILE#)                                */
    /*                                                                             */
    /*                    SCAN_ARRAY.SELECT(FILE#)                                 */
    /*                    SCAN_ARRAY.PLANE.SELECT(FILE#,PLANE#),                   */
    /*                    SCAN_ARRAY.PLANE.ROW.SELECT(FILE#,PLANE#,ROW#),          */
    /*                    SCAN_ARRAY.PLANE.ROW.COL.OP(FILE#,PLANE#,ROW#,COL#),     */
    /*                    SCAN_ARRAY.PLANE.ROW.COL.STRING(FILE#,PLANE#,ROW#,COL#)  */
    /*                    SCAN_ARRAY.PLANE.ROW.COL.BEG_POS(FILE#,PLANE#,ROW#,COL#) */
    /*                    SCAN_ARRAY.PLANE.ROW.COL.END_POS(FILE#,PLANE#,ROW#,COL#) */
    /*                    SCAN_ARRAY.PLANE.ROW.COL.POS_LEN(FILE#,PLANE#,ROW#,COL#) */
    /*                                                                             */
    /*                    MATCH_ARRAY.ENTRY.TYPE(MATCH#)                           */
    /*                    MATCH_ARRAY.ENTRY.COMPARE_TEST(MATCH#)                   */
    /*                    MATCH_ARRAY.ENTRY.FILE.COMPARE_OPTION(MATCH#,FILE#)      */
    /*                    MATCH_ARRAY.ENTRY.FILE.COMPARE_SELECT(MATCH#,FILE#)      */
    /*                    MATCH_ARRAY.ENTRY.FILE.WRITE_OPTION(MATCH#,FILE#)        */
    /*                    MATCH_ARRAY.ENTRY.FILE.WRITE_SELECT(MATCH#,FILE#)        */
    /*                                                                             */
    /*                 PLI DATA MODE DOES NOT ALLOW SUBSCRIPTS TO BE               */
    /*                 INTERLEAVED, AND CHARACTER STRING VALUES MUST BE ENCLOSED   */
    /*                 IN QUOTES.  A TERMINATING SEMICOLON IS NOT REQUIRED ON      */
    /*                 THE SYSIN CONTROL CARDS - IT IS SUPPLIED INTERNALLY FOR     */
    /*                 THE "GET DATA" STATEMENT BY SMPSCAN.  TO ALLOW THE INPUT    */
    /*                 DATA TO BE SELF-DOCUMENTING, A CONTROL CARD WITH AN "*"     */
    /*                 IN COLUMN 001 IS CONSIDERED TO BE A COMMENT RECORD, AND     */
    /*                 IT IS BYPASSED.  PLI GET DATA MODE DOES NOT ALLOW USE OF    */
    /*                 THE PLI-STYLE COMMENTS ON RECORDS PROCESSED BY "GET         */
    /*                 DATA".                                                      */
    /*                                                                             */
    /*                 THE MEANING OF THE ABOVE VARIABLES, AND THE ALLOWABLE       */
    /*                 VALUES FOR THEM ARE DESCRIBED IN THE FACILITIES/FEATURES    */
    /*                 SECTION BELOW.                                              */
    /*                                                                             */
    /*                -THE SMP/E LIST INPUT DATA SETS,                             */
    /*                 DDNAMES=(SMPLIST1-SMPLIST9, SMPLST10-SMPLST16)              */
    /*                 DCB=(RECFM=FBA,LRECL=121) CONTAIN THE OUTPUT WRITTEN TO     */
    /*                 THE "SMPLIST" DATA SET DURING AN SMP/E                      */
    /*                 "SET_BDY(ZONENAME)./LIST."  RUN.  THIS DATA CAN COME        */
    /*                 DIRECTLY FROM EXECUTION OF SMP/E, OR FROM A DATA WRITTEN    */
    /*                 TO AN "SMPSOUT" DATA SET DURING A PREVIOUS EXECUTION OF     */
    /*                 SMPSCAN.  THE "XREF" OPTION CAN BE SPECIFIED ON THE SMP/E   */
    /*                 LIST COMMAND, IF IT IS SUPPORTED FOR THE ZONE BEING         */
    /*                 LISTED.  EACH SMP/E LIST DATA SET USED AS INPUT TO          */
    /*                 SMPSCAN MUST CONTAIN DATA FOR A SINGLE ZONE - "LIST         */
    /*                 ALLZONES" OUTPUT IS NOT SUPPORTED AS INPUT BY SMPSCAN.      */
    /*                 CROSS-ZONE MATCHING VIA SMPSCAN IS ACCOMPLISHED BY          */
    /*                 PROCESSING SEPARATE LIST DATA SETS, ONE FOR EACH ZONE OF    */
    /*                 INTEREST.                                                   */
    /*                                                                             */
    /*                                                                             */
    /*   WORK/     .SMPSCAN EXECUTION REQUIRES USE OF TEMPORARY WORK DATA SETS     */
    /*   SPILL      OR "SPILL" FILES FOR SAVING ENTRY LISTINGS WHOSE SIZE          */
    /*   FILES      EXCEEDS THE COMPILED CAPACITY OF SMPSCAN.  THERE ARE UP TO     */
    /*              16 OF THESE DATA SETS, ONE FOR EACH OF THE ACTIVE INPUT        */
    /*              LISTING FILES. THE DDNAMES ARE SMPUT1-9, SMPUT10-16, AND THE   */
    /*              DCB ATTRIBUTES ARE (RECFM=FB, LRECL=120).  PRINT CONTROL       */
    /*              CHARACTERS ARE NOT SAVED WITH THE LISTING LINES.  THE SPILL    */
    /*              FILE IS USED WHENEVER THE ENTRY MATCHING CRITERIA PROVIDED     */
    /*              IN "MATCH_ARRAY" INDICATE THAT THE ENTRY COULD POSSIBLY BE     */
    /*              WRITTEN TO AN OUTPUT DATA SET.                                 */
    /*                                                                             */
    /*              THE WORK/SPILL FILES CAN BE ALLOCATED TO ANY MEDIUM            */
    /*              SUPPORTING SEQUENTIAL INPUT AND OUTPUT TO THE SAME DATA SET    */
    /*              (E.G., DASD OR VIO).  AS EACH ENTRY LISTING LINE IS READ       */
    /*              FROM THE "SMPLIST" INPUT DATA SET AND AND PROCESSED AGAINST    */
    /*              THE FILE'S SCAN_ARRAY, THE LINE IS SAVED IN AN ARRAY IN        */
    /*              STORAGE.  IF THE NUMBER OF LINES IN AN ENTRY LISTING EXCEEDS   */
    /*              THE LIMIT SPECIFIED IN SMPSCAN PROGRAM VARIABLE                */
    /*              "LINE_SAVE_LIMIT" (CURRENTLY SET AT 100), THE WORK FILE IS     */
    /*              OPENED FOR OUTPUT, AND THE LINES BEYOND 100 (101, 102, ETC.)   */
    /*              ARE WRITTEN TO IT.  IF, ONCE THE ENTRY HAS BEEN FULLY READ,    */
    /*              IT IS DETERMINED THAT THE ENTRY SATISFIES THE SCAN SELECTION   */
    /*              AND FILE MATCHING CRITERIA SUPPLIED BY THE USER, THE WORK      */
    /*              FILE IS REOPENED FOR INPUT AND THE SAVED LINES ARE REREAD.     */
    /*              TOTALS OF THE NUMBER OF TIMES AN ENTRY WAS SAVED IN            */
    /*              ANTICIPATION OF ITS POSSIBLY BEING NEEDED, THE NUMBER OF       */
    /*              TIMES THE WORK FILE WAS OPENED FOR OUTPUT(WRITE OPEN/LINE      */
    /*              COUNTS) AND FOR INPUT(READ OPEN/LINE COUNTS) ARE DISPLAYED     */
    /*              IN THE FINAL TOTALS SECTION AT THE END OF THE "SMPDCTRY"       */
    /*              REPORT DATA SET.                                               */
    /*                                                                             */
    /*                                                                             */
    /*   OUTPUT    .SMPSCAN PRODUCES NO OPERATOR MESSAGES - THE PLI "DISPLAY"      */
    /*              STATEMENT IS NOT USED.                                         */
    /*                                                                             */
    /*             .SMPSCAN PRODUCES FOUR GROUPS OF OUTPUT DATA SETS:              */
    /*                                                                             */
    /*                -THE EXECUTION PROCESSING REPORT,                            */
    /*                 DDNAME=PTSDCTRY(RECFM=FBA,LRECL=133), CONTAINS MESSAGES     */
    /*                 AND COMMENTS DOCUMENTING THIS EXECUTION OF SMPSCAN.         */
    /*                 REGARDLESS OF THE NUMBER OF ACTIVE INPUT LISTING FILES,     */
    /*                 ONLY ONE SMPDCTRY DATA SET IS PRODUCED FOR AN EXECUTION     */
    /*                 OF SMPSCAN.  THE SMPDCTRY DATA SET REPORT CONTAINS FOUR     */
    /*                 SECTIONS:                                                   */
    /*                                                                             */
    /*                   1). INITIAL FILE INFORMATION AND SCAN_ARRAY CONTENTS.     */
    /*                   2). MATCH STATUS INFORMATION AND MATCH_ARRAY CONTENTS.    */
    /*                   3). DIRECTORY OF MATCHING ENTRIES (ONE SECTION FOR EACH   */
    /*                       DISTINCT TYPE OF ENTRY MATCHED).                      */
    /*                   4). FINAL PROCESSING TOTALS BY FILE, AND BY ENTRY TYPE    */
    /*                       WITHIN FILE.                                          */
    /*                                                                             */
    /*                 THE FIRST TWO SECTIONS ARE PRODUCED DURING SMPSCAN          */
    /*                 INITIALIZATION AND STARTUP, THE THIRD SECTION IS PRODUCED   */
    /*                 AS THE INPUT FILES ARE READ AND ENTRIES ARE MATCHED, AND    */
    /*                 THE LAST SECTION IS PRODUCED AFTER ALL INPUT FILES HAVE     */
    /*                 BEEN READ AND ALL MATCHING OUTPUT PRODUCED.                 */
    /*                                                                             */
    /*                -THE MATCHED ENTRY HIGHLIGHTED OUTPUT DATA SETS,             */
    /*                 DDNAMES=(SMPSCAN1-SMPSCAN9,SMPSCN10-SMPSCN16)               */
    /*                 DCB=(RECFM=FBA,LRECL=133), CONTAIN LISTINGS OF THE          */
    /*                 MATCHING ENTRIES.  THERE IS ONE OF THESE DATA SETS FOR      */
    /*                 EACH ACTIVE INPUT DATA SET.  THIS DATA SET, WHEN PRINTED,   */
    /*                 LOOKS LIKE THE SMPLIST OUTPUT FROM SMP/E, BUT THE DATA      */
    /*                 SETS ARE NOT COMPATIBLE.  PAGE TITLES AND LINE SPACING      */
    /*                 APPEAR THE SAME UPON PRINTING AND RECFM IS THE SAME, BUT    */
    /*                 THE LRECL IS LARGER (133 VS 121), AND THE TOP-OF-PAGE       */
    /*                 TITLE REFERENCES SMPSCAN RATHER THAN SMPLIST.  IN           */
    /*                 ADDITION, THOSE LINES SELECTED BY COMPARISON WITH THE       */
    /*                 FILE'S SCAN_ARRAY ARE FLAGGED ON THE RIGHT WITH             */
    /*                 "**PPP,RRR**" AND SELECTING CHARACTER STRINGS ARE           */
    /*                 UNDERSCORED.  THE FLAG ON THE RIGHT OF A HIGHLIGHTED LINE   */
    /*                 REFERENCES THE PLANE("PPP") AND ROW("RRR") OF THE FILE'S    */
    /*                 SCAN_ARRAY THAT RESULTED IN THE SUCCESSFUL COMPARISON.      */
    /*                 AN UNDERSCORE LINE IS PRODUCED ONLY FOR THE FIRST           */
    /*                 SUCCESSFUL ROW OF THE FILE'S SCAN_ARRAY.  NOTE: AN ENTRY    */
    /*                 THAT WAS CHOSEN BECAUSE AN EXCLUDE CRITERION WAS            */
    /*                 SATISFIED WILL NOT SHOW CORRESPONDING HIGHLIGHTED LINES     */
    /*                 BECAUSE THE CHARACTER STRING(S) DON'T APPEAR IN THE         */
    /*                 ENTRY.                                                      */
    /*                                                                             */
    /*                -THE MATCHED ENTRY SMPLIST OUTPUT DATA SETS,                 */
    /*                 DDNAMES=(SMPSOUT1-SMPSOUT9,SMPSOU10-SMPSOU16)               */
    /*                 DCB=(RECFM=FBA,LRECL=121), CONTAIN LISTINGS OF THE          */
    /*                 MATCHING ENTRIES.  THESE ARE THE SAME ENTRIES LISTED IN     */
    /*                 THE HIGHLIGHTED OUTPUT ("SCAN") DATA SETS, BUT WITHOUT      */
    /*                 HIGHLIGHTING INFORMATION.  THERE IS ONE OF THESE DATA       */
    /*                 SETS FOR EACH ACTIVE INPUT DATA SET. THIS OUTPUT DATA SET   */
    /*                 IS PRODUCED IN THE SAME FORMAT AND WITH THE SAME DCB        */
    /*                 ATTRIBUTES AS THE SMPLIST OUTPUT FROM SMP/E (RECFM,         */
    /*                 LRECL, PRINT CONTROL CHARACTERS, PAGE TITLES, AND LINE      */
    /*                 SPACINGS ARE THE SAME).  THE DATA SET CAN BE PRINTED, BUT   */
    /*                 IT IS NORMALLY USED TO PROVIDE INPUT (VIA SMPLIST           */
    /*                 DDNAMES) TO A FOLLOW-ON EXECUTION OF SMPSCAN USING          */
    /*                 DIFFERENT SELECTION CRITERIA.  IT CAN ALSO BE PASSED TO     */
    /*                 OTHER PROGRAMS WHICH PROCESS SMP/E SMPLIST OUTPUT SUCH AS   */
    /*                 THOSE FOUND ON SHARE OR GUIDE MODS TAPES.                   */
    /*                                                                             */
    /*                -THE MATCHED ENTRY CARD-IMAGE OUTPUT DATA SET,               */
    /*                 DDNAMES=(SMPDATA1-SMPDATA9,SMPDAT10-SMPDAT16)               */
    /*                 DCB=(RECFM=FB,LRECL=080), CONTAINS LISTING LINES FROM THE   */
    /*                 SELECTED ENTRIES MAPPED FROM A 120 CHARACTER PRINT LINE     */
    /*                 ONTO ONE OR MORE 80 BYTE CARD IMAGE RECORDS.  THERE IS      */
    /*                 ONE OF THESE DATA SETS FOR EACH ACTIVE INPUT DATA SET.      */
    /*                 DATA FROM EACH PRINT LINE IS MAPPED WITH ENCLOSING          */
    /*                 COMMENT CHARACTERS SO THAT ONLY THE ENTRY NAME, SMP         */
    /*                 M.C.S.  CONTROL STATEMENTS, ASSEM ENTRY ASSEMBLER SOURCE    */
    /*                 STATEMENTS, AND LMOD ENTRY LINKAGE EDITOR CONTROL           */
    /*                 STATEMENTS ARE MAPPED OUTSIDE COMMENT CHARACTERS.  THE      */
    /*                 DATA SET IS THUS USUALLY SUITABLE FOR DIRECT USE IN AN      */
    /*                 SMP CONTROL STATEMENT (SUCH AS "APPLY").  IT CAN ALSO BE    */
    /*                 PROCESSED BY ANY AVAILABLE INTERACTIVE EDITOR TO PRODUCE    */
    /*                 FURTHER RESULTS.  THE AMOUNT OF DATA WRITTEN TO THIS DATA   */
    /*                 SET DEPENDS ON THE SETTING OF THE "DATA_OUTPUT_OPTION"      */
    /*                 VARIABLE FOR THAT FILE.  THE ALLOWABLE VALUES AND           */
    /*                 ASSOCIATED OUTPUT ARE DESCRIBED IN THE                      */
    /*                 FEATURES/FACILITIES SECTION BELOW.                          */
    /*                                                                             */
    /*             .IN ADDITION TO THE DATA SETS PRODUCED BY SMPSCAN, THE          */
    /*              FOLLOWING ADDITIONAL DATA SETS MAY BE REQUIRED BECAUSE THE     */
    /*              PROGRAM IS WRITTEN IN PLI.  BOTH OF THESE DATA SETS SHOULD     */
    /*              BE ASSIGNED TO SYSOUT, OR DUMMIED OUT:                         */
    /*                                                                             */
    /*                -DDNAME=SYSPRINT IS REQUIRED IF AN ERROR IN PROGRAM          */
    /*                 EXECUTION OCCURS.                                           */
    /*                                                                             */
    /*                -DDNAME=PLIDUMP IS REQUIRED WHEN THE PROGRAM HAS BEEN        */
    /*                 COMPILED WITH WITH THE "COUNT" OR "FLOW" ATTRIBUTES, OR     */
    /*                 WHEN THE "REPORT" OPTION IS USED DURING PROGRAM EXECUTION   */
    /*                 TO MONITOR ISA AND HEAP STORAGE USE.                        */
    /*                                                                             */
    /*                                                                             */
    /*   RESTRICTIONS/LIMITATIONS                                                  */
    /*                                                                             */
    /*             .SMPSCAN HAS BEEN COMPILED UNDER IBM'S PLI OPTIMIZING           */
    /*              COMPILER VERSION 1 RELEASE 5.1 AND SUCCESSFULLY EXECUTED ON    */
    /*              MVS/SP LEVEL 2.1.3.  NO OTHER EXECUTION ENVIRONMENTS HAVE      */
    /*              BEEN TESTED WITH THIS PROGRAM SINCE THE SITE AT WHICH THIS     */
    /*              PROGRAM WAS DEVELOPED IS EXCLUSIVELY MVS/XA AND VM/SP.         */
    /*                                                                             */
    /*             .COMPILATION AND EXECUTION USING THE PLI OPTIMIZING COMPLIER    */
    /*              AND LIBRARIES AT VERSION 1 RELEASE 4.0 LEVEL PRODUCED A LOAD   */
    /*              MODULE WHICH FAILED TO EXECUTE.  WE TURNED OFF THE             */
    /*              "OPTIMIZE(TIME)" OPTION AT COMPILATION AND MADE TEMPORARY      */
    /*              PROGRAM CHANGES TO CIRCUMVENT THE PROBLEM UNTIL THE RELEASE    */
    /*              5.1 LEVEL OF THE COMPILER WAS INSTALLED.  WHILE WE SUSPECT     */
    /*              THESE PROBLEMS WERE RELATED TO THE MAINTENANCE LEVEL OF OUR    */
    /*              4.0 COMPILER, WE DID NOT RESEARCH THE PROBLEM IN DEPTH.  IT    */
    /*              MADE MORE SENSE TO US TO GET THE 5.1 LEVEL OF THE COMPILER     */
    /*              AND LIBRARIES UP AND OPERATIONAL SINCE WE HAD OTHER            */
    /*              REQUIREMENTS FOR THEM AS WELL.  IF THE PLI OPTIMIZING          */
    /*              COMPILER AT VERSION 1 RELEASE 5.1 OR LATER LEVEL IS NOT        */
    /*              AVAILABLE AT YOUR INSTALLATION, CONTACT THE AUTHOR FOR         */
    /*              FUTHER DETAILS.                                                */
    /*                                                                             */
    /*             .THE PROGRAM SUPPORTS SMPLIST OUTPUT FROM THE SMP/E "LIST"      */
    /*              COMMAND.  THERE ARE NO ENTRY TYPE PROCESSING RESTRICTIONS AS   */
    /*              THERE WERE IN PTSSCAN.  ALL ENTRY TYPES THAT ARE DEFINED IN    */
    /*              ZONES AND THAT CAN BE LISTED BY SMP/E RELEASE 3 ARE            */
    /*              SUPPORTED BY SMPSCAN.  MOREOVER, SMPSCAN HAS BEEN STRUCTURED   */
    /*              TO MAKE SUPPORT FOR NEW ENTRY TYPES FAIRLY EASY TO ADD.        */
    /*                                                                             */
    /*             .LISTING OF BACKUP ENTRIES FROM THE SCDS, MTSMAC ENTRIES FROM   */
    /*              SMPMTS, AND STSSRC ENTRIES FROM SMPSTS ARE NOT SUPPORTED BY    */
    /*              SMPSCAN AT THIS TIME.                                          */
    /*                                                                             */
    /*             .THIS VERSION OF SMPSCAN HAS BEEN RUN WITH SMPLIST OUTPUT       */
    /*              FROM SMP/E LVL 13.05.                                          */
    /*                                                                             */
    /*             .AT PRESENT, CONCURRENT PROCESSING IS SUPPORTED FOR A MAXIMUM   */
    /*              OF 16 INPUT LISTINGS ALONG WITH ASSOCIATED OUTPUT DATA SETS.   */
    /*                                                                             */
    /*             .ERROR ROUTINES TO ALLOW FOR RECOVERY FROM MISSING DD           */
    /*              STATEMENTS ARE NOT CODED INTO SMPSCAN AT THIS TIME.  THUS,     */
    /*              IF AN OUTPUT DATA SET IS NOT WANTED, A "DD DUMMY" JCL          */
    /*              STATEMENT SHOULD BE SUPPLIED FOR THE UNWANTED OUTPUT DATA      */
    /*              SET, OR THE PROGRAM WILL END IN ERROR WITHOUT PROCESSING ANY   */
    /*              DATA.                                                          */
    /*                                                                             */
    /*                                                                             */
    /*   FACILITIES/FEATURES                                                       */
    /*                                                                             */
    /*            THIS PROGRAM READS SMP/E "SET_BDY(ZONENAME)./LIST."  OUTPUT      */
    /*      LISTINGS FROM DDNAME=SMPLIST THAT HAVE BEEN WRITTEN TO DISK OR TAPE    */
    /*      DATA SETS RATHER THAN SYSOUT.  UP TO 16 LISTING DATA SETS CAN BE       */
    /*      SCANNED AND MATCHED CONCURRENTLY.  ALL ENTRY TYPES ARE SUPPORTED.      */
    /*      AS ENTRY LISTINGS ARE READ, SMPSCAN SCANS EACH ENTRY FOR CHARACTER     */
    /*      STRINGS AS SPECIFIED BY THE FILE'S "SCAN_ARRAY".  BASED ON THE         */
    /*      RESULTS OF THESE SCANS AND ON THE FILE MATCHING INSTRUCTIONS FROM      */
    /*      THE "MATCH_ARRAY", SMPSCAN PRODUCES OUTPUT DATA SETS CONTAINING DATA   */
    /*      FROM THOSE ENTRIES SATISFYING THE COMBINATION OF SCAN SELECTION AND    */
    /*      MATCH CRITERIA SPECIFIED.                                              */
    /*                                                                             */
    /*            PROGRAM EXECUTION IS CONTROLLED BY VALUES SPECIFIED FOR          */
    /*      PROGRAM VARIABLES IN THE "SYSIN" DATA SET.  THE "SYSIN" DATA SET IS    */
    /*      DEFINED AS A "RECORD" DATA SET.  PLI "GET STRING DATA" IS USED TO      */
    /*      EXTRACT VALUES FROM EACH "SYSIN" INPUT RECORD ONCE IT HAS BEEN READ.   */
    /*      THIS TECHNIQUE WAS USED TO ALLOW COMMENT RECORDS TO BE INCLUDED WITH   */
    /*      THE VARIABLES AND THEIR VALUES.  IF AN "*" APPEARS IN BYTE 1 OF A      */
    /*      SYSIN INPUT RECORD, THE RECORD IS CONSIDERED A COMMENT.  SMPSCAN       */
    /*      BYPASSES COMMENT RECORDS.  WHEN A RECORD IS NOT A COMMENT, BYTES       */
    /*      01-72 OF THE INPUT RECORD ARE PROCESSED AS DATA - BYTES 73-80 ARE      */
    /*      IGNORED AND CAN CONTAIN SEQUENCE NUMBERS IF DESIRED.  IT IS NOT        */
    /*      NECESSARY TO INCLUDE A SEMI-COLON IN "SYSIN" INPUT RECORDS FOR GET     */
    /*      DATA MODE PROCESSING.  SMPSCAN APPENDS A SEMI-COLON TO THE END OF      */
    /*      THE DATA PORTION OF THE RECORD BEFORE DOING THE "GET STRING DATA"      */
    /*      FUNCTION.  BECAUSE PLI "GET DATA" IS USED TO READ THE INPUT            */
    /*      SPECIFICATIONS, THE SPECIFICATIONS MUST HAVE ONE OF THE FOLLOWING      */
    /*      FORMS:                                                                 */
    /*                                                                             */
    /*                 VARIABLE_NAME(SUBSCRIPTS) = NUMBER                          */
    /*            OR   VARIABLE_NAME(SUBSCRIPTS) = 'VALUE'                         */
    /*                                                                             */
    /*      THE VALUE SPECIFICATION FOR CHARACTER STRINGS MUST BE ENCLOSED IN      */
    /*      QUOTES BECAUSE THE CONTROL VARIABLES ARE DECLARED AS PLI CHARACTER     */
    /*      STRINGS. FURTHERMORE, SUBSCRIPTS MUST BE SPECIFIED TOGETHER            */
    /*      FOLLOWING THE VARIABLE NAME AND ALL QUALIFICATIONS.  UNLIKE THE PLI    */
    /*      COMPILER, PLI GET DATA MODE DOES NOT SUPPORT INTERLEAVED SUBSCRIPTS.   */
    /*      PROGRAM CONTROL VARIABLES THAT CAN BE SPECIFIED IN THE CONTROL         */
    /*      VARIABLE INPUT DATA SET WERE LISTED IN THE "INPUT" SECTION ABOVE.      */
    /*      THE MEANING OF THESE VARIABLES, THEIR EFFECTS ON PROGRAM EXECUTION,    */
    /*      AND THEIR VALID RANGES OF VALUES, WILL NOW BE DESCRIBED.               */
    /*                                                                             */
    /*            >>>>>FILE_ACTIVE_OPTION(FILE#).<<<<<                             */
    /*            THIS VARIABLE SPECIFIES WHICH FILES ARE TO BE ACTIVE DURING      */
    /*      THIS EXECUTION OF SMPSCAN.  IT IS DECLARED WITHIN SMPSCAN AS A         */
    /*      ONE-DIMENSIONAL ARRAY OF VARYING LENGTH CHARACTER STRINGS WITH THE     */
    /*      SINGLE SUBSCRIPT CORRESPONDING TO THE FILE NUMBER: 01-16.  THE         */
    /*      VALUES THAT CAN BE SPECIFIED ARE:                                      */
    /*                                                                             */
    /*                 'ACTIVE'                                                    */
    /*                 'INACTIVE'                                                  */
    /*                                                                             */
    /*      THE DEFAULT SPECIFICATION IS "INACTIVE" TO INSURE THAT FILES ARE       */
    /*      EXPLICITLY ACTIVATED.  IF A FILE IS "ACTIVATED", THE CORRESPONDING     */
    /*      "LIST", "SCAN" AND "SOUT" DD STATEMENTS MUST BE SUPPLIED.  THE         */
    /*      CORRESPONDING "DATA" DD STATEMENT IS ALSO REQUIRED UNLESS              */
    /*      DATA_OUTPUT_OPTION FOR THE FILE IS SET TO "NONE" (SEE BELOW).          */
    /*                                                                             */
    /*            >>>>>DATA_OUTPUT_OPTION(FILE#).<<<<<                             */
    /*            THIS VARIABLE CONTROLS THE AMOUNT OF OUTPUT WRITTEN TO EACH      */
    /*      ACTIVE CARD-IMAGE (SMPDATA1-SMPDATA9, SMPDAT10-SMPDAT16) OUTPUT DATA   */
    /*      SET FOR MATCHING ENTRIES.  THE SELECTION OF ENTRIES TO BE WRITTEN IS   */
    /*      CONTROLLED BY THE FILE'S SCAN_ARRAY CONTENTS, AND BY THE               */
    /*      MATCH_ARRAY.  THE DATA_OUTPUT_OPTION VARIABLE IS DECLARED WITHIN       */
    /*      SMPSCAN AS A ONE-DIMENSIONAL ARRAY OF VARYING LENGTH CHARACTER         */
    /*      STRINGS WITH THE SINGLE SUBSCRIPT CORRESPONDING TO THE FILE NUMBER:    */
    /*      01-16.  THE VALUES THAT CAN BE SPECIFIED ARE:                          */
    /*                                                                             */
    /*                 'NONE'                                                      */
    /*                 'ID1'                                                       */
    /*                 'ID'                                                        */
    /*                 'SELECT'                                                    */
    /*                 'ALL'                                                       */
    /*                                                                             */
    /*      THE DEFAULT SPECIFICATION IS "NONE".  CONSEQUENTLY, THE "DATA" DD      */
    /*      STATEMENT IS OPTIONAL AND IS REQUIRED AND USED ONLY IF EXPLICITLY      */
    /*      REQUESTED, AND IF THE MATCH_ARRAY INDICATES THAT THE DATA SET MAY BE   */
    /*      REQUIRED FOR OUTPUT.  THE OTHER SPECIFICATIONS CONTROL THE AMOUNT OF   */
    /*      DATA THAT WILL BE WRITTEN TO THIS DATA SET BY DESIGNATING WHICH OF A   */
    /*      MATCHING ENTRY'S LINES WILL BE MAPPED FROM 120-CHARACTER PRINT LINES   */
    /*      ONTO 80-BYTE CARD IMAGE RECORDS.  A VALUE OF "ID1" CAUSES THE FIRST    */
    /*      PART OF THE FIRST LISTING LINE FOR AN ENTRY TO BE MAPPED TO A SINGLE   */
    /*      80-BYTE CARD IMAGE.  THE RESULT IS A SINGLE CARD IMAGE FOR EACH        */
    /*      MATCHING ENTRY THAT IS SYNTACTICALLY CORRECT FOR USE WITH              */
    /*      SELECT/EXCLUDE OPERANDS ON SMP/E COMMANDS.  A VALUE OF "ID" CAUSES     */
    /*      THE FIRST LISTING LINE FOR AN ENTRY TO BE MAPPED TO ONE OR MORE CARD   */
    /*      IMAGE RECORDS.  SOME ENTRIES, E.G., M.C.S.  ENTRIES, MAY GENERATE      */
    /*      MORE THAN ONE CARD IMAGE WITH THE "ID" OPTION.  A VALUE OF "SELECT"    */
    /*      CAUSES THE FIRST LISTING LINE OF AN ENTRY, AND ANY LISTING LINE        */
    /*      WHICH WAS SELECTED BY COMPARISON WITH THE FILE'S SCAN_ARRAY TO BE      */
    /*      MAPPED TO CARD IMAGE RECORDS.  LASTLY, A VALUE OF "ALL" CAUSES ALL     */
    /*      LISTING LINES FOR A MATCHING ENTRY TO BE MAPPED ONTO CARD IMAGE        */
    /*      RECORDS, WHETHER SELECTED BY THE FILE'S SCAN_ARRAY, OR NOT.            */
    /*                                                                             */
    /*            >>>>>SCAN_ARRAY.<<<<<                                            */
    /*            SCAN_ARRAY PROVIDES SMPSCAN WITH THE INFORMATION IT NEEDS TO     */
    /*      SEARCH ENTRY LISTING LINES.  TITLE LINES ASIDE, THE FORMAT OF SMP/E    */
    /*      LIST OUTPUT LINES IS QUITE STRAIGHTFORWARD.  WITHOUT RECOURSE TO ANY   */
    /*      INTERNAL INFORMATION ON SMP/E, ONE CAN SEE THAT LISTING LINES ARE      */
    /*      FORMATTED IN FOUR AREAS, THREE OF WHICH ARE SIGNIFICANT:               */
    /*                                                                             */
    /*             .ENTRY NAME:       POSITIONS: 001-008     LENGTH: 008           */
    /*             .LINE TYPE:        POSITIONS: 011-025     LENGTH: 015           */
    /*             .EQUALS SIGN:      POSITION:    027       LENGTH: 001           */
    /*             .LINE DATA:        POSITIONS: 029-120     LENGTH: 092           */
    /*                                                                             */
    /*      THE TYPE OF ENTRY IS DETERMINED FROM THE SECOND TITLE LINE OF THE      */
    /*      PAGE ON WHICH THE ENTRY LISTING BEGINS.  A COMPLETELY BLANK LINE IS    */
    /*      NOT PART OF AN ENTRY LISTING, AND IS DISCARDED.  ON NON-BLANK LINES,   */
    /*      THE ENTRY NAME, LINE TYPE, AND LINE DATA AREAS HAVE A MAJOR TO MINOR   */
    /*      RELATIONSHIP WITHIN AN ENTRY LISTING.  THE ENTRY NAME FIELD CONTAINS   */
    /*      THE NAME OF THE ENTRY.  IF THE ENTRY NAME FIELD IS NON-BLANK, IT       */
    /*      SIGNALS THE START OF A NEW ENTRY LISTING.  IF BLANK, THE LINE IS A     */
    /*      CONTINUATION OF THE CURRENT ENTRY LISTING.  THE LINE TYPE FIELD        */
    /*      CATEGORIZES THE INFORMATION BEING LISTED ABOUT THE ENTRY.  WHEN THIS   */
    /*      AREA IS BLANK THE INFORMATION IN THE LINE DATA AREA IS IN THE SAME     */
    /*      CATEGORY AS THAT ON THE PRECEEDING LINE.  SOMETIMES SMP/E WILL PLACE   */
    /*      CHARACTERS IN THE ENDING POSITIONS OF THE LINE TYPE FIELD, LEAVING     */
    /*      THE BEGINNING BLANK.  IN THESE SITUATIONS IT MADE SENSE TO PROPAGATE   */
    /*      THE NON-BLANK DATA FROM THE PRECEEDING LINE TYPE VALUE.  AN EXAMPLE    */
    /*      OF THIS SITUATION OCCURS WITH "DATA/TIME" LINES.  APPLIED SYSMODS IN   */
    /*      A TARGET ZONE WILL HAVE A "DATA/TIME REC" LINE FOLLOWED BY AN          */
    /*      "__________INS" LINE.  SMPSCAN LOGIC SIMPLY CARRIES FORWARD THE        */
    /*      LEADING VALUE SO THAT THE LINE TYPE BECOMES "DATE/TIME INS".  THE      */
    /*      EQUALS SIGN AREA VISUALLY SEPARATES THE LINE TYPE AREA FROM THE LINE   */
    /*      DATA AREA, BUT OTHERWISE ISN'T SIGNIFICANT.  THE LINE DATA AREA        */
    /*      GENERALLY CONTAINS THE ELEMENTS WITHIN THE LINE TYPE CATEGORY.         */
    /*      EXAMPLES INCLUDE THE LISTS OF ELEMENTS AFFECTED BY A SYSMOD (MACROS,   */
    /*      MODULES), THE DATE AND TIME A SYSMOD WAS RECEIVED OR INSTALLED,        */
    /*      HOLDDATA INFORMATION, AND ASSEMBLER INPUT FOR ASSEMBLER ENTRIES.       */
    /*      SOMETIMES THE LINE TYPE AREA WILL IMPLY A SPECIAL TYPE OF LAYOUT FOR   */
    /*      THE INFORMATION PRINTED IN THE LINE DATA AREA.                         */
    /*                                                                             */
    /*            TO PROVIDE THE FACILITIES NEEDED FOR EFFECTIVE SEARCHING OF      */
    /*      LISTING LINES, FOUR GROUPS OF COMPARE AND SCAN OPERATIONS ARE          */
    /*      DEFINED:                                                               */
    /*                                                                             */
    /*             .ENTRY TYPE COMPARES.  THESE OPERATIONS TEST THE TYPE OF        */
    /*              ENTRY LISTED.  ENTRY TYPE IS DETERMINED FROM THE SECOND        */
    /*              TITLE LINE AND IS NOT PART OF THE ENTRY'S LISTING.             */
    /*                                                                             */
    /*             .LINE TYPE COMPARES.  THESE OPERATIONS TEST THE CONTENTS OF     */
    /*              THE SMPSCAN-CALCULATED LINE TYPE FIELD STORED SEPARATELY FOR   */
    /*              THE LINE.  SMPSCAN LOGICALLY CARRIES FORWARD LINE TYPE         */
    /*              INFORMATION FROM A PREVIOUS LINE IF THIS AREA OF THE CURRENT   */
    /*              LINE IS BLANK.  THE CONTENTS OF THE CURRENT LINE ARE NOT       */
    /*              CHANGED.  BECAUSE SMP/E USES A CARRY-FORWARD LOGIC FOR         */
    /*              FORMATTING THIS VALUE (ALL-BLANKS AND LEADING BLANKS), THESE   */
    /*              OPERATIONS ARE PROCESSED AS "PREFIX" COMPARES.     THE LINE    */
    /*              TYPE FIELD IS COMPARED ONLY UP TO THE LENGTH OF THE            */
    /*              SCAN_ARRAY "STRING", AND "STRING" IS NOT EXTENDED ON THE       */
    /*              RIGHT WITH BLANKS.  BOTH NORMAL (CHARACTER-BY-CHARACTER) AND   */
    /*              GENERIC COMPARE OPERATIONS ARE PROVIDED.                       */
    /*                                                                             */
    /*             .LINE DATA COMPARES.  THESE OPERATIONS EXAMINE DATA ON THE      */
    /*              LISTING LINE.  PROGRAM DEFAULTS ARE SET TO COMPARE AT THE      */
    /*              BEGINNING OF THE LINE DATA AREA (029), BUT LOCATIONS           */
    /*              ANYWHERE ON THE LINE CAN BE COMPARED, INCLUDING THE ENTRY      */
    /*              NAME AND LINE TYPE AREAS.  THE COMPARISON IS DONE ONCE, AT     */
    /*              THE LINE POSITION DESIGNATED IN SCAN_ARRAY VARIABLE            */
    /*              "BEG_POS" (SEE BELOW).  LINE DATA COMPARES DIFFER FROM LINE    */
    /*              TYPE COMPARES IN TWO WAYS:  LINE DATA COMPARES ARE NOT         */
    /*              PREFIX COMPARES, A FIELD LENGTH LONGER THAN THE STRING         */
    /*              LENGTH IS NOT IMPLIED, AND LINE DATA COMPARES ARE NOT          */
    /*              LIMITED TO THE LINE DATA FIELD, DATA ANYWHERE ON THE LINE      */
    /*              CAN BE COMPARED.  BOTH NORMAL AND GENERIC COMPARE OPERATIONS   */
    /*              ARE PROVIDED.                                                  */
    /*                                                                             */
    /*             .LINE DATA SCANS.  THESE OPERATIONS EXAMINE THE DATA ON THE     */
    /*              LISTING LINE FOR ONE OR MORE OCCURRENCES OF A CHARACTER        */
    /*              STRING.  PROGRAM DEFAULTS ARE SET TO SCAN THE BOUNDS OF THE    */
    /*              LINE DATA AREA (029-120), BUT DATA ANYWHERE ON THE LINE CAN    */
    /*              BE SCANNED.  TO REDUCE EXECUTION OVERHEAD, THE FIRST           */
    /*              OCCURRENCE OF A STRING STOPS THE SCAN WHEN TESTING LINES,      */
    /*              BUT ALL OCCURRENCES WILL BE UNDERSCORED IF THE ENTRY IS        */
    /*              WRITTEN WITH HIGHLIGHTED OUTPUT.  SCAN OPERATIONS RESEMBLE     */
    /*              EDIT PROCESSOR "FIND" COMMANDS, EXCEPT THAT THE SCAN           */
    /*              OPERATION IS RESTRICTED TO A SINGLE LINE.  BOTH NORMAL AND     */
    /*              GENERIC SCAN OPERATIONS ARE SUPPORTED.                         */
    /*                                                                             */
    /*            SCAN_ARRAY IS DECLARED WITHIN SMPSCAN AS A FOUR DIMENSIONAL      */
    /*      ARRAY OF STRUCTURES, WITH EACH FILE HAVING A CORRESPONDING             */
    /*      CROSS-SECTION.  THE FIRST SCAN_ARRAY SUBSCRIPT CORRESPONDS TO THE      */
    /*      FILE NUMBER (FILE#) WITHIN SMPSCAN, AND THE REMAINING SUBSCRIPTS       */
    /*      DESIGNATE THE PLANE, ROW, AND COLUMN NUMBERS WITHIN SCAN_ARRAY FOR     */
    /*      THAT FILE.  EACH FILE'S CROSS SECTION OF SCAN_ARRAY CAN BE THOUGHT     */
    /*      OF AS A CUBE.  A CUBE IS MADE UP OF PLANES WHICH IN TURN ARE MADE UP   */
    /*      OF LINES (ROWS) WHICH ARE MADE UP OF POINTS (COLUMNS).  THE            */
    /*      SCAN_ARRAY WAS DESIGNED AS AN ALTERNATIVE TO TRYING TO DESIGN A        */
    /*      BOOLEAN ALGEBRA SYNTAX FOR SEARCHING THE LISTING LINES OF AN ENTRY     */
    /*      FOR CHARACTER STRINGS.  THE PLANE AND ROW DIMENSIONS WERE SET UP TO    */
    /*      PROVIDE "LOGICAL OR(PLANE)" AND "LOGICAL AND(ROW)" CAPABILITY, WHILE   */
    /*      THE COLUMN DIMENSION PROVIDES FOR MULTIPLE CHARACTER STRING TESTS      */
    /*      AGAINST THE SAME LINE.  NEGATION CAPABILITY IS ALSO PROVIDED AT EACH   */
    /*      LEVEL WITHIN A FILE'S CROSS-SECTION SO THAT DE_MORGAN'S RULES          */
    /*      RELATING "LOGICAL AND" AND "LOGICAL OR":                               */
    /*                                                                             */
    /*           ^(A & B) = ^A | ^B      ("|" IS THE PLI SYMBOL FOR "OR")          */
    /*           ^(A | B) = ^A & ^B      ("&" IS THE PLI SYMBOL FOR "AND")         */
    /*                                                                             */
    /*      ALONG WITH SOME OF THEIR USEFUL CONSEQUENCES USING DOUBLE NEGATION     */
    /*      TO EXCHANGE THE ROLES OF "AND" AND "OR":                               */
    /*                                                                             */
    /*            (A & B) = ^(^A | ^B)                                             */
    /*            (A | B) = ^(^A & ^B)                                             */
    /*                                                                             */
    /*           (^A & B) = ^( A | ^B)                                             */
    /*           (^A | B) = ^( A & ^B)                                             */
    /*                                                                             */
    /*      AND THE IDENTITY:                                                      */
    /*                                                                             */
    /*               A    =   ^(^A)                                                */
    /*                                                                             */
    /*      CAN BE USED TO USED TO ADVANTAGE.  NEGATION CAPABILITY ALSO ALLOWS     */
    /*      ENTRIES TO BE SELECTED BASED ON CONDITIONS THAT AREN'T SATISFIED       */
    /*      (E.G., TO FIND A SYSMOD THAT DOES CONTAIN JCLIN OR REFERENCES A        */
    /*      SYSGEN MACRO, BUT THAT DOESN'T BELONG TO A PARTICULAR FMID).           */
    /*                                                                             */
    /*            THE STRUCTURAL DECLARATION OF SCAN_ARRAY IS AS FOLLOWS:          */
    /*                                                                             */
    /*            01 SCAN_ARRAY                           CONTROLLED,              */
    /*               05 FILE(IFILE_MIN:IFILE_MAX),       -ONE CUBE FOR EACH FILE-  */
    /*                  09 SELECT_OPTION                  CHAR(008) VARYING,       */
    /*                  09 PLANE(IPLANE_MIN:IPLANE_MAX),                           */
    /*                     13 SELECT_OPTION               CHAR(008) VARYING,       */
    /*                     13 ROW(IROW_MIN:IROW_MAX),                              */
    /*                        17 SELECT_OPTION            CHAR(008) VARYING,       */
    /*                        17 COL(ICOL_MIN:ICOL_MAX),                           */
    /*                           21 BEG_POS               FIXED BINARY(15,0),      */
    /*                           21 END_POS               FIXED BINARY(15,0),      */
    /*                           21 POS_LEN               FIXED BINARY(15,0),      */
    /*                           21 OP                    CHAR(008) VARYING,       */
    /*                           21 OP_OIX                FIXED BINARY(15,0),      */
    /*                           21 STRING                CHAR(032) VARYING,       */
    /*                           21 STR_LEN               FIXED BINARY(15,0),      */
    /*                           21 STR_NIX               FIXED BINARY(15,0),      */
    /*                                                                             */
    /*      IF SCAN_ARRAY VARIABLES ARE SPECIFIED FOR A FILE, A "SCAN_RESULT"      */
    /*      IS CALCULATED FOR EACH ENTRY PROCESSED (SEE THE DESCRIPTION OF         */
    /*      MATCH_ARRAY FOR AN EXPLANATION OF WHEN ENTRIES ARE PROCESSED).         */
    /*      THREE RESULTS ARE RECOGNIZED IN SMPDCTRY OUTPUT:  SCANNED AND          */
    /*      SELECTED, SCANNED AND NOT SELECTED, AND NOT SCANNED.  FOR THE          */
    /*      PURPOSES OF ENTRY MATCHING, HOWEVER, SCANNED AND NOT SELECTED IS       */
    /*      EQUIVALENT TO NOT SCANNED.  THE "SCAN_RESULT" CALCULATION IS A THREE   */
    /*      STEP PROCESS:                                                          */
    /*                                                                             */
    /*           1. WHEN THE FIRST LINE OF A NEW ENTRY IS RECOGNIZED, ALL OF THE   */
    /*              SCAN_ARRAY ROW RESULTS ARE SET TO '0'B ('0'B = FALSE OR        */
    /*              NOT SELECTED, '1'B = TRUE OR SELECTED).                        */
    /*                                                                             */
    /*           2. A SCAN_ARRAY PLANE OR ROW IS CONSIDERED ACTIVE IF ANY COLUMN   */
    /*              SUBSTRUCTURE CONTAINS A "STRING" VALUE.  AS ENTRY LINES ARE    */
    /*              READ, EACH ACTIVE ROW IN EACH ACTIVE PLANE IS REVIEWED.  IF    */
    /*              THE ROW RESULT IS ALREADY SET TO '1'B, TESTS FOR THAT ROW      */
    /*              ARE SKIPPED (FOR SCANNING BUT NOT FOR HIGHLIGHTING) TO         */
    /*              REDUCE EXECUTION OVERHEAD.  WHEN THE RESULT FOR AN ACTIVE      */
    /*              ROW IS NOT YET SET TO '1'B, THE COLUMN SUBSTRUCTURES ARE       */
    /*              PROCESSED AGAINST THE CURRENT LINE, AND A ROW RESULT IS        */
    /*              CALCULATED.                                                    */
    /*                                                                             */
    /*              THE ROW-COLUMN STRUCTURING IS DESIGNED TO PROVIDE A WAY TO     */
    /*              DESCRIBE SEPARATE MULTIPLE TESTS AGAINST THE SAME LINE.  THE   */
    /*              TESTS FOR ALL ACTIVE COLUMNS IN A ROW MUST BE SATISFIED        */
    /*              AGAINST THE SAME LINE IN ORDER FOR A POSITIVE ROW RESULT TO    */
    /*              OCCUR.                                                         */
    /*                                                                             */
    /*           3. ONCE ALL LINES FOR AN ENTRY HAVE BEEN READ AND ROW RESULTS     */
    /*              HAVE BEEN DETERMINED, CALCULATION OF THE FINAL SCAN_RESULT     */
    /*              FOR THE ENTRY BEGINS.  A ROW'S RESULT IS FIRST COMPARED WITH   */
    /*              ITS SELECT_OPTION.  IF EACH ACTIVE ROW'S RESULT IS THE SAME    */
    /*              AS ITS SELECT_OPTION, THE PLANE'S RESULT IS SET TO '1'B.       */
    /*              OTHERWISE, THE PLANE'S SCAN_RESULT IS SET TO '0'B.  A          */
    /*              SCAN_RESULT MATCHES ITS CORRESPONDING SELECT_OPTION IF         */
    /*              EITHER THE RESULT IS '1'B AND THE OPTION IS "SELECT", OR THE   */
    /*              RESULT IS '0'B AND THE OPTION IS "EXCLUDE".  IN EFFECT, THE    */
    /*              FINAL RESULTS FOR THE ACTIVE ROWS ARE "ANDED" TOGETHER.        */
    /*                                                                             */
    /*              ONCE THE PLANE RESULTS HAVE BEEN DETERMINED, THE FILE (CUBE)   */
    /*              RESULT IS CALCULATED.  EACH ACTIVE PLANE'S RESULT IS           */
    /*              COMPARED WITH ITS CORRESPONDING SELECT_OPTION.  IF ANY         */
    /*              ACTIVE PLANE'S RESULT MATCHES ITS SELECT_OPTION, THE ENTRY'S   */
    /*              FILE (CUBE) SCAN_RESULT IS SET TO '1'B.  OTHERWISE IT IS SET   */
    /*              TO '0'B.  IN EFFECT, THE FINAL PLANE RESULTS ARE "ORED"        */
    /*              TOGETHER.                                                      */
    /*                                                                             */
    /*              THE FILE SCAN_RESULT IS THE NEXT-TO-LAST STEP IN CALCULATING   */
    /*              THE ENTRY'S SCAN_RESULT.  THE FILE RESULT IS COMPARED WITH     */
    /*              THE SELECT_OPTION AT THE FILE LEVEL.  IF THEY AGREE, THE       */
    /*              FINAL SCAN_RESULT FOR THE ENTRY IS SET TO '1'B, OTHERWISE      */
    /*              '0'B.                                                          */
    /*                                                                             */
    /*              THE FILE-PLANE-ROW STRUCTURE IS DESIGNED TO PROVIDE A WAY TO   */
    /*              DESCRIBE NOT/OR/AND OPERATIONS TO BE APPLIED TO THE ROW        */
    /*              RESULTS OBTAINED FROM EXAMINING AN ENTRY'S LISTING LINES.  A   */
    /*              FULL BOOLEAN EXPRESIION CAN BE CONSTRUCTED, ALTHOUGH SOME      */
    /*              DUPLICATION MAY BE REQUIRED.  SELECT OPTIONS CORRESPOND TO     */
    /*              "NOT", PLANES TO "OR", AND ROWS TO "AND".                      */
    /*                                                                             */
    /*      AN ENTRY'S FINAL SCAN_RESULT IS PART OF THE INFORMATION USED BY        */
    /*      MATCH_ARRAY PROCESSING TO DECIDE WHICH ENTRIES SHOULD BE WRITTEN TO    */
    /*      OUTPUT DATA SETS.                                                      */
    /*                                                                             */
    /*            THE SCAN_ARRAY VARIABLES THAT CAN BE SUPPLIED IN THE "SYSIN"     */
    /*      DATA STREAM ARE LISTED ABOVE IN THE INPUT SECTION.  IF USED, THEY      */
    /*      SHOULD BE SPECIFIED WITH REQUIRED LEVELS OF QUALIFICATION AND          */
    /*      SUBSCRIPTS AS SHOWN THERE.  NOT ALL SCAN_ARRAY VARIABLES CAN BE        */
    /*      SPECIFIED:  SOME, SUCH AS STR_LEN, AND STR_NIX ARE CALCULATED AFTER    */
    /*      ALL VARIABLES HAVE BEEN READ, AND POS_LEN IS USUALLY ALLOWED TO        */
    /*      DEFAULT.  THE VARIABLES THAT CAN BE SUPPLIED, ALONG WITH THEIR         */
    /*      DEFAULT VALUES ARE:                                                    */
    /*                                                                             */
    /*             .SELECT_OPTION.  THE SELECT OPTIONS CAN BE SPECIFIED AT THE     */
    /*              FILE, PLANE AND ROW LEVELS AND INDICATE NEGATION IF            */
    /*              REQUESTED.  THE VALUES THAT CAN BE SPECIFIED ARE:              */
    /*                                                                             */
    /*                 'SELECT'                                                    */
    /*                 'EXCLUDE'                                                   */
    /*                                                                             */
    /*              THE DEFAULT SPECIFICATION IS "SELECT".  A VALUE OF "EXCLUDE"   */
    /*              REQUESTS NEGATION.  THE EFFECTS OF THESE VARIABLES IN          */
    /*              COMPUTING THE LINE SCAN RESULTS FOR AN INDIVIDUAL ENTRY        */
    /*              ARE DESCRIBED BELOW.                                           */
    /*                                                                             */
    /*             .BEG_POS.  THE BEG_POS VARIABLE IS A NUMBER INDICATING THE      */
    /*              STARTING POSITION WITHIN THE LISTING LINE AT WHICH             */
    /*              COMPARISON IS TO BE PERFORMED OR SCANNING IS TO BEGIN.  THIS   */
    /*              NUMBER IS ASSIGNED EXCLUSIVE OF THE PRINT CONTROL CHARACTER,   */
    /*              WITH THE LEFTMOST PRINTED CHARACTER BEING 001.  THE DEFAULT    */
    /*              VALUE DEPENDS ON THE TYPE OF OPERATION (SEE "OP") AS           */
    /*              FOLLOWS:                                                       */
    /*                                                                             */
    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED.  NOT USED.       */
    /*                                                                             */
    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO 011.     */
    /*                                                                             */
    /*                -LINE  DATA COMPARE:   029.                                  */
    /*                                                                             */
    /*                -LINE  DATA    SCAN:   029.                                  */
    /*                                                                             */
    /*              BEG_POS CAN DESIGNATE ANY POSITION ON THE LINE: 001 - 120,     */
    /*              BUT SHOULD BE LESS THAN OR EQUAL IN VALUE TO END_POS.          */
    /*                                                                             */
    /*             .END_POS.  THE END_POS VARIABLE IS A NUMBER INDICATING THE      */
    /*              ENDING POSITION WITHIN THE LISTING LINE AT WHICH COMPARISON    */
    /*              IS TO BE PERFORMED OR SCANNING IS TO BEGIN.  THIS NUMBER IS    */
    /*              ASSIGNED EXCLUSIVE OF THE PRINT CONTROL CHARACTER, WITH THE    */
    /*              LEFTMOST PRINTED CHARACTER BEING 001.  THE DEFAULT VALUE       */
    /*              DEPENDS ON THE TYPE OF OPERATION (SEE "OP") AS FOLLOWS:        */
    /*                                                                             */
    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED. NOT USED.        */
    /*                                                                             */
    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO          */
    /*                                       BEG_POS+STR_LEN-1 OR 025,             */
    /*                                       WHICHEVER IS LESS.                    */
    /*                                                                             */
    /*                -LINE  DATA COMPARE:   BEG_POS+STR_LEN-1 OR 120,             */
    /*                                       WHICHEVER IS LESS.                    */
    /*                                                                             */
    /*                -LINE  DATA    SCAN:   120.                                  */
    /*                                                                             */
    /*              END_POS CAN DESIGNATE ANY POSITION ON THE LINE: 001 - 120,     */
    /*              BUT SHOULD BE GREATER THAN OR EQUAL IN VALUE TO BEG_POS.       */
    /*                                                                             */
    /*             .POS_LEN.  THE POS_LEN VARIABLE IS A NUMBER INDICATING THE      */
    /*              NUMBER OF PRINT POSTITONS BETWEEN BEG_POS AND END_POS.         */
    /*              POS_LEN CAN BE SPECIFIED IN LIEU OF END_POS, BUT IT IS         */
    /*              USUALLY ALLOWED TO DEFAULT.  IF POS_LEN IS PROVIDED RATHER     */
    /*              THAN END_POS, END_POS IS CALCULATED.  THE CALCULATED VALUE     */
    /*              FOR POS_LEN DEPENDS ON THE TYPE OF OPERATION (SEE "OP") AS     */
    /*              FOLLOWS:                                                       */
    /*                                                                             */
    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED. NOT USED.        */
    /*                                                                             */
    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO          */
    /*                                       END_POS-BEG_POS+1 OR 015,             */
    /*                                       WHICHEVER IS LESS.                    */
    /*                                                                             */
    /*                -LINE  DATA COMPARE:   END_POS-BEG_POS+1 OR STR_LEN,         */
    /*                                       WHICHEVER IS LESS.                    */
    /*                                                                             */
    /*                -LINE  DATA    SCAN:   END_POS-BEG_POS+1 OR 120,             */
    /*                                       WHICHEVER IS LESS.                    */
    /*                                                                             */
    /*              POS_LEN IS RECALCULATED AFTER THE FINAL VALUES FOR             */
    /*              BEG_POS AND END_POS HAVE BEEN DETERMINED.                      */
    /*                                                                             */
    /*             .OP.  THIS VARIABLE GOVERNS HOW THE "STRING" IS COMPARED WITH   */
    /*              THE ENTRY'S LISTING LINE WITHIN THE BOUNDS DEFINED BY          */
    /*              BEG_POS AND END_POS.  IN EACH GROUP OF COMPARE/SCAN            */
    /*              OPERATIONS, SEVERAL COMPARISON OPERATORS ARE DEFINED.  FOR     */
    /*              THREE OF THE FOUR, GENERIC COMPARISONS CAN ALSO BE             */
    /*              PERFORMED.  THE OPERATIONS SUPPORTED WITHIN EACH GROUP ARE     */
    /*              AS FOLLOWS:                                                    */
    /*                                                                             */
    /*                -ENTRY TYPE COMPARE:                                         */
    /*                            EQENTRY:   THE ENTRY TYPE MUST BE THE SAME AS    */
    /*                                       THAT SPECIFIED IN "STRING".           */
    /*                            NEENTRY:   THE ENTRY TYPE MUST NOT BE THE SAME   */
    /*                                       AS THAT SPECIFIED IN "STRING".        */
    /*                   EQENTRY SYNONYMS:   EQNTRY,     EQN.                      */
    /*                   NEENTRY SYNONYMS:   NENTRY,     NEN,                      */
    /*                                      ^EQENTRY,   ^EQNTRY,  ^EQN.            */
    /*                                                                             */
    /*                -LINE  TYPE COMPARE:                                         */
    /*                             EQLINE:   THE LINE TYPE, FOR THE NUMBER OF      */
    /*                                       CHARACTERS IN "STRING" (I.E., A       */
    /*                                       PREFIX COMPARISON IS DONE) MUST BE    */
    /*                                       THE SAME AS THAT SPECIFIED IN         */
    /*                                       "STRING".                             */
    /*                             NELINE:   THE LINE TYPE, FOR THE NUMBER OF      */
    /*                                       CHARACTERS IN "STRING" (I.E., A       */
    /*                                       PREFIX COMPARISON IS DONE) MUST NOT   */
    /*                                       BE THE SAME AS THAT SPECIFIED IN      */
    /*                                       "STRING".                             */
    /*                            EQGLINE:   THE LINE TYPE, FOR THE NUMBER OF      */
    /*                                       CHARACTERS IN "STRING" (I.E., A       */
    /*                                       PREFIX COMPARISON IS DONE) MUST       */
    /*                                       GENERICALLY COMPARE EQUAL TO THE      */
    /*                                       VALUE SPECIFIED IN "STRING".          */
    /*                            NEGLINE:   THE LINE TYPE, FOR THE NUMBER OF      */
    /*                                       CHARACTERS IN "STRING" (I.E., A       */
    /*                                       PREFIX COMPARISON IS DONE) MUST       */
    /*                                       GENERICALLY COMPARE NOT EQUAL TO      */
    /*                                       THE VALUE SPECIFIED IN "STRING".      */
    /*                    EQLINE SYNONYMS:    EQLIN,    EQL.                       */
    /*                    NELINE SYNONYMS:    NELIN,    NEL,                       */
    /*                                       ^EQLINE,  ^EQLIN,    ^EQL.            */
    /*                   EQGLINE SYNONYMS:    EQGLIN,   EQGL.                      */
    /*                   NEGLINE SYNONYMS:    NEGLIN,   NEGL,                      */
    /*                                       ^EQGLINE, ^EQGLIN,   ^EQGL.           */
    /*                                                                             */
    /*                -LINE  DATA COMPARE:                                         */
    /*                             LTCMPR:   THE CHARACTER STRING IN THE ENTRY     */
    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
    /*                                       LESS THAN THE VALUE  SPECIFIED IN     */
    /*                                       "STRING".                             */
    /*                             LECMPR:   THE CHARACTER STRING IN THE ENTRY     */
    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
    /*                                       LESS THAN OR EQUAL TO THE VALUE       */
    /*                                       SPECIFIED IN "STRING".                */
    /*                             EQCMPR:   THE CHARACTER STRING IN THE ENTRY     */
    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
    /*                                       EQUAL TO THE VALUE SPECIFIED IN       */
    /*                                       "STRING".                             */
    /*                             NECMPR:   THE CHARACTER STRING IN THE ENTRY     */
    /*                                       LINE, STARTING AT BEG_POS, MUST NOT   */
    /*                                       BE EQUAL TO THE VALUE SPECIFIED IN    */
    /*                                       "STRING".                             */
    /*                             GECMPR:   THE CHARACTER STRING IN THE ENTRY     */
    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
    /*                                       GREATER THAN OR EQUAL TO THE VALUE    */
    /*                                       SPECIFIED IN "STRING".                */
    /*                             GTCMPR:   THE CHARACTER STRING IN THE ENTRY     */
    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
    /*                                       GREATER THAN THE VALUE SPECIFIED IN   */
    /*                                       "STRING".                             */
    /*                            EQGCMPR:   THE CHARACTER STRING IN THE ENTRY     */
    /*                                       LINE, STARTING AT BEG_POS, MUST       */
    /*                                       GENERICALLY COMPARE EQUAL TO THE      */
    /*                                       VALUE SPECIFIED IN "STRING".          */
    /*                            NEGCMPR:   THE CHARACTER STRING IN THE ENTRY     */
    /*                                       LINE, STARTING AT BEG_POS, MUST       */
    /*                                       GENERICALLY COMPARE NOT EQUAL TO      */
    /*                                       THE VALUE SPECIFIED IN "STRING".      */
    /*                    LTCMPR SYNONYMS:   LTCPR,    LTC,      LT,               */
    /*                                      ^GECMPR,  ^GECPR,   ^GEC,    ^GE.      */
    /*                    LECMPR SYNONYMS:   LECPR,    LEC,      LE,               */
    /*                                      ^GTCMPR,  ^GTCPR,   ^GTC,    ^GT.      */
    /*                    EQCMPR SYNONYMS:   EQCPR,    EQC,      EQ.               */
    /*                    NECMPR SYNONYMS:   NECPR,    NEC,      NE,               */
    /*                                      ^EQCMPR,  ^EQCPR,   ^EQC,    ^EQ.      */
    /*                    GECMPR SYNONYMS:   GECPR,    GEC,      GE,               */
    /*                                      ^LTCMPR,  ^LTCPR,   ^LTC,    ^LT.      */
    /*                    GTCMPR SYNONYMS:   GTCPR,    GTC,      GT,               */
    /*                                      ^LECMPR,  ^LECPR,   ^LEC,    ^LE.      */
    /*                   EQGCMPR SYNONYMS:   EQGCPR,   EQGC,     EQG.              */
    /*                   NEGCMPR SYNONYMS:   NEGCPR,   NEGC,     NEG,              */
    /*                                      ^EQGCPR,  ^EQGC,     ^EQG.             */
    /*                                                                             */
    /*                -LINE  DATA    SCAN:                                         */
    /*                             EQSCAN:   THE CHARACTERS IN THE ENTRY LINE      */
    /*                                       BETWEEN BEG_POS AND END_POS MUST      */
    /*                                       CONTAIN AT LEAST ONE SUBSTRING        */
    /*                                       EQUAL TO THE VALUE SPECIFIED IN       */
    /*                                       "STRING".  SUBSTRINGS ARE EXAMINED    */
    /*                                       STARTING AT BEG_POS AND STOPPING AT   */
    /*                                       (END_POS-STR_LEN+1).                  */
    /*                             NESCAN:   THE CHARACTERS IN THE ENTRY LINE      */
    /*                                       BETWEEN BEG_POS AND END_POS MUST      */
    /*                                       NOT CONTAIN ANY SUBSTRING EQUAL TO    */
    /*                                       THE VALUE SPECIFIED IN "STRING".      */
    /*                                       SUBSTRINGS ARE EXAMINED STARTING AT   */
    /*                                       BEG_POS AND STOPPING AT               */
    /*                                       (END_POS-STR_LEN+1).                  */
    /*                            EQGSCAN:   THE CHARACTERS IN THE ENTRY LINE      */
    /*                                       BETWEEN BEG_POS AND END_POS MUST      */
    /*                                       CONTAIN AT LEAST ONE SUBSTRING        */
    /*                                       GENERICALLY EQUAL TO THE VALUE        */
    /*                                       SPECIFIED IN "STRING".  SUBSTRINGS    */
    /*                                       ARE EXAMINED STARTING AT BEG_POS      */
    /*                                       AND STOPPING AT                       */
    /*                                       (END_POS-STR_LEN+1).                  */
    /*                            NEGSCAN:   THE CHARACTERS IN THE ENTRY LINE      */
    /*                                       BETWEEN BEG_POS AND END_POS MUST      */
    /*                                       NOT CONTAIN ANY SUBSTRING             */
    /*                                       GENERICALLY EQUAL TO THE VALUE        */
    /*                                       SPECIFIED IN "STRING".  SUBSTRINGS    */
    /*                                       ARE EXAMINED STARTING AT BEG_POS      */
    /*                                       AND STOPPING AT                       */
    /*                                       (END_POS-STR_LEN+1).                  */
    /*                    EQSCAN SYNONYMS:    EQSCN,    EQS.                       */
    /*                    NESCAN SYNONYMS:    NESCN,    NES,                       */
    /*                                       ^EQSCAN,  ^EQSCN,     ^EQS.           */
    /*                   EQGSCAN SYNONYMS:    EQGSCN,   EQGS.                      */
    /*                   NEGSCAN SYNONYMS:    NEGSCN,   NEGS,                      */
    /*                                       ^EQGSCAN, ^EQGSCN,    ^EQGS.          */
    /*                                                                             */
    /*              THE DEFAULT SPECIFICATION FOR "OP" IS "EQSCAN".                */
    /*                                                                             */
    /*             .STRING.  THIS IS THE CHARACTER STRING DATA WHOSE PRESENCE OR   */
    /*              ABSENCE IS BEING SOUGHT.  IT CAN HAVE A MAXIMUM LENGTH OF 32   */
    /*              BYTES.  A SCAN_ARRAY ELEMENT IS CONSIDERED ACTIVE ONLY IF A    */
    /*              CHARACTER STRING VALUE OF LENGTH GREATER THAN ZERO HAS BEEN    */
    /*              SPECIFIED (THE STRING CAN BE BLANK).  THE DATA PROVIDED FOR    */
    /*              "STRING" WILL DEPEND ON THE TYPE OF OPERATION (SEE "OP") AS    */
    /*              FOLLOWS:                                                       */
    /*                                                                             */
    /*                -ENTRY TYPE COMPARE:   NAMES A TYPE OF ENTRY (E.G.,          */
    /*                                       "DDDEF", "ASSEM", "LMOD", "MOD",      */
    /*                                       "SYSMOD").  A FULL LIST OF VALUES     */
    /*                                       APPEARS BELOW IN THE DESCRIPTION OF   */
    /*                                       "TYPE" FOR MATCH_ARRAY.  WITHIN       */
    /*                                       REASON, ABBREVIATIONS ARE             */
    /*                                       SUPPORTED.  TO REDUCE EXECUTION       */
    /*                                       OVERHEAD, THE ENTRY TYPE NAME IS      */
    /*                                       CONVERTED TO AN INTERNAL INDEX        */
    /*                                       VALUE (AND SAVED IN STR_NIX).  THE    */
    /*                                       INDEX VALUE IS USED FOR THE ACTUAL    */
    /*                                       TEST AGAINST THE LINE.                */
    /*                                                                             */
    /*                -LINE  TYPE COMPARE:   IDENTIFIES A TYPE OF LISTING LINE.    */
    /*                                       THE BEST WAY TO DETERMINE VALUES TO   */
    /*                                       USE IS TO EXAMINE AN ACTUAL SMP/E     */
    /*                                       LIST OUTPUT.                          */
    /*                                                                             */
    /*                -LINE  DATA COMPARE:   THE COMPARE ARGUMENT STRING FOR       */
    /*                                       REGULAR COMPARE OPERATIONS, OR THE    */
    /*                                       PATTERN STRING FOR GENERIC            */
    /*                                       COMPARES.                             */
    /*                                                                             */
    /*                -LINE  DATA    SCAN:   THE SCAN ARGUMENT STRING OR THE       */
    /*                                       PATTERN STRING, DEPENDING ON          */
    /*                                       WHETHER THE SCAN OPERATION IS OF      */
    /*                                       THE NORMAL VARIETY, OR GENERIC.       */
    /*                                                                             */
    /*              "STRING" HAS NO DEFAULT.  IF A STRING VALUE IS NOT PROVIDED,   */
    /*              THE SCAN_ARRAY COLUMN SUBSTRUCTURE IS NOT USED DURING ENTRY    */
    /*              PROCESSING.  IF A VALUE IS PROVIDED, ITS LENGTH DETERMINED     */
    /*              AND THEN SAVED IS SCAN_ARRAY VARIABLE STR_LEN.                 */
    /*                                                                             */
    /*            THE DISTINCTION BETWEEN THE "NE" COLUMN OPERATIONS AND A ROW     */
    /*      LEVEL SELECT_OPTION OF "EXCLUDE" NEEDS TO BE CLARIFIED.  COLUMN        */
    /*      OPERATIONS ARE USED TO TEST WHETHER A CONDITION OCCURS OR DOESN'T      */
    /*      OCCUR ON A GIVEN LINE.  ONCE A ROW TEST HAS BEEN SATISFIED FOR ANY     */
    /*      LINE OF AN ENTRY, HOWEVER, THE TEST IS SATISFIED FOR THE ENTRY.        */
    /*      CONSEQUENTLY, AN "NE" OPERATION MAY NOT RESULT IN ALL PERTINENT        */
    /*      LINES BEING TESTED.  TO VERIFY THAT A PARTICULAR VALUE DOES NOT        */
    /*      APPEAR ON ANY ENTRY LINE (I.E., THAT ALL PERTINENT LINES FAIL THE      */
    /*      TEST), USE A POSITIVE TEST SUCH AS "EQ" COMBINED WITH A ROW            */
    /*      SELECT_OPTION OF "EXCLUDE".  NEGATIVELY-EXPRESSED OPERATIONS ARE       */
    /*      GENERALLY USED IN COMBINATION WITH OTHER TESTS, OR WHEN THE DATA OF    */
    /*      INTEREST APPEAR ON ONLY ONE LISTING LINE.                              */
    /*                                                                             */
    /*            WHILE GENERIC SEARCH AND COMPARE FACILITIES ARE AVAILABLE IN A   */
    /*      VARIETY OF PROGRAMS AND PRODUCTS, THE GENERIC OPERATIONS PROVIDED IN   */
    /*      THE SCAN_ARRAY ARE MOST SIMILAR TO THE PICTURE STRING FEATURE OF THE   */
    /*      ISPF BROWSE AND EDIT COMMANDS.  A NOTE FOR THE LAWYERS - ISPF IS A     */
    /*      PROGRAM PRODUCT OF IBM.  WHEN GENERIC COMPARISON OR GENERIC SCANNING   */
    /*      IS REQUESTED, THE SCAN_ARRAY SEARCH STRING IS TREATED AS A MASK OR     */
    /*      PATTERN.  THE CHARACTER STRING FROM THE LISTING LINE BEING EXAMINED    */
    /*      IS COMPARED CHARACTER BY CHARACTER WITH THE PATTERN STRING FROM        */
    /*      SCAN_ARRAY, PROCESSING FROM LEFT TO RIGHT.  THE FIRST CHARACTER        */
    /*      STRING CHARACTER NOT SATISFYING THE REQUIREMENTS OF ITS PATTERN        */
    /*      STRING CHARACTER STOPS THE COMPARE AND GIVES A NOT-EQUAL RESULT.       */
    /*      WHEN ALL CORRESPONDING CHARACTERS ARE EQUAL, A CHARACTER STRING        */
    /*      LONGER THAN THE PATTERN STRING IS CHECKED TO VERIFY THAT BYTES         */
    /*      EXTENDING ON THE RIGHT BEYOND THE LENGTH OF THE PATTERN STRING ARE     */
    /*      BLANK.  LIKEWISE, A PATTERN STRING LONGER THAN THE CHARACTER STRING    */
    /*      IS ALSO CHECKED TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT        */
    /*      BEYOND THE LENGTH OF THE CHARACTER STRING ARE EITHER BLANK, OR THE     */
    /*      "ANY" SELECTION BYTE("*").                                             */
    /*                                                                             */
    /*            A GENERIC COMPARISON PATTERN CHARACTER REPRESENTS EITHER A       */
    /*      GROUP OF CHARACTERS, OR ITSELF.  BECAUSE CHARACTERS WITHIN A GROUP     */
    /*      WILL NOT, IN GENERAL, BE CONSECUTIVE WITHOUT GAPS IN THE COLLATING     */
    /*      SEQUENCE, A GENERIC COMPARISON ORDER IN TERMS OF HIGH, LOW, AND        */
    /*      EQUAL CANNOT BE DEFINED.  THE BEST THAT CAN BE DETERMINED IS EQUAL     */
    /*      OR NOT EQUAL.  THE FOLLOWING CHARACTERS HAVE SPECIAL SIGNIFICANCE IN   */
    /*      PATTERN STRINGS, AND ARE USED TO SELECT GROUPS OF CHARACTERS:          */
    /*                                                                             */
    /*            "*" - THE CORRESPONDING CHARACTER STRING CHARACTER CAN BE        */
    /*                  ANY CHARACTER.                                             */
    /*                                                                             */
    /*            "#" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  NUMERIC AND CAN BE EITHER UPPER OR LOWER CASE.             */
    /*                                                                             */
    /*            "@" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  ALPHABETIC AND CAN BE EITHER UPPER OR LOWER CASE.          */
    /*                                                                             */
    /*            "[" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  ONE OF THE NATIONAL CHARACTERS: "$", "#", OR "@".          */
    /*                  BECAUSE OF THEIR BIT REPRESENTATIONS, NATIONAL             */
    /*                  CHARACTERS ARE UPPERCASE.                                  */
    /*                                                                             */
    /*            "%" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  ALPHABETIC OR ONE OF THE NATIONAL CHARACTERS.              */
    /*                                                                             */
    /*            "_" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  ALPHABETIC, NUMERIC,  OR ONE OF THE NATIONAL CHARACTERS.   */
    /*                                                                             */
    /*            ">" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  ONE OF THE NATIONAL CHARACTERS, OR AN UPPERCASE            */
    /*                  ALPHABETIC OR NUMERIC CHARACTER.                           */
    /*                                                                             */
    /*            "<" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  A LOWERCASE ALPHABETIC OR NUMERIC CHARACTER.               */
    /*                                                                             */
    /*            "!" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  ONE OF THE SPECIAL CHARACTERS.                             */
    /*                                                                             */
    /*            "-" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  NON-NUMERIC.                                               */
    /*                                                                             */
    /*            "^" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  NON-BLANK.                                                 */
    /*                                                                             */
    /*            "?" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
    /*                  ONE OF THE INVALID CHARACTERS.                             */
    /*                                                                             */
    /*      ALL OTHER CHARACTERS IN A PATTERN STRING (BLANKS, ALPHABETICS,         */
    /*      NUMERIC DIGITS, AND ESPECIALLY THE CHARACTERS "=" "." "," ":" "$"      */
    /*      "(" AND ")" REPRESENT THEMSELVES.  WHEN A PATTERN STRING CHARACTER     */
    /*      REPRESENTS ITSELF, THE CHARACTER STRING CHARACTER MUST BE THE SAME     */
    /*      AS THE PATTERN CHARACTER.  FOR EXAMPLE, IN THE PATTERN STRING          */
    /*      "%RM####" USED TO SEARCH FOR RMF FMID'S, THE CHARACTERS "R" AND "M"    */
    /*      REPRESENT THEMSELVES.  EVERY ATTEMPT WAS MADE TO CHOOSE GENERIC        */
    /*      SELECTION CHARACTERS THAT WOULD BE UNLIKELY TO APPEAR IN THE DATA      */
    /*      EXCEPT WHERE TRADITION STRONGLY DICTATED OTHERWISE (E.G., THE CHOICE   */
    /*      OF "#" TO SELECT NUMERIC CHARACTERS).                                  */
    /*                                                                             */
    /*            >>>>>MATCH_ARRAY.<<<<<                                           */
    /*            MATCH_ARRAY PROVIDES SMPSCAN WITH THE INFORMATION IT NEEDS TO    */
    /*      DETERMINE WHICH ENTRIES SHOULD BE WRITTEN TO OUTPUT DATA SETS.  THE    */
    /*      MATCH_ARRAY CONTENTS SPECIFY ENTRY MATCH CRITERIA WHICH CAN APPLY TO   */
    /*      A SINGLE INPUT LISTING, OR TO MULTIPLE LISTINGS (CROSS-ZONES)          */
    /*      CONCURRENTLY.  MATCH CRITERIA ARE BASED ON A COMBINATION OF ENTRY      */
    /*      TYPE (SYSMOD, MAC, MOD, LMOD, OR WHATEVER), ON THE PRESENCE OR         */
    /*      ABSENCE OF AN ENTRY IN A PARTICULAR INPUT LISTING, AND ON AN ENTRY'S   */
    /*      SCAN_RESULT IF SCAN_ARRAY VARIABLES WERE PROVIDED FOR THAT FILE.       */
    /*      THE OUTPUT DECISION IS BASED ON WHETHER THE MATCH CRITERIA WERE        */
    /*      SATISFIED AND, IF SCAN RESULTS ARE DEEMED RELEVANT, ON WHETHER SCAN    */
    /*      RESULTS WERE POSITIVE.                                                 */
    /*                                                                             */
    /*            MATCH_ARRAY IS DECLARED AS A TWO DIMENSIONAL ARRAY OF            */
    /*      STRUCTURES.  THE FIRST SUBSCRIPT IS THE MATCH_ARRAY ENTRY NUMBER AND   */
    /*      THE SECOND, WHEN REQUIRED, IS THE FILE NUMBER.  THE STRUCTURAL         */
    /*      DECLARATION OF MATCH_ARRAY IS:                                         */
    /*                                                                             */
    /*            01 MATCH_ARRAY                          CONTROLLED,              */
    /*               05 ENTRY(IMATCH_MIN:IMATCH_MAX),                              */
    /*                  09 TYPE                           CHAR(016) VARYING,       */
    /*                  09 COMPARE_TEST                   CHAR(008) VARYING,       */
    /*                  09 FILE(IFILE_MIN:IFILE_MAX),                              */
    /*                     13 COMPARE_OPTION              CHAR(012) VARYING,       */
    /*                     13 COMPARE_SELECT              CHAR(012) VARYING,       */
    /*                     13 WRITE_OPTION                CHAR(012) VARYING,       */
    /*                     13 WRITE_SELECT                CHAR(012) VARYING,       */
    /*                                                                             */
    /*            AS ENTRIES ARE READ, SMPSCAN FORMS A COMPARE KEY FROM THE        */
    /*      ENTRY TYPE, AND ENTRY NAME WITHIN TYPE.  FOR COMPARE KEY PURPOSES      */
    /*      THE ENTRY TYPE IS CONVERTED TO A TWO DIGIT INDEX WHOSE VALUES ARE IN   */
    /*      THE SAME ORDER AS ENTRY TYPES APPEAR IN SMP/E LISTINGS.  THIS IS THE   */
    /*      SAME INDEX VALUE MENTIONED IN REGARD TO ENTRY TYPE COMPARE             */
    /*      OPERATIONS IN THE DESCRIPTION OF THE SCAN_ARRAY "STRING" VARIABLE      */
    /*      ABOVE.  THE COMPARE KEY IS USED TO SYNCHRONIZE THE PROCESSING OF       */
    /*      MULTIPLE LISTING INPUTS BECAUSE IT DEFINES AN ORDER FOR THE INPUT      */
    /*      AND ALLOWS ENTRIES WITH THE SAME NAME TO BE IDENTIFIED ACROSS ZONES.   */
    /*      THIS KEY TECHNIQUE WORKS BECAUSE SMP/E LISTS ENTRIES WITHIN TYPE IN    */
    /*      ASCENDING ORDER BY NAME, AND ENTRY TYPES ALWAYS APPEAR IN THE SAME     */
    /*      ORDER IN OUTPUT LISTINGS.  THIS CONSISTENCY PROBABLY REFLECTS          */
    /*      SMP/E'S ZONE KEY CONSTRUCTION TECHNIQUE.                               */
    /*                                                                             */
    /*            ONCE THE FIRST ENTRY HAS BEEN READ FROM EACH ACTIVE INPUT        */
    /*      FILE, SMPSCAN CHECKS THE COMPARE KEYS, AND IDENTIFIES THOSE WITH THE   */
    /*      LOWEST COMPARE KEY.  THERE WILL ALWAYS BE AT LEAST ONE SUCH ENTRY,     */
    /*      AND THERE MAY SEVERAL IF THE ENTRY APPEARS IN MORE THAT ONE INPUT      */
    /*      LISTING.  THESE ENTRIES ARE THEN PROCESSED AS A GROUP.  PROCESSING     */
    /*      CONSISTS OF TESTING EACH ACTIVE ENTRY OF MATCH_ARRAY TO SEE IF THIS    */
    /*      GROUP OF ENTRIES IS A "MATCH", AND THEN APPLYING EACH "MATCHING"       */
    /*      ARRAY ENTRY'S OUTPUT INSTRUCTIONS TO EACH GROUP MEMBER.  A "MATCH"     */
    /*      IS DEFINED IN TERMS OF THE VARIABLES TYPE, COMPARE_TEST,               */
    /*      COMPARE_OPTION, AND COMPARE_SELECT:                                    */
    /*                                                                             */
    /*            1. MATCH_ARRAY TYPE MUST BE "ALL", OR MUST BE THE SAME AS THE    */
    /*               ENTRY TYPE FOR THE GROUP (ENTRIES OF DIFFERENT TYPES WILL     */
    /*               NOT BE IN THE SAME GROUP).                                    */
    /*                                                                             */
    /*            2. FOR EACH ACTIVE FILE, COMPARE_OPTION AND COMPARE_SELECT ARE   */
    /*               CHECKED AGAINST THE FILE'S CONTRIBUTION TO THE GROUP.  EACH   */
    /*               ACTIVE FILE EITHER HAS OR DOESN'T HAVE AN ENTRY IN THE        */
    /*               GROUP, AND EACH ENTRY IN THE GROUP HAS EITHER A POSITIVE      */
    /*               ('1'B) OR NEGATIVE ('0'B) SCAN_RESULT.  COMPARE_OPTION        */
    /*               INDICATES WHETHER THE FILE MUST OR MUST NOT HAVE AN ENTRY     */
    /*               IN THE GROUP, OR WHETHER MEMBERSHIP IN THE GROUP IS           */
    /*               OPTIONAL.  COMPARE_SELECT IS CHECKED IF AN ENTRY APPEARS IN   */
    /*               THE GROUP (WHETHER MANDATORY OR OPTIONAL).  AN ABSENT ENTRY   */
    /*               DOESN'T HAVE A SCAN_RESULT.  COMPARE_SELECT INDICATES         */
    /*               WHETHER AN ENTRY MUST HAVE A POSITIVE OR NEGATIVE             */
    /*               SCAN_RESULT, OR THE SCAN_RESULT IS TO BE DISREGARDED FOR      */
    /*               MATCHING PURPOSES (COMPARE_SELECT AND WRITE_SELECT ARE        */
    /*               INDEPENDENT OF EACH OTHER).                                   */
    /*                                                                             */
    /*            3. COMPARE_TEST AFFECTS THE WAY THE COMPARE_OPTION AND           */
    /*               COMPARE_SELECT TESTS ARE ASSESED TO DETERMINE A "MATCH".      */
    /*               IF COMPARE_TEST IS "ALL", THE COMPARE_OPTION/COMPARE_SELECT   */
    /*               TESTS MUST BE TRUE FOR ALL ACTIVE FILES.  IF COMPARE_TEST     */
    /*               IS "ANY", AT LEAST ONE OF THE COMPARE_OPTION/COMPARE_SELECT   */
    /*               TESTS MUST BE TRUE FOR AN ACTIVE FILE.                        */
    /*                                                                             */
    /*      IF A MATCH_ARRAY ENTRY'S COMPARE INSTRUCTION YIELD A "MATCH", THE      */
    /*      ARRAY ENTRY'S OUTPUT INSTRUCTIONS ARE APPLIED TO EACH ENTRY IN THE     */
    /*      GROUP.  AN ABSENT ENTRY CAN'T BE WRITTEN.  THE OUTPUT INSTRUCTIONS     */
    /*      ARE GIVEN BY THE VARIABLES WRITE_OPTION AND WRITE_SELECT:              */
    /*                                                                             */
    /*            1. FOR EACH ACTIVE FILE, WRITE_OPTION INDICATES WHETHER THE      */
    /*               ENTRY IS TO BE WRITTEN IF THE GROUP IS A "MATCH".             */
    /*               WRITE_OPTION IS INDEPENDENT OF COMPARE_OPTION, ESPECIALLY     */
    /*               WHEN COMPARE_TEST IS "ANY".  FOR EXAMPLE, FOR MULTIPLE        */
    /*               INPUTS, COMPARE_TEST='ANY' ALONG WITH                         */
    /*               COMPARE_OPTION='NOCOMPARE' AND WRITE_OPTION='WRITE' IS A      */
    /*               VALID COMBINATION.  THIS COMBINATION INSTRUCTS SMPSCAN TO     */
    /*               IDENTIFY AND WRITE THOSE GROUPS OF ENTRIES THAT DON'T         */
    /*               APPEAR IN ALL INPUT LISTINGS.                                 */
    /*                                                                             */
    /*            2. IF WRITE_OPTION IS "WRITE" AND AN ENTRY FROM THIS FILE        */
    /*               APPEARED IN THE GROUP, WRITE_SELECT INDICATES WHETHER THE     */
    /*               FILE ENTRY'S SCAN_RESULT HAS ANY BEARING ON THE OUTPUT        */
    /*               DECISION.  LIKE WRITE_OPTION, WRITE_SELECT IS INDEPENDENT     */
    /*               OF BOTH COMPARE_OPTION AND COMPARE_SELECT.  ONE ADVANTAGE     */
    /*               OF THIS INDEPENDENCE IS THAT ONE CAN "MATCH" OR IDENTIFY      */
    /*               ENTRIES INDEPENDENT OF SCAN RESULTS AND THEN WRITE A SUBSET   */
    /*               OF THE "MATCHING" ENTRIES BASED ON SCAN RESULTS.  A CAUTION   */
    /*               IS THAT IMPOSSIBLE COMBINATIONS PRODUCING NO OUTPUT CAN       */
    /*               ALSO BE DESCRIBED.                                            */
    /*                                                                             */
    /*      ONCE A MATCH_ARRAY ENTRY HAS PRODUCED A "MATCH", PROCESSING            */
    /*      CONTINUES.  THE FIRST ARRAY ENTRY YIELDING A MATCH DOES NOT            */
    /*      TERMINATE THE PROCESSING OF MATCH_ARRAY FOR THIS ENTRY GROUP.  AFTER   */
    /*      APPLYING OUTPUT INSTRUCTIONS, SMPSCAN GOES ON TO THE NEXT ACTIVE       */
    /*      MATCH_ARRAY ENTRY.  THIS ALLOWS THE OUTPUT FROM MULTIPLE CONDITIONS    */
    /*      TO BE MERGED IN A SINGLE EXECUTION (SMPSCAN HAS EXTRACT AND            */
    /*      MULTI-PASS CAPABILITIES).  "MATCHED" ARRAY ENTRY OUTPUT INSTRUCTIONS   */
    /*      ARE APPLIED ADDITIVELY.  ALTHOUGH THE WRITE_OPTION DEFAULT IS          */
    /*      "WRITE", AN ENTRY FROM THE GROUP WILL NOT BE WRITTEN UNLESS ITS        */
    /*      CORRESPONDING WRITE_OPTION FROM A "MATCHED" ARRAY ENTRY SPECIFIES      */
    /*      "WRITE".  FURTHER, AN ENTRY WILL BE WRITTEN IF ANY "MATCHED" ARRAY     */
    /*      ENTRY SPECIFIES "WRITE".  "NOWRITE" DOES NOT OVERRIDE "WRITE".         */
    /*                                                                             */
    /*            AFTER THE ABOVE PROCESSING HAS COMPLETED FOR THE FIRST SET       */
    /*      ENTRIES READ FROM EACH ACTIVE FILE, THE NEXT ENTRY IS READ FROM EACH   */
    /*      ACTIVE INPUT FILE THAT HAD AN ENTRY IN THE GROUP, AND THE MATCHING     */
    /*      PROCESS IS REPEATED, STARTING WITH THE IDENTIFICATION OF A NEW GROUP   */
    /*      OF LOW-KEY ENTRIES.  READING, SCANNING, AND MATCHING OF ENTRIES        */
    /*      CONTINUES UNTIL THE ENTRIES FROM ALL INPUT FILES HAVE BEEN READ.       */
    /*      LINES ARE SCANNED AS ENTRIES ARE READ, SO THAT THE SCAN_RESULT IS      */
    /*      AVAILABLE WHEN THE THE NEXT LOW-KEY GROUP IS IDENTIFIED.               */
    /*                                                                             */
    /*            MATCH_ARRAY VARIABLES ARE SUPPLIED IN THE "SYSIN" DATA STREAM,   */
    /*      AND ARE DOCUMENTED IN THE INPUT SECTION ABOVE.  IF USED, THEY SHOULD   */
    /*      BE SPECIFIED WITH THE REQUIRED LEVELS OF QUALIFICATION AND             */
    /*      SUBSCRIPTS AS SHOWN THERE.  UNLIKE SCAN_ARRAY, MATCH_ARRAY             */
    /*      (CURRENTLY) DOES NOT CONTAIN SMPSCAN-CALCULATED VARIABLES.  ALL        */
    /*      MATCH_ARRAY VARIABLES CAN BE SPECIFIED BY THE USER.  THE VARIABLES,    */
    /*      ALONG WITH THEIR DEFAULTS ARE:                                         */
    /*                                                                             */
    /*             .TYPE.  THIS VARIABLE SPECIFIES THE SMP/E ENTRY TYPE TO WHICH   */
    /*              THE MATCH_ARRAY ENTRY APPLIES.  IT CAN REFERENCE A SPECIFIC    */
    /*              ENTRY TYPE (LIKE THE SCAN_ARRAY STRING VALUE FOR ENTRY TYPE    */
    /*              OPERATIONS).  THE SPECIAL VALUES "NONE" AND "ALL" ARE ALSO     */
    /*              RECOGNIZED.  "ALL" INDICATES THAT THE MATCH_ARRAY ENTRY        */
    /*              APPLIES TO ALL ENTRY TYPES, AND "NONE" THAT THE ENTRY IS       */
    /*              INACTIVE.  FOR SOME ENTRY TYPES, REASONABLE ABBREVIATIONS      */
    /*              ARE SUPPORTED.  A FULL LIST OF THE CURRENTLY SUPPORTED ENTRY   */
    /*              TYPES IN ORDER OF APPEARANCE IN LISTINGS IS:                   */
    /*                                                                             */
    /*                 'ZONE'                                                      */
    /*                 'OPTIONS'                                                   */
    /*                 'UTILITY'                                                   */
    /*                 'FMIDSET'                                                   */
    /*                 'DDDEF'                                                     */
    /*                 'ZONESET'                                                   */
    /*                 'ASSEMBLER'                                                 */
    /*                 'LOAD MODULE'                                               */
    /*                 'MACRO'                                                     */
    /*                 'MODULE'                                                    */
    /*                 'SOURCE'                                                    */
    /*                 'DLIB'                                                      */
    /*                 'SYSMOD'                                                    */
    /*                 'M.C.S.'                                                    */
    /*                                                                             */
    /*             NOTE THAT A VALUE OF "ALL" WILL INCREASE SMPSCAN EXECUTION      */
    /*             TIME, BECAUSE ONLY THOSE ENTRY TYPES REFERENCED IN              */
    /*             MATCH_ARRAY ARE POTENTIAL OUTPUT CANDIDATES.  SMPSCAN           */
    /*             BYPASSES NON-ESSENTIAL PROCESSING FOR THOSE TYPES OMITTED       */
    /*             FROM MATCH_ARRAY.  IN PARTICULAR, LINE SCANNING IS SKIPPED.     */
    /*             NOT USING MATCH_ARRAY HAS THE SAME EFFECT AS "ALL" SINCE        */
    /*             ENTRY MATCHING IS GOVERNED BY SCAN RESULTS.                     */
    /*                                                                             */
    /*             .COMPARE_TEST.  THIS VARIABLE CONTROLS WHETHER THE FILE         */
    /*              SUB-ENTRIES WITHIN THIS MATCH_ARRAY ENTRY ARE TO BE PROCESSED  */
    /*              IN AN ALL (AND) OR ANY (OR) MANNER.  VALID VALUES ARE:         */
    /*                                                                             */
    /*                 'ALL'                                                       */
    /*                 'ANY'                                                       */
    /*                                                                             */
    /*              THE DEFAULT IS "ALL".  "ALL" INDICATES THAT ALL CONDITIONS     */
    /*              REPRESENTED BY THE COMPARE_OPTION AND COMPARE_SELECT           */
    /*              VARIABLES FOR EACH ACTIVE FILE MUST BE MET IN ORDER FOR A      */
    /*              MATCH_ARRAY ENTRY TO YIELD A MATCH WITH THE CURRENT GROUP OF   */
    /*              LISTING ENTRIES.  "ALL" WAS CHOSEN AS DEFAULT TO COMPLEMENT    */
    /*              THE FACT THAT ALL ACTIVE MATCH_ARRAY ENTRIES ARE PROCESSED     */
    /*              FOR EACH GROUP OF LISTING ENTRIES, AND ANY MATCH_ARRAY ENTRY   */
    /*              RESULTING IN A MATCH CAUSES TH ENTRY'S OUTPUT INSTRUCTIONS     */
    /*              TO BE APPLIED TO THE GROUP.  IN OTHER WORDS, "ALL" (AND) WAS   */
    /*              CHOSEN TO COMPLEMENT THE "ANY" (OR) LOGIC USED WITH THE        */
    /*              ARRAY.  A VALUE OF "ANY" CAN ALSO BE SPECIFIED FOR             */
    /*              COMPARE_TEST.  A VALUE OF "ANY" DOESN'T CHANGE THE WAY         */
    /*              MATCH_ARRAY IS INTERPRETED, BUT IT DOES SIMPLIFY THE           */
    /*              SPECIFICATION OF CERTAIN TESTS.  THAT'S WHY IT'S PROVIDED.     */
    /*              FOR EXAMPLE, WITH FOUR INPUT ZONE LISTINGS, TESTING FOR        */
    /*              ENTRIES OF A CERTAIN TYPE THAT ARE DEFINED IN SOME BUT NOT     */
    /*              ALL INPUT LISTINGS WILL REQUIRE 1 MATCH_ARRAY ENTRY WITH       */
    /*              COMPARE_TEST='ANY', BUT WILL REQUIRE 14 MATCH_ARRAY ENTRIES    */
    /*              WITH COMPARE_TEST='ALL'.                                       */
    /*                                                                             */
    /*             .COMPARE_OPTION.  THIS VARIABLE SPECIFIES, FOR THE CURRENT      */
    /*              GROUP OF LISTING ENTRIES, WHETHER AN ENTRY IS EXPECTED TO      */
    /*              BE PRESENT FROM THAT FILE.  A COMPARE_OPTION VALUE             */
    /*              PERTAINS TO EACH ACTIVE FILE.  VALID VALUES ARE:               */
    /*                                                                             */
    /*                 'COMPARE'       (AND REASONABLE ABBREVIATIONS)              */
    /*                 'NOCOMPARE'     (AND REASONABLE ABBREVIATIONS)              */
    /*                 'IGNORE' OR 'IGCOMPARE'    (AND ABBREVIATIONS)              */
    /*                                                                             */
    /*             THE DEFAULT IS "IGNORE".  "COMPARE" INDICATES THAT A LISTING    */
    /*             ENTRY IS EXPECTED FROM THIS FILE.  "NOCOMPARE" INDICATES THAT   */
    /*             A LISTING ENTRY IS EXPECTED TO BE ABSENT FROM THIS FILE.        */
    /*             "IGNORE" AND ITS SYNONYM "IGCOMPARE" INDICATE THAT AN ENTRY     */
    /*             LISTING MAY OR MAY NOT APPEAR - IT WILL BE PROCESSED IF         */
    /*             PRESENT, BUT ITS PRESENCE OR ABSENCE ISN'T DEMANDED.  BOTH      */
    /*             "COMPARE" AND "IGNORE" ARE INTERPRETED IN CONJUNCTION WITH      */
    /*             THE COMPARE_SELECT VARIABLE AS DESCRIBED BELOW.  "NOCOMPARE"    */
    /*             DOESN'T INTERACT WITH COMPARE_SELECT BECAUSE AN ENTRY THAT      */
    /*             ISN'T PRESENT CAN'T BE SCANNED.                                 */
    /*                                                                             */
    /*             .COMPARE_SELECT.  THIS VARIABLE SPECIFIES, WHEN AN ENTRY FROM   */
    /*              THIS FILE IS PRESENT IN THE CURRENT GROUP OF LISTING           */
    /*              ENTRIES, HOW THE ENTRY'S SCAN_RESULT IS TO BE WEIGHED.  A      */
    /*              COMPARE_TEST VALUE CORRESPONDING TO THE COMPARE_OPTION         */
    /*              PERTAINS TO EACH ACTIVE FILE.  VALID VALUES ARE:               */
    /*                                                                             */
    /*                 'SELECT'        (AND REASONABLE ABBREVIATIONS)              */
    /*                 'NOSELECT'      (AND REASONABLE ABBREVIATIONS)              */
    /*                 'IGNORE' OR 'IGSELECT'     (AND ABBREVIATIONS)              */
    /*                                                                             */
    /*             THE DEFAULT IS "IGNORE".  "SELECT" INDICATES THAT THE ENTRY     */
    /*             MUST HAVE BEEN SELECTED BY THE SCAN PROCESS (RESULT IS '1'B).   */
    /*             "NOSELECT" INDICATES THAT THE ENTRY MUST BE NOT SELECTED BY     */
    /*             THE SCAN PRECESS (RESULT IS '0'B).  "IGNORE" AND ITS SYNONYM    */
    /*             "IGSELECT" INDICATE THAT THE SCAN RESULT IS TO BE DISREGARDED   */
    /*             IN DETERMINING WHETHER THE CURRENT GROUP OF ENTRIES IS A        */
    /*             "MATCH" ACCORDING TO THIS MATCH_ARRAY ENTRY.  IF                */
    /*             COMPARE_OPTION IS "COMPARE" OR "IGNORE" AND COMPARE_SELECT IS   */
    /*             "SELECT" OR "NOSELECT", THE VARIABLES ACT TOGETHER.  FOR        */
    /*             INSTANCE, ONE CAN SPECIFY THAT AN ENTRY NEED NOT BE PRESENT     */
    /*             ISN A LISTING, BUT IF IT IS PRESENT, ITS SCAN_RESULT MUST BE    */
    /*             POSITIVE BY SPECIFYING COMPARE_OPTION='IGNORE' AND              */
    /*             'COMPARE_SELECT='SELECT'.                                       */
    /*                                                                             */
    /*             .WRITE_OPTION.  IF THIS MATCH_ARRAY ENTRY RESULTS IN A MATCH    */
    /*              FOR THE CURRENT GROUP OF LISTING ENTRIES, THIS VARIABLE        */
    /*              INDICATES THE OUTPUT REQUIREMENT FOR THE ENTRY FROM THIS       */
    /*              FILE.  VALID VALUES ARE:                                       */
    /*                                                                             */
    /*                 'WRITE'         (AND REASONABLE ABBREVIATIONS)              */
    /*                 'NOWRITE'       (AND REASONABLE ABBREVIATIONS)              */
    /*                                                                             */
    /*              THE DEFAULT IS "WRITE", AND THEIR MEANINGS ARE APPARENT.       */
    /*              FOR "WRITE", THE DECISION TO WRITE DEPENDS ON THE VALUE IN     */
    /*              WRITE_SELECT, DESCRIBED NEXT.                                  */
    /*                                                                             */
    /*             .WRITE_SELECT.  IF THIS MATCH_ARRAY ENTRY RESULTS IN A MATCH    */
    /*              FOR THE CURRENT GROUP OF LISTING ENTRIES AND WRITE_OPTION IS   */
    /*              "WRITE", THIS VARIABLE INDICATES WHETHER THE LISTING ENTRY'S   */
    /*              SCAN RESULT HAS ANY BEARING ON WHETHER THE ENTRY IS WRITTEN.   */
    /*              VALID VALUES ARE THE SAME AS THOSE FOR COMPARE_SELECT:         */
    /*                                                                             */
    /*                 'SELECT'        (AND REASONABLE ABBREVIATIONS)              */
    /*                 'NOSELECT'      (AND REASONABLE ABBREVIATIONS)              */
    /*                 'IGNORE' OR 'IGSELECT'     (AND ABBREVIATIONS)              */
    /*                                                                             */
    /*              THE DEFAULT IS "IGNORE".  "SELECT" INDICATES THAT THE ENTRY    */
    /*              MUST HAVE BEEN SELECTED BY THE SCAN PROCESS (RESULT IS         */
    /*              '1'B).  "NOSELECT" INDICATES THAT THE ENTRY MUST HAVE BEEN     */
    /*              NOT SELECTED (RESULT IS '0'B).  "IGNORE" AND ITS SYNONYM       */
    /*              "IGSELECT" INDICATE THAT THE SCAN_RESULT IS TO BE              */
    /*              DISREGARDED FOR THE PURPOSE OF DECIDING WHETHER TO WRITE THE   */
    /*              ENTRY - IT IS WRITTEN EITHER WAY.  A WRITE_SELECT VALUE OF     */
    /*              "IGNORE" HAS NO EFFECT ON THE PRESENCE OR ABSENCE OF           */
    /*              UNDERSCORES IN HIGHLIGHTED OUTPUT FOR THIS FILE.               */
    /*                                                                             */
    /*      IF MATCH_ARRAY VARIABLES ARE OMITTED FROM THE INPUT DATA SET, IT IS    */
    /*      AS IF A SINGLE MATCH_ARRAY ENTRY HAD BEEN SPECIFIED, WITH THE          */
    /*      FOLLOWING VALUES:                                                      */
    /*                                                                             */
    /*             .TYPE          ='ALL'.                                          */
    /*             .COMPARE_TEST  ='ANY'.                                          */
    /*             .COMPARE_OPTION='IGNORE'  FOR EACH ACTIVE FILE.                 */
    /*             .COMPARE_SELECT='SELECT'  FOR EACH ACTIVE FILE.                 */
    /*             .WRITE_OPTION  ='WRITE'   FOR EACH ACTIVE FILE.                 */
    /*             .WRITE_SELECT  ='SELECT'  FOR EACH ACTIVE FILE.                 */
    /*                                                                             */
    /*                                                                             */
    /*   USES AND EXAMPLES                                                         */
    /*                                                                             */
    /*            SMPSCAN'S USES CORRESPOND TO ITS FOUR MAIN FUNCTIONAL            */
    /*      CAPABILITIES:  PROVIDING A DIRECTORY OF MATCHING ENTRIES AND ENTRY     */
    /*      TYPE TOTALS FOR ONE OR MORE SMP/E LIST COMMAND OUTPUT LISTINGS,        */
    /*      IDENTIFYING AND MATCHING ENTRIES WHICH SATISY CERTAIN CONDITIONS,      */
    /*      PROVIDING PRE-SELECTED INPUT TO OTHER LIST COMMAND OUTPUT PROCESSING   */
    /*      PROGRAMS, AND GENERATING CARD-IMAGE FILES THAT CAN BE EDITED AND       */
    /*      TAILORED FOR OTHER USES.  SOME SPECIFIC INSTANCES ARE TO:              */
    /*                                                                             */
    /*             .IDENTIFY DDDEF ENTRIES:                                        */
    /*                                                                             */
    /*                -REFERENCING VOLUME SERIAL NUMBERS NO LONGER DEFINED, OR     */
    /*                 DEVICE TYPES NO LONGER INSTALLED.                           */
    /*                                                                             */
    /*                -THAT SHOULD BE DEFINED IN ALL (SAY) TARGET ZONES, BUT       */
    /*                 AREN'T.                                                     */
    /*                                                                             */
    /*                -REFERENCING VOLUME SERIAL NUMBERS INAPPROPRIATE TO A        */
    /*                 ZONE.                                                       */
    /*                                                                             */
    /*             .IDENTIFY LOAD MODULES:                                         */
    /*                                                                             */
    /*                -CROSS-SYSTEM THAT ARE DEFINED IN SOME BUT NOT ALL OF THE    */
    /*                 LISTED TARGET ZONES.                                        */
    /*                                                                             */
    /*                -CONTAINING MODULES FOR A PARTICULAR FMID OR GROUP OF        */
    /*                 FMID'S TO ASSIST IN THE INSTALLATION OF A NEW FMID.         */
    /*                                                                             */
    /*                -APPEARING IN MORE THAN ONE SYSTEM LIBRARY FOR A GIVEN       */
    /*                 ZONE, OR IN MORE THAN ONE LIBRARY FOR SOME TARGET ZONES     */
    /*                 BUT NOT FOR ALL.                                            */
    /*                                                                             */
    /*             .ALLOW IDENTIFICATION OF SYSMODS:                               */
    /*                                                                             */
    /*                -CONTAINING JCLIN, AND EITHER UPDATING OR REPLACING A        */
    /*                 SYSGEN MACRO.                                               */
    /*                                                                             */
    /*                -RECEIVED ON A PARTICULAR DATE, DATE AND TIME, OR BETWEEN    */
    /*                 ONE OR MORE RANGES OF DATES (AND TIMES).                    */
    /*                                                                             */
    /*                -REFERENCING A GIVEN MACRO, MODULE, APAR, FUNCTION, OR       */
    /*                 PTF, WHETHER APPLIED, ACCEPTED, OR ONLY JUST RECEIVED.      */
    /*                                                                             */
    /*                -APPLIED TO A TARGET ZONE BETWEEN TWO DATES AND EITHER       */
    /*                 ACCEPTED AFTER A CERTAIN DATE, OR NOT ACCEPTED AT ALL.      */
    /*                 MOREOVER, THESE TYPES OF TESTS CAN INVOLVE MORE THAN ONE    */
    /*                 TARGET ZONE, WITH DIFFERENT RANGES OF DATES FOR EACH        */
    /*                 ZONE.                                                       */
    /*                                                                             */
    /*             .PROVIDE A CONTROL CARD OUTPUT FILE OF THE SELECTED ENTRIES     */
    /*              THAT CAN BE EDITED:                                            */
    /*                                                                             */
    /*                -AND USED AS INPUT TO SMP/E TO INSTALL SPECIAL-PURPOSE       */
    /*                 MAINTENANCE, OR SELECT CERTAIN SYSMODS FOR APPLY, ACCEPT,   */
    /*                 OR RESTORE PROCESSING.                                      */
    /*                                                                             */
    /*                                                                             */
    /*   PROGRAMMING NOTES                                                         */
    /*                                                                             */
    /*            THIS SECTION DESCRIBES SOME OF THE MORE IMPORTANT                */
    /*      CONSIDERATIONS UNDERLYING THE STRUCTURE AND CODING OF SMPSCAN, IN      */
    /*      CASE CORRECTIONS, CHANGES, OR ENHANCEMENTS ARE NEEDED:                 */
    /*                                                                             */
    /*             .AFTER ANY PROGRAM CHANGES ARE MADE, THE VALUE IN VARIABLE      */
    /*              SMPSCAN_LVL SHOULD REFLECT THE VERSION AND NEW LEVEL OF        */
    /*              SMPSCAN.  THIS VALUE APPEARS IN THE SMPDCTRY OUTPUT IN TITLE   */
    /*              LINE NUMBER 1.                                                 */
    /*                                                                             */
    /*             .THE MAJOR DATA STRUCTURES WITHIN SMPSCAN WERE DECLARED         */
    /*              "CONTROLLED" WITH VARIABLE DIMENSIONS IN ORDER TO MAKE ARRAY   */
    /*              SIZES EASY TO EXPAND.  THESE DIMENSION VARIABLES WERE          */
    /*              REFERENCED BOTH IN STRUCTURAL DECLARATIONS AND DO GROUPS.      */
    /*              THE MORE IMPORTANT OF THESE DIMENSION VARIABLES ARE:           */
    /*                                                                             */
    /*                -IMATCH_MAX:  DETERMINES THE NUMBER OF ENTRIES IN            */
    /*                              MATCH_ARRAY, CURRENTLY SET AT 032.             */
    /*                                                                             */
    /*                -IFILE_MAX:   DEFINES THE MAXIMUM NUMBER OF INPUT LISTING    */
    /*                              FILES SUPPORTED, CURRENTLY SET AT 016.  IF     */
    /*                              SUPPORT FOR MORE THAN 016 FILES IS DESIRED,    */
    /*                              PROGRAM VARIABLES BEGINNING WITH "DTF", THE    */
    /*                              FILE VARIABLES AND ASSOCIATED LISTS MUST       */
    /*                              ALSO BE UPDATED ACCORDINGLY.  OTHERWISE, THE   */
    /*                              SOLE DEPENDENCY IS ON THE VALUE IN             */
    /*                              IFILE_MAX, SINCE THE FILE MANAGEMENT           */
    /*                              STRUCTURES ARE "CONTROLLED" WITH VARIABLE      */
    /*                              SUBSCRIPTS.                                    */
    /*                                                                             */
    /*                -IPLANE_MAX:  DETERMINES THE NUMBER OF PLANES IN EACH        */
    /*                              SCAN_ARRAY FILE CROSS-SECTION, CURRENTLY SET   */
    /*                              AT 012.                                        */
    /*                                                                             */
    /*                -IROW_MAX:    DETERMINES THE NUMBER OF ROWS IN EACH          */
    /*                              SCAN_ARRAY PLANE, CURRENTLY SET AT 012.        */
    /*                                                                             */
    /*                -ICOL_MAX:    DETERMINES THE NUMBER OF COLUMNS IN EACH       */
    /*                              SCAN_ARRAY ROW, CURRENTLY SET AT 012.          */
    /*                                                                             */
    /*                -PLIXOPT:     AFTER ANY PROGRAM CHANGES THAT INCREASE        */
    /*                              SMPSCAN'S VIRTUAL STORAGE REQUIREMENTS, THE    */
    /*                              ISASIZE AND HEAP OPTIONS IN PLIXOPT MAY NEED   */
    /*                              TO BE REVISED.                                 */
    /*                                                                             */
    /*             .IF IT BECOMES NECESSARY TO ADD SUPPORT FOR NEW SMP/E ENTRY     */
    /*              TYPES IN THE FUTURE, THE FOLLOWING PROGRAM AREAS SHOULD BE     */
    /*              REVIEWED:                                                      */
    /*                                                                             */
    /*                -NTRYINDX_MAX:  THIS VARIABLE DEFINES AN ARBITRARY UPPER     */
    /*                              LIMIT TO THE NUMBER OF DISTINCT ENTRY TYPES.   */
    /*                              ITS VALUE IS CURRENTLY SET AT 024, WITH        */
    /*                              14 VALUES IN ACTUAL USE.                       */
    /*                                                                             */
    /*                -ENTRY_TYPE:  THIS SUBROUTINE MAPS AN ENTRY TYPE NAME TO     */
    /*                              AN SMPSCAN INTERNAL INDEX VALUE.  NEW ENTRY    */
    /*                              TYPE NAMES AND ABBREVIATIONS FOR NEW OR        */
    /*                              EXISTING TYPES SHOULD BE ADDED HERE.           */
    /*                                                                             */
    /*                -ENTRY_INDEX: THIS SUBROUTINE MAPS AN SMPSCAN ENTRY TYPE     */
    /*                              INTERNAL INDEX VALUE BACK TO AN ENTRY TYPE     */
    /*                              NAME.  NAMES OF NEW ENTRY TYPES, BUT NOT       */
    /*                              ABBREVIATIONS, SHOULD BE ADDED HERE.           */
    /*                                                                             */
    /*                -SMPDATA_ENTRY_LINE_WRITE:  THIS SUBROUTINE AND ITS          */
    /*                              SUBORDINATE SUBROUTINES                        */
    /*                              WRITE_DATA_FORMAT1_LINE THROUGH                */
    /*                              WRITE_DATA_FORMAT5_LINE SHOULD BE REVIEWED     */
    /*                              AND FORMATTING ROUTINES FOR ANY NEW LINE       */
    /*                              TYPES SHOULD BE ADDED AS NEEDED.               */
    /*                                                                             */
    /*                -SMPDCTRY_ENTRY_FILE_STYPE_INFO:  IF SPECIAL ENTRY           */
    /*                              INFORMATION IS DESIRED IN SMPDCTRY ENTRY       */
    /*                              LINE LOCATIONS 026-040 THIS SUBROUTINE, THE    */
    /*                              CORRESPONDING DATA COLLECTION LOGIC IN         */
    /*                              SMPLIST_ENTRY_LINE_EVAL, AND ANY NEW           */
    /*                              VARIABLE DEFINITIONS NEEDED IN                 */
    /*                              SMPLIST.CURR_PAGE AND SMPLIST.CURR_NTRY WILL   */
    /*                              NEED TO BE CONSIDERED.                         */
    /*                                                                             */
    /*                -SCANDOC:     FINALLY, THIS DOCUMENTATION SHOULD BE          */
    /*                              REVIEWED, AND THE NEW ENTRY TYPE MENTIONED     */
    /*                              AT LEAST IN CONJUNCTION WITH THE MATCH_ARRAY   */
    /*                              "TYPE" VARIABLE.                               */
    /*                                                                             */
    /*                                                                             */
    /*   UPDATE HISTORY                                                            */
    /*                                                                             */
    /*             .MODULE UPGRADED FROM "PTSSCAN" TO SUPPORT SMP/E,               */
    /*              RENAMED TO "SMPSCAN", TESTED, AND DOCUMENTED.      12/31/86 TJA*/
    /*                                                                             */
    /*******************************************************************************/
    /*                                                                             */
    /*>>>>>>>>>>>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<<<<<<<<<<<*/
    /*                                                                             */
    /*******************************************************************************/
    /*            THE INFORMATION OR MATERIAL BEING PROVIDED BY COMMERCIAL UNION   */
    /*      INSURANCE COMPANY (CUIC), WHETHER IN HARD COPY OR MACHINE READABLE     */
    /*      FORM, HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE AND FOR USE ON    */
    /*      ITS OWN EQUIPMENT AND WITHIN ITS OWN DATA PROCESSING SYSTEM.  CUIC     */
    /*      MAKES NO REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH RESPECT TO      */
    /*      THE INFORMATION OR MATERIAL FURNISHED HEREUNDER, EXPRESSED OR          */
    /*      IMPLIED, INCLUDING BUT NOT LIMITED TO ANY REPRESENTATION OR WARRANTY   */
    /*      OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE OR PURPOSE OR     */
    /*      THAT THE USE OF THE INFORMATION OR MATERIAL WILL NOT INFRINGE ANY      */
    /*      PATENT, COPYRIGHT, TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU      */
    /*      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR MATERIAL ON AN "AS IS"   */
    /*      BASIS AND WILL BE USING IT AT YOUR OWN RISK.  NEITHER CUIC NOR ANY     */
    /*      OF ITS AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY CLAIM, ACTION,   */
    /*      OR DEMAND BY ANY USER OR OTHER PARTY (INCLUDING ANY CLAIM, ACTION,     */
    /*      OR DEMAND FOR CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN ADVISED OF   */
    /*      THE POSSIBILITY OF SUCH DAMAGES) ARISING FROM THE USE OF THE           */
    /*      INFORMATION OR THE MATERIALS AND CONCEPTS RELATED THERETO.             */
    /*      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR UPDATE THIS           */
    /*      INFORMATION OR MATERIAL IN THE FUTURE.                                 */
    /*                                                                  01/26/83   */
    /*******************************************************************************/
    /*                                                                             */
    /*             DIRECT COMMENTS, QUESTIONS, AND SUGGESTIONS FOR ENHANCEMENTS    */
    /*      TO THE AUTHOR.........                                                 */
    /*                                                                             */
    /*             THOMAS J. AUBREY                                                */
    /*             INFORMATION SYSTEMS AND SERVICES - DATA PROCESSING DIVISION     */
    /*             COMMERCIAL UNION INSURANCE COMPANIES                            */
    /*             ONE BEACON STREET - THIRTEENTH FLOOR                            */
    /*             BOSTON, MASSACHUSETTS  02108                                    */
    /*             TELEPHONE: (617) 725-6208                                       */
    /*                                                                             */
    /*******************************************************************************/;
    %SKIP(3);
    DECLARE                    /*SPECIFY GLOBAL PROGRAM VALUES*/
         SMPSCAN_LVL             CHAR(005) INIT('02.00'),    /*PROGRAM VERSION & LEVEL   */
         SYSPARM                 CHAR(100) VARYING,          /*EXEC PARAMETER DATA       */
         PLIXOPT                 CHAR(128) VARYING           /*EXEC-TIME RUN OPTIONS     */
                                 STATIC EXTERNAL
                INIT('ISASIZE(0064K),HEAP(2048K,512K),STAE,COUNT,FLOW(256,064),REPORT');
    %PAGE;
    DECLARE                    /*LIST THE BUILT-IN FUNCTIONS USED */
        (ADDR,
         ALL,
         ANY,
         BOOL,
         CEIL,
         DATE,
         DIM,
         FLOOR,
         HIGH,
         INDEX,
         LENGTH,
         LINENO,
         LOG,LOG2,LOG10,
         LOW,
         MAX,
         MIN,
         PLIDUMP,
         REPEAT,
         SIGN,
         STRING,
         SUBSTR,
         TIME,
         UNSPEC,
         VERIFY)                 BUILTIN;
    %SKIP(2);
    DECLARE                    /*DEFINE FREQUENTLY_USED PROGRAM CONSTANTS*/
         SEMI_C                  CHAR(001) INIT(';');
    %PAGE;
    DECLARE                    /*DECLARE DO LOOP INDEX VARIABLES*/
         IMATCH                  FIXED BIN(15,0),
         IMATCH_MIN              FIXED BIN(15,0) INIT(001),
         IMATCH_MAX              FIXED BIN(15,0) INIT(032),
 
         IFILE                   FIXED BIN(15,0),
         IFILE_MIN               FIXED BIN(15,0) INIT(001),
         IFILE_MAX               FIXED BIN(15,0) INIT(016),
 
         ILINE                   FIXED BIN(15,0),
         LINE_SAVE_LIMIT   FIXED BIN(31,0) STATIC INTERNAL INIT(0100),
         LIST_LINE_SIZE    FIXED BIN(31,0) STATIC INTERNAL INIT(120),
         LIST_LINE_RCZC    FIXED BIN(31,0) STATIC INTERNAL INIT(133), /*SMPDCTRY LINE SIZE*/
         LIST_LINE_RCZD    FIXED BIN(31,0) STATIC INTERNAL INIT(080), /*SMPDATA  LINE SIZE*/
         LIST_LINE_RCZL    FIXED BIN(31,0) STATIC INTERNAL INIT(121), /*SMPLIST  LINE SIZE*/
         LIST_LINE_RCZN    FIXED BIN(31,0) STATIC INTERNAL INIT(133), /*SMPSCAN  LINE SIZE*/
         LIST_LINE_DBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(001),
         LIST_LINE_NBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(001),
         LIST_LINE_NWID    FIXED BIN(15,0) STATIC INTERNAL INIT(008),
         LIST_LINE_LBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(011),
         LIST_LINE_LEND    FIXED BIN(15,0) STATIC INTERNAL INIT(025),
         LIST_LINE_LWID    FIXED BIN(15,0) STATIC INTERNAL INIT(015),
         LIST_LINE_SBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(029),
         LIST_LINE_DEND    FIXED BIN(15,0) STATIC INTERNAL INIT(120),
 
         IPLANE                  FIXED BIN(15,0),
         IPLANE_MIN              FIXED BIN(15,0) INIT(001),
         IPLANE_MAX              FIXED BIN(15,0) INIT(012),
         IROW                    FIXED BIN(15,0),
         IROW_MIN                FIXED BIN(15,0) INIT(001),
         IROW_MAX                FIXED BIN(15,0) INIT(012),
         ICOL                    FIXED BIN(15,0),
         ICOL_MIN                FIXED BIN(15,0) INIT(001),
         ICOL_MAX                FIXED BIN(15,0) INIT(012),
         SCAN_ARRAY_ELEMENT_ADDR       POINTER,
 
         NTRYINDX_IX             FIXED BIN(15,0),
         NTRYINDX_MIN            FIXED BIN(15,0) INIT(000),
         NTRYINDX_MAX            FIXED BIN(15,0) INIT(024);
    %PAGE;
    DECLARE                    /*USER-PROVIDED EXECUTION CONTROL VARIABLES: */
         DDIPFX                               CHAR(003) INIT('SMP'),
         DDOPFX                               CHAR(003) INIT('SMP');
 
    DECLARE                    /*USER-PROVIDED EXECUTION CONTROL VARIABLES: */
         FILE_ACTIVE_OPTION(IFILE_MIN:IFILE_MAX)        CONTROLLED
                                              CHAR(008) VARYING;   /*ACTIVE | INACTIVE */
 
    DECLARE                                 /*USER-PROVIDED FILE MATCH CONTROL ARRAY: */
      01 MATCH_ARRAY                                    CONTROLLED,
         05 ENTRY(IMATCH_MIN:IMATCH_MAX),
            09 TYPE                           CHAR(016) VARYING,  /* ALL | NONE | E_TYPE */
            09 COMPARE_TEST                   CHAR(008) VARYING,  /* ALL | ANY */
            09 FILE(IFILE_MIN:IFILE_MAX),
               13 COMPARE_OPTION          /* COMPARE | NOCOMPARE | IGCOMPARE | IGNORE */
                                              CHAR(012) VARYING,
 
               13 COMPARE_SELECT          /* SELECT | NOSELECT | IGSELECT | IGNORE */
                                              CHAR(012) VARYING,
 
               13 WRITE_OPTION                       /* WRITE  | NOWRITE */
                                              CHAR(012) VARYING,
 
               13 WRITE_SELECT            /* SELECT | NOSELECT | IGSELECT | IGNORE */
                                              CHAR(012) VARYING;
 
    DECLARE                         /*USER-PROVIDED SMPLIST ENTRY SCAN CONTROL ARRAY: */
      01 SCAN_ARRAY                                     CONTROLLED,
         05 FILE(IFILE_MIN:IFILE_MAX),         /*ONE SCAN CUBE FOR EACH SUPPORTED FILE*/
            09 SELECT_OPTION                  CHAR(008) VARYING,  /* SELECT | EXCLUDE */
            09 PLANE(IPLANE_MIN:IPLANE_MAX),
               13 SELECT_OPTION               CHAR(008) VARYING,  /* SELECT | EXCLUDE */
               13 ROW(IROW_MIN:IROW_MAX),
                  17 SELECT_OPTION            CHAR(008) VARYING,  /* SELECT | EXCLUDE */
                  17 COL(ICOL_MIN:ICOL_MAX),
                     21 BEG_POS               FIXED BINARY(15,0),
                     21 END_POS               FIXED BINARY(15,0),
                     21 POS_LEN               FIXED BINARY(15,0),
                     21 OP                    CHAR(008) VARYING,
                     21 OP_OIX                FIXED BINARY(15,0),
                     21 STRING                CHAR(032) VARYING,
                     21 STR_LEN               FIXED BINARY(15,0),
                     21 STR_NIX               FIXED BINARY(15,0);
 
    DECLARE                    /*USER-PROVIDED OUTPUT CONTROL OPTIONS:   */
         DATA_OUTPUT_OPTION(IFILE_MIN:IFILE_MAX)        CONTROLLED
                                              CHAR(008) VARYING;   /*ALL | ID */
    %PAGE;
    DECLARE
         SYSIN                 /*CONTROL VARIABLE INPUT FILE*/
                                 FILE RECORD SEQUENTIAL INPUT
                                 ENV(FB   RECSIZE(080)),
         SYSIN_CONTROL_CARD      CHAR(080),
         SYSIN_EOF               BIT(1),
 
         SYSPRINT              /*PL/I LISTING OUTPUT FILE*/
                                 FILE STREAM OUTPUT PRINT
                                 ENV(VB   RECSIZE(155));
    %SKIP(5);
    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */
         DTFDCTRY                FILE STREAM OUTPUT PRINT INTERNAL
                                 ENV(FB  RECSIZE(LIST_LINE_RCZC));
 
    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */
      01 SMPDCTRY                      CONTROLLED,
         05 FILEREF              FILE  VARIABLE,
         05 DDNAME               CHAR(008),
         05 OPEN                 BIT(01),                       /*IF THE FILE IS OPEN   */
         05 PAGE_SZ              FIXED BIN(15,0),               /*OUTPUT PAGE SIZE      */
         05 LINE_SZ              FIXED BIN(15,0),               /*OUTPUT LINE SIZE      */
         05 CURR_PAGE,
            09 PAGE_NO           FIXED BIN(31,0),               /*CURRENT PAGE NUMBER   */
            09 INFO_1STLINE      FIXED BIN(15,0),         /*# OF 1ST LINE AFTER HEADINGS*/
            09 NTRYINDX          FIXED BIN(15,0),
            09 TITLE1_DATE       CHAR(008),                     /*TITLE_1 MM/DD/YY      */
            09 TITLE1_TIME       CHAR(012),                     /*TITLE_1 HH:MM:SS.XCM  */
            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE-010),      /*TITLE LINE FOR LISTING*/
            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE);          /*TITLE LINE FOR LISTING*/
    %PAGE;
    DECLARE                    /*SMP/E "SMPLIST" ELEMENT LISTING INPUT FILE(S)*/
        (DTFLIST1,DTFLIST2,DTFLIST3,DTFLIST4,DTFLIST5,DTFLIST6,DTFLIST7,DTFLIST8,
         DTFLIST9,DTFLST10,DTFLST11,DTFLST12,DTFLST13,DTFLST14,DTFLST15,DTFLST16)
                                 FILE RECORD SEQUENTIAL INPUT INTERNAL
                                      ENV(FB   RECSIZE(LIST_LINE_RCZL)),
 
         DTFLIST_LIST(001:016)   FILE  VARIABLE  INIT(DTFLIST1,DTFLIST2,DTFLIST3,DTFLIST4,
                                                      DTFLIST5,DTFLIST6,DTFLIST7,DTFLIST8,
                                                      DTFLIST9,DTFLST10,DTFLST11,DTFLST12,
                                                      DTFLST13,DTFLST14,DTFLST15,DTFLST16);
    %SKIP(2);
    DECLARE
      01 SMPLIST_CNTL            CONTROLLED,    /*SMP/E "SMPLIST" FILE CONTROL STRUCTURE*/
         05 A_STAT,            /*GENERAL INFORMATION ON THE SMPLIST INPUT/OUTPUT FILES  */
            09 #_F_ACTIVE        FIXED BIN(15,0),             /*# OF ACTIVE INPUT FILES */
         05 HIGH_PAGE,         /*RESET   INFORMATION FOR CURRENT PAGE AT END-OF-FILE    */
            09 NTRYNAME          CHAR(008),
            09 NTRYINDX          FIXED BIN(15,0),
            09 PAGEKEY           CHAR(011),
            09 NTRYKEY           CHAR(019),
            09 CMPRKEY           CHAR(011),
         05 HIGH_CMPR,         /*RESET   INFORMATION FOR CURRENT SMPLIST ENTRIES*/
            09 RESULT            BIT(01),
            09 NTRYNAME          CHAR(008),
            09 NTRYINDX          FIXED BIN(15,0),         /*NTRYINDX FOR CURRENT CMPRKEY*/
            09 CMPRKEY           CHAR(011),                            /*CURRENT CMPRKEY*/
         05 E_CMPR,            /*COMPARE INFORMATION FOR CURRENT SMPLIST ENTRIES*/
            09 RESULT            BIT(01),
            09 NTRYNAME          CHAR(008),
            09 NTRYINDX          FIXED BIN(15,0),         /*NTRYINDX FOR CURRENT CMPRKEY*/
            09 CMPRKEY           CHAR(011),                            /*CURRENT CMPRKEY*/
         05 A_MATCH,
            09 ACTIVE            BIT(01),                      /*ANY E_MATCH ROWS ACTIVE*/
            09 RESULT            BIT(01),
            09 M_E_TYPE(NTRYINDX_MIN:NTRYINDX_MAX)         /*ENTRY TYPE(S) BEING MATCHED*/
                                 BIT(01),
            09 F_OUTPUT(IFILE_MIN:IFILE_MAX)
                                 BIT(01),                      /*OUTPUT CANDIDATE FILES */
            09 E_MATCH(IMATCH_MIN:IMATCH_MAX),
               13 NTRYINDX       FIXED BIN(15,0),             /*NTRYINDX FOR ENTRY MATCH*/
               13 ACTIVE         BIT(01),                      /*THIS MATCH ENTRY ACTIVE*/
               13 C_TST          BIT(01),             /*COMPARE TEST: ANY='0'B, ALL='1'B*/
               13 F_MATCH(IFILE_MIN:IFILE_MAX),
                  17 M_CMPR      BIT(01),                  /*IF THE ENTRY MUST    BE FOUND*/
                  17 M_NOCMPR    BIT(01),                  /*IF THE ENTRY MUSTN'T BE FOUND*/
                  17 M_IGCMPR    BIT(01),                  /*IF THE ENTRY MAY     BE FOUND*/
                  17 M_SEL       BIT(01),                 /*FOUND ENTRY MUST   BE SELECTED*/
                  17 M_NOSEL     BIT(01),                 /*FOUND ENTRY MUSN'T BE SELECTED*/
                  17 M_IGSEL     BIT(01),                 /*FOUND ENTRY IGNORE    SELECT  */
                  17 W_OUT       BIT(01),                 /*WRITE BASED ON WRITE_SELECT   */
                  17 W_SEL       BIT(01),                 /*WRITE MATCH IF SELECTED       */
                  17 W_NOSEL     BIT(01),                 /*WRITE MATCH IF NOT SELECTED   */
                  17 W_IGSEL     BIT(01);                 /*WRITE MATCH REGARDLESS OF SEL */
    %PAGE;
    DECLARE
      01 SMPLIST(IFILE_MIN:IFILE_MAX)  CONTROLLED,           /*LIST FILE MANAGEMENT ARRAY*/
         05 FILEREF              FILE  VARIABLE,
         05 DDNAME               CHAR(008),
         05 ACTIVE               BIT(01),                         /*IF THE FILE IS ACTIVE*/
         05 EOF                  BIT(01),
         05 LINE_SZ              FIXED BIN(15,0),                /*INPUT  LINE SIZE      */
         05 CURR_PAGE,
            09 PAGE_BS           FIXED BIN(31,0),           /*BASE FOR 4-DIGIT PAGE NUMBR*/
            09 PAGE_NO           FIXED BIN(31,0),           /*CURRENT PAGE NUMBER        */
            09 PAGE_HI           FIXED BIN(31,0),           /*TO INIT CURR_NTRY.PAGE_HI  */
            09 LINE_NO           FIXED BIN(31,0),           /*LINE # ON CURRENT PAGE     */
            09 FLUSH             BIT(01),                   /*SET TO '1'B TO BYPASS PAGE */
            09 LINE_CT           FIXED BIN(31,0),           /*TO INIT CURR_NTRY.LINE_CT  */
            09 WRITE_OUT         BIT(01),                   /*TO INIT CURR_NTRY.WRITE_OUT*/
            09 CMPR_RESULT       BIT(01),                   /*TO INIT CURR_NTRY.CMPR_RSLT*/
            09 SCAN_RESULT       BIT(01),                   /*TO INIT CURR_NTRY.SCAN_RSLT*/
            09 ZONENAME          CHAR(007),
            09 ZONEINDX          FIXED BIN(15,0),
            09 ZONETYPE          CHAR(007)  VAR,
            09 ZONETYPE_C        CHAR(001),
            09 NTRYNAME          CHAR(008),
            09 NTRYINDX          FIXED BIN(15,0),
            09 NTRYTYPE          CHAR(016)  VAR,
            09 FMID              CHAR(007),                 /*TO INIT CURR_NTRY.FMID     */
            09 SOURCEID          CHAR(008),                 /*TO INIT CURR_NTRY.SOURCEID */
            09 SYSLIB1           CHAR(008),                 /*TO INIT CURR_NTRY.SYSLIB1  */
            09 SYSLIB2           CHAR(008),                 /*TO INIT CURR_NTRY.SYSLIB2  */
            09 PAGEKEY           CHAR(011),
            09 NTRYKEY           CHAR(019),
            09 CMPRKEY           CHAR(011),
            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
         05 CURR_LINE,
            09 LINETYPE          CHAR(LIST_LINE_LWID),
            09 IN,
               13 PRTCTL         CHAR(001),
               13 DATA           CHAR(LIST_LINE_SIZE),
         05 CURR_NTRY,
            09 PAGE_NO           FIXED BIN(31,0),            /*1ST LISTING PAGE OF ENTRY*/
            09 PAGE_HI           FIXED BIN(31,0),        /*HIGHEST PAGE NUMBER FOR ENTRY*/
            09 LINE_CT           FIXED BIN(31,0),            /*CURRENT LINE COUNT OF ENTRY*/
            09 WRITE_OUT         BIT(01),                    /*TO WRITE THIS ENTRY       */
            09 CMPR_RESULT       BIT(01),                    /*TO READ NEXT ENTRY        */
            09 SCAN_RESULT       BIT(01),                    /*IF ENTRY SELECTED FOR PROC*/
            09 ZONENAME          CHAR(007),
            09 ZONEINDX          FIXED BIN(15,0),
            09 ZONETYPE          CHAR(007)  VAR,
            09 ZONETYPE_C        CHAR(001),
            09 NTRYNAME          CHAR(008),
            09 NTRYINDX          FIXED BIN(15,0),
            09 NTRYTYPE          CHAR(016)  VAR,
            09 FMID              CHAR(007),
            09 SOURCEID          CHAR(008),
            09 SYSLIB1           CHAR(008),
            09 SYSLIB2           CHAR(008),
            09 PAGEKEY           CHAR(011),
            09 NTRYKEY           CHAR(019),
            09 CMPRKEY           CHAR(011),
            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/
            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/
            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/
         05 M_E_TYPE(NTRYINDX_MIN:NTRYINDX_MAX)   /*ENTRY TYPE(S) BEING MATCHED FOR FILE*/
                                 BIT(01),
         05 SCAN_CUBE,
            09 RESULT            BIT(01),
            09 SELECT            BIT(01),
            09 ACTIVE            BIT(01),                        /*ANY SCAN_ARRAY PLANES*/
            09 PLANE(IPLANE_MIN:IPLANE_MAX),
               13 RESULT         BIT(01),
               13 SELECT         BIT(01),
               13 ACTIVE         BIT(01),                          /*ANY SCAN_ARRAY ROWS*/
               13 ROW(IROW_MIN:IROW_MAX),
                  17 RESULT      BIT(01),
                  17 SELECT      BIT(01),
                  17 ACTIVE      BIT(01),                          /*ANY SCAN_ARRAY COLS*/
         05 FILE_TOTALS,
            09 #_S_ACTIVE        FIXED BIN(15,0),    /*# OF ACTIVE SCAN PLANES/ROWS/COLS*/
            09 #_F_OUTPUT        FIXED BIN(15,0),    /*# OF ACTIVE OUTPUT FILES         */
            09 #_E_T_FOUND       FIXED BIN(15,0),    /*# OF DISTINCT ENTRY TYPES FOUND  */
            09 RCRD_CT           FIXED BIN(31,0),           /*TOTAL NUMBER OF LINES READ*/
         05 ENTRY_TOTALS(NTRYINDX_MIN:NTRYINDX_MAX+1),  /*ONE SUBSTRUCTURE FOR EACH TYPE*/
                                                        /*PLUS ONE(MAX+1) FOR ALL TYPES */
            09 ENTRY_CT          FIXED BIN(31,0),           /*NUMBER OF ENTRIES         */
            09 LIST_PAGELO       FIXED BIN(31,0),           /*PAGE # OF FIRST INPUT PAGE*/
            09 LIST_PAGEHI       FIXED BIN(31,0),           /*PAGE # OF HIGH  INPUT PAGE*/
            09 LINE_CT           FIXED BIN(31,0),           /*NUMBER OF LINES IN ENTRIES*/
            09 MAXNAME           CHAR(008),                 /*ENTRY WITH MOST LINES     */
            09 MAXLINE           FIXED BIN(31,0),           /*NUMBER OF LINES IN ENTRY  */
            09 MAXPAGE           FIXED BIN(31,0),           /*PAGE ON WHICH ENTRY STARTS*/
            09 SELECT_CT         FIXED BIN(31,0),           /*# OF ENTRIES SELECTED/SCAN*/
            09 MATCH_CT          FIXED BIN(31,0),           /*# OF ENTRIES MATCHED /CMPR*/
            09 WRITE_CT          FIXED BIN(31,0);           /*# OF ENTRIES WRITTEN      */
    %SKIP(8);
    DECLARE                    /*SMP/E "SMPLIST" TITLE LINE MAPPING POINTERS  */
        (SMPLIST_TITLE1_MAP_ADDR,
         SMPLIST_TITLE2_MAP_ADDR,
         SMPLIST_TITLE3_MAP_ADDR)              POINTER;
    %PAGE;
    DECLARE                    /*SMP/E "SMPLIST" TITLE LINE MAPPINGS          */
      01 SMPLIST_TITLE1_MAP      BASED(SMPLIST_TITLE1_MAP_ADDR),
         05 EDATE                CHAR(004),    /*DATE*/
         05 FILL02               CHAR(001),
         05 LDATE                ,
            09 YY                PIC'99',      /*YY*/
            09 P                 CHAR(001),    /*.*/
            09 DDD               PIC'999',     /*DDD*/
         05 FILL03               CHAR(002),
         05 ETIME                CHAR(004),    /*TIME*/
         05 FILL04               CHAR(001),
         05 LTIME                ,
            09 HH                PIC'99',      /*HH*/
            09 C1                CHAR(001),    /*:*/
            09 MM                PIC'99',      /*MM*/
            09 C2                CHAR(001),    /*:*/
            09 SS                PIC'99',      /*SS*/
         05 FILL05               CHAR(006),
         05 EGIMSMP              CHAR(006),    /*GIMSMP*/
         05 FILL06               CHAR(001),
         05 ELVL                 CHAR(003),    /*LVL*/
         05 FILL07               CHAR(001),
         05 LVL                  ,
            09 VV                PIC'99',      /*VV*/
            09 P                 CHAR(001),    /*.*/
            09 LL                PIC'99',      /*LL*/
         05 FILL08               CHAR(001),
         05 ESMPLIST             CHAR(007),    /*SMPLIST*/
         05 FILL09               CHAR(002),
         05 EOUTPUT              CHAR(006),    /*OUTPUT*/
         05 FILL10               CHAR(005),
         05 EDASH                CHAR(001),    /*-*/
         05 FILL11               CHAR(001),
         05 ENOWSET              CHAR(010),    /*NOW SET TO*/
         05 FILL12               CHAR(001),
         05 ZONETYPE             CHAR(006),    /*TYPE OF ZONE*/
         05 FILL13               CHAR(001),
         05 EZONE                CHAR(004),    /*ZONE*/
         05 FILL14               CHAR(001),
         05 ZONENAME             CHAR(007),    /*NAME OF ZONE*/
         05 FILL15               CHAR(008),
         05 EPAGE                CHAR(004),    /*PAGE*/
         05 FILL16               CHAR(001),
         05 PAGE_NO              PICTURE'9999',/*NNNN*/
         05 FILL17               CHAR(002),
      01 SMPLIST_TITLE2_MAP      BASED(SMPLIST_TITLE2_MAP_ADDR),
         05 ZONENAME             CHAR(007),    /*NAME OF ZONE  BEING LISTED*/
         05 FILL01               CHAR(001),
         05 NTRYTYPE             CHAR(112),    /*TYPE OF ENTRY BEING LISTED*/
      01 SMPLIST_TITLE3_MAP      BASED(SMPLIST_TITLE3_MAP_ADDR),
         05 FILL01               CHAR(002),
         05 ENAME                CHAR(004),    /*NAME*/
         05 FILL02               CHAR(114);
    %PAGE;
    DECLARE                    /*SMP/E "SMPLIST" ELEMENT LISTING SPILL FILE(S)*/
        (DTFUT1,DTFUT2, DTFUT3, DTFUT4, DTFUT5, DTFUT6, DTFUT7, DTFUT8,
         DTFUT9,DTFUT10,DTFUT11,DTFUT12,DTFUT13,DTFUT14,DTFUT15,DTFUT16)
                                 FILE RECORD SEQUENTIAL INTERNAL     /*INPUT AND OUTPUT*/
                                 ENV(FB   RECSIZE(LIST_LINE_SIZE)),
 
         DTFUT_LIST(001:016)     FILE  VARIABLE  INIT(DTFUT1, DTFUT2, DTFUT3, DTFUT4,
                                                      DTFUT5, DTFUT6, DTFUT7, DTFUT8,
                                                      DTFUT9, DTFUT10,DTFUT11,DTFUT12,
                                                      DTFUT13,DTFUT14,DTFUT15,DTFUT16);
    %SKIP(5);
    DECLARE                    /*SMP/E "SMPLIST" ELEMENT LISTING SPILL FILE(S)*/
      01 SMPUT(IFILE_MIN:IFILE_MAX)    CONTROLLED,  /*SPILL FILE MANAGEMENT ARRAY*/
         05 FILEREF              FILE  VARIABLE,
         05 DDNAME               CHAR(008),
         05 LINE_SAVE(LINE_SAVE_LIMIT) CHAR(LIST_LINE_SIZE),  /*RESERVE SAVE_LIMIT LINES*/
         05 WRITE,
            09 SAVE_CT           FIXED BIN(31,0),
            09 OPEN_CT           FIXED BIN(31,0),
            09 LINE_CT           FIXED BIN(31,0),
         05 READ,
            09 OPEN_CT           FIXED BIN(31,0),
            09 LINE_CT           FIXED BIN(31,0);
    %PAGE;
    DECLARE                      /*SMPSCAN SMPLIST SCAN HIGHLIGHTED OUTPUT*/
        (DTFSCAN1,DTFSCAN2,DTFSCAN3,DTFSCAN4,DTFSCAN5,DTFSCAN6,DTFSCAN7,DTFSCAN8,
         DTFSCAN9,DTFSCN10,DTFSCN11,DTFSCN12,DTFSCN13,DTFSCN14,DTFSCN15,DTFSCN16)
                                 FILE STREAM OUTPUT PRINT INTERNAL
                                 ENV(FB  RECSIZE(LIST_LINE_RCZN)),
 
         DTFSCAN_LIST(001:016)   FILE  VARIABLE  INIT(DTFSCAN1,DTFSCAN2,DTFSCAN3,DTFSCAN4,
                                                      DTFSCAN5,DTFSCAN6,DTFSCAN7,DTFSCAN8,
                                                      DTFSCAN9,DTFSCN10,DTFSCN11,DTFSCN12,
                                                      DTFSCN13,DTFSCN14,DTFSCN15,DTFSCN16);
    %SKIP(5);
    DECLARE                      /*SMPSCAN SMPLIST SCAN HIGHLIGHTED OUTPUT*/
      01 SMPSCAN(IFILE_MIN:IFILE_MAX)  CONTROLLED,
         05 FILEREF              FILE  VARIABLE,
         05 DDNAME               CHAR(008),
         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */
         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */
         05 PAGE_SZ              FIXED BIN(15,0),          /*OUTPUT PAGE SIZE            */
         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */
         05 CURR_PAGE,
            09 PAGE_NO           FIXED BIN(31,0),          /*CURRENT PAGE NUMBER         */
            09 PAGEKEY           CHAR(011),
            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
         05 CURR_NTRY,
            09 PAGE_NO           FIXED BIN(31,0),          /*FIRST LISTING PAGE OF ENTRY */
            09 PAGEKEY           CHAR(011);
 
    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */
         SMPSCAN_TITLE1_MAP_ADDR                 POINTER,
      01 SMPSCAN_TITLE1_MAP      BASED(SMPSCAN_TITLE1_MAP_ADDR)
                                 LIKE  SMPLIST_TITLE1_MAP;
    %PAGE;
    DECLARE                      /*SMPSCAN SMPLIST RELIST OUTPUT*/
        (DTFSOUT1,DTFSOUT2,DTFSOUT3,DTFSOUT4,DTFSOUT5,DTFSOUT6,DTFSOUT7,DTFSOUT8,
         DTFSOUT9,DTFSOU10,DTFSOU11,DTFSOU12,DTFSOU13,DTFSOU14,DTFSOU15,DTFSOU16)
                                 FILE STREAM OUTPUT PRINT INTERNAL
                                 ENV(FB  RECSIZE(LIST_LINE_RCZL)),
 
         DTFSOUT_LIST(001:016)   FILE  VARIABLE  INIT(DTFSOUT1,DTFSOUT2,DTFSOUT3,DTFSOUT4,
                                                      DTFSOUT5,DTFSOUT6,DTFSOUT7,DTFSOUT8,
                                                      DTFSOUT9,DTFSOU10,DTFSOU11,DTFSOU12,
                                                      DTFSOU13,DTFSOU14,DTFSOU15,DTFSOU16);
    %SKIP(5);
    DECLARE
      01 SMPSOUT(IFILE_MIN:IFILE_MAX)  CONTROLLED,
         05 FILEREF              FILE  VARIABLE,
         05 DDNAME               CHAR(008),
         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */
         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */
         05 PAGE_SZ              FIXED BIN(15,0),          /*OUTPUT PAGE SIZE            */
         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */
         05 CURR_PAGE,
            09 PAGE_NO           FIXED BIN(31,0),          /*CURRENT PAGE NUMBER         */
            09 PAGEKEY           CHAR(011),
            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
         05 CURR_NTRY,
            09 PAGE_NO           FIXED BIN(31,0),          /*FIRST LISTING PAGE OF ENTRY */
            09 PAGEKEY           CHAR(011);
 
    DECLARE
         SMPSOUT_TITLE1_MAP_ADDR                 POINTER,
      01 SMPSOUT_TITLE1_MAP      BASED(SMPSOUT_TITLE1_MAP_ADDR)
                                 LIKE  SMPLIST_TITLE1_MAP;
 
    %PAGE;
    DECLARE                      /*SMPSCAN SMPLIST CARD IMAGE OUTPUT*/
        (DTFDATA1,DTFDATA2,DTFDATA3,DTFDATA4,DTFDATA5,DTFDATA6,DTFDATA7,DTFDATA8,
         DTFDATA9,DTFDAT10,DTFDAT11,DTFDAT12,DTFDAT13,DTFDAT14,DTFDAT15,DTFDAT16)
                                 FILE STREAM OUTPUT INTERNAL
                                 ENV(FB  RECSIZE(LIST_LINE_RCZD)),
 
         DTFDATA_LIST(001:016)   FILE  VARIABLE  INIT(DTFDATA1,DTFDATA2,DTFDATA3,DTFDATA4,
                                                      DTFDATA5,DTFDATA6,DTFDATA7,DTFDATA8,
                                                      DTFDATA9,DTFDAT10,DTFDAT11,DTFDAT12,
                                                      DTFDAT13,DTFDAT14,DTFDAT15,DTFDAT16);
    %SKIP(5);
    DECLARE
      01 SMPDATA(IFILE_MIN:IFILE_MAX)  CONTROLLED,
         05 FILEREF              FILE  VARIABLE,
         05 DDNAME               CHAR(008),
         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */
         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */
         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */
         05 CURR_CARD,
            09 DATA              CHAR(072),
            09 SEQ_NO            FIXED BIN(31,0),
         05 CURR_NTRY,
            09 SEQ_NO            FIXED BIN(31,0);      /*SEQ # OF FIRST LINE OF ENTRY*/
    %PAGE;
 SMPSCAN_MAINLINE:
    /******************************************************************/
    /*   SMPSCAN MAINLINE ROUTINE                                     */
    /******************************************************************/
 
    ON ERROR
       BEGIN;
            ON ERROR SYSTEM;
            PUT DATA;                                                           /*DEBUG*/
            CALL PLIDUMP;
       END;
    %SKIP(03);
    CALL SMPDCTRY_OPEN;             /*OPEN THE DIAGNOSTIC MSG/DIRECTORY DATA SET        */
    CALL CONTROL_VALUE_INPUT;  /*INIT/READ/VALIDATE THE PROGRAM EXECUTION CONTROL VALUES*/
    CALL SMPLIST_OPEN;              /*OPEN INPUT AND OUTPUT DATA SETS,                  */
                                    /*AND READ THE FIRST LINES OF INPUT                 */
    CALL SMPDCTRY_INITIAL_INFO;     /*DOCUMENT FILE STATUS AND CONTROL VALUES           */
    CALL SMPLIST_ENTRY_READ;        /*READ THE FIRST SET OF ENTRIES, DETERMINE SCAN     */
                                    /*RESULTS, COMPARE FILES FOR LOWEST KEYS, AND       */
                                    /*DETERMINE IF THIS IS A MATCH.                     */
 
    DO   WHILE(SMPLIST_CNTL.E_CMPR.RESULT);           /*WHILE ENTRIES REMAIN TO PROCESS */
 
         IF       (SMPLIST_CNTL.A_MATCH.RESULT)       /*IF THIS IS A SUCCESSFUL MATCH   */
             & ANY(SMPLIST.CURR_NTRY.WRITE_OUT)       /*AND ANY ARE TO BE WRITTEN,      */
           THEN CALL  SMPLIST_ENTRY_WRITE;            /*WRITE OUT THE SELECTED ENTRIES. */
 
         IF       (SMPLIST_CNTL.A_MATCH.RESULT)       /*IF THIS IS A SUCCESSFUL MATCH,  */
           THEN CALL  SMPDCTRY_ENTRY_INFO;            /*WRITE ENTRY LOCATOR INFORMATION.*/
 
         CALL  SMPLIST_ENTRY_READ;                    /*READ THE NEXT SET OF ENTRIES,   */
                                                      /*DETERMINE SCAN RESULTS,         */
                                                      /*COMPARE FILES FOR LOWEST KEYS,  */
                                                      /*AND DETERMINE IF THIS IS A MATCH*/
    END;
 
    CALL SMPLIST_WRAPUP;            /*CALCULATE FINAL VALUES                            */
    CALL SMPDCTRY_FINAL_INFO;       /*WRITE OUT FINAL PROCESSING TOTALS                 */
    CALL SMPLIST_CLOSE;             /*CLOSE THE INPUT AND OUTPUT DATA SET(S)            */
    CALL SMPDCTRY_CLOSE;            /*CLOSE THE DIAGNOSTIC MSG/DIRECTORY DATA SET       */
 
    RETURN;                         /*RETURN TO CALLER OF SMPSCAN                       */
 %PAGE;
 SMPDCTRY_OPEN:
   PROC;
      ALLOCATE SMPDCTRY;                            /*ALLOCATE FILE MANAGEMENT STRUCTURE*/
      SMPDCTRY.FILEREF                =   DTFDCTRY; /*INITIALIZE FILE VARIABLE REFERENCE*/
      PUT STRING(SMPDCTRY.DDNAME)         EDIT(DDIPFX,'DCTRY')             (A,A);  /*DDN*/
      SMPDCTRY.OPEN                   =  '0'B;              /*INITIALIZE OPEN INDICATOR */
      SMPDCTRY.PAGE_SZ                =   060;              /*INITIALIZE PAGE SIZE      */
      SMPDCTRY.LINE_SZ                =   LIST_LINE_SIZE + 012; /*INITIALIZE LINE SIZE  */
      SMPDCTRY.CURR_PAGE.PAGE_NO      =   0000;             /*INITIALIZE PAGE NUMBER    */
      SMPDCTRY.CURR_PAGE.INFO_1STLINE =   000;              /*INITIALIZE 1ST INFO LINE #*/
      SMPDCTRY.CURR_PAGE.NTRYINDX     = NTRYINDX_MIN - 1;   /*INITIALIZE ENTRY INDEX    */
      SMPDCTRY.CURR_PAGE.TITLE2_DATA  = ' ';                /*INITIALIZE TITLE LINES    */
      SMPDCTRY.CURR_PAGE.TITLE3_DATA  = ' ';                /*INITIALIZE TITLE LINES    */
 
      OPEN  FILE(SMPDCTRY.FILEREF) OUTPUT
            PAGESIZE(SMPDCTRY.PAGE_SZ) LINESIZE(SMPDCTRY.LINE_SZ)
            TITLE(SMPDCTRY.DDNAME);
 
      SMPDCTRY.OPEN          =   '1'B;           /*INDICATE FILE IS OPEN*/
 
   END SMPDCTRY_OPEN;
 %SKIP(3);
 SMPDCTRY_CLOSE: /*SUBROUTINE TO CLOSE THE "SMPDCTRY" DATA SET */
    PROC;
       CLOSE FILE(SMPDCTRY.FILEREF) ENV(LEAVE);
 
      SMPDCTRY.OPEN          =   '0'B;           /*INDICATE FILE IS NO LONGER OPEN*/
    END SMPDCTRY_CLOSE;      /*END OF "SMPDCTRY_CLOSE" SUBROUTINE*/
 %PAGE;
 SMPDCTRY_NEWPAGE:
   PROC;
      DCL  NEWPAGE_DATE               CHAR(006), /*STORE DATE FROM "DATE" FUNCTION*/
           NEWPAGE_TIME               CHAR(009); /*STORE TIME FROM "TIME" FUNCTION*/
 
      IF LINENO(SMPDCTRY.FILEREF) > 1 THEN PUT FILE(SMPDCTRY.FILEREF) PAGE;
      SMPDCTRY.CURR_PAGE.PAGE_NO      =   SMPDCTRY.CURR_PAGE.PAGE_NO + 1;
      NEWPAGE_DATE                    =   DATE();
      NEWPAGE_TIME                    =   TIME();
      SMPDCTRY.CURR_PAGE.TITLE1_DATE  =   SUBSTR(NEWPAGE_DATE,03,02)  /*MM*/
                                       || '/'
                                       || SUBSTR(NEWPAGE_DATE,05,02)  /*DD*/
                                       || '/'
                                       || SUBSTR(NEWPAGE_DATE,01,02); /*YY*/
 
      SMPDCTRY.CURR_PAGE.TITLE1_TIME  =   SUBSTR(NEWPAGE_TIME,01,02)  /*HH*/
                                       || ':'
                                       || SUBSTR(NEWPAGE_TIME,03,02)  /*MM*/
                                       || ':'
                                       || SUBSTR(NEWPAGE_TIME,05,02)  /*SS*/
                                       || '.'
                                       || SUBSTR(NEWPAGE_TIME,07,03); /*XCM*/
      PUT    FILE(SMPDCTRY.FILEREF)              /*TITLE1 LINE*/
             EDIT('DATE:',SMPDCTRY.CURR_PAGE.TITLE1_DATE)  (COL(001),A,X(1),A)
                 ('TIME:',SMPDCTRY.CURR_PAGE.TITLE1_TIME)  (X(2),A,X(1),A(012))
                 ('SMPSCAN  LVL',SMPSCAN_LVL)              (X(2),A,X(1),A)
                 ('C.U. SMP/E LIST ENTRY SELECTION')       (X(3),A)
                 ('--','SMPDCTRY OUTPUT')                  (X(1),A,X(1),A)
                 ('PAGE', SMPDCTRY.CURR_PAGE.PAGE_NO)      (COL(110),A,X(1),P'9999');
 
      CALL   SMPDCTRY_NEWTITLE_2_3;              /*WRITE TITLE LINES 2 & 3*/
      SMPDCTRY.CURR_PAGE.INFO_1STLINE = LINENO(SMPDCTRY.FILEREF) + 1;
   END SMPDCTRY_NEWPAGE;
 %SKIP(2);
 SMPDCTRY_NEWTITLE_2_3:                          /*WRITE TITLE LINES 2 & 3*/
   PROC;
      PUT    FILE(SMPDCTRY.FILEREF)              /*TITLE2 LINE*/
             EDIT(' ')                                     (SKIP(1),A)
                 ('SMPSCAN')                               (SKIP(1),COL(001),A)
                 (SMPDCTRY.CURR_PAGE.TITLE2_DATA)          (COL(011),A(110))
                 (' ')                                     (SKIP(1),A);
      IF  SMPDCTRY.CURR_PAGE.TITLE3_DATA ^= ' '  /*IF A TITLE3 LINE IS PRESENT*/
        THEN
         PUT FILE(SMPDCTRY.FILEREF)
             EDIT(' ')                                     (SKIP(1),A)
                 (SMPDCTRY.CURR_PAGE.TITLE3_DATA)          (SKIP(1),A)
                 (' ')                                     (SKIP(1),A);
   END SMPDCTRY_NEWTITLE_2_3;
 %PAGE;
 SMPDCTRY_INITIAL_INFO:
   PROC;
 
            /*-------------------------------------------------------------------------*/
            /* ASSEMBLE TITLE2 LINE AND SET UP END-OF-PAGE CONTROL:                    */
            /*-------------------------------------------------------------------------*/
 
      SMPDCTRY.CURR_PAGE.NTRYINDX     = NTRYINDX_MIN - 1;
      SMPDCTRY.CURR_PAGE.TITLE2_DATA  =
              'DIAGNOSTIC MESSAGES AND EXECUTION CONTROL VALUES:';
 
      ON ENDPAGE(SMPDCTRY.FILEREF) CALL SMPDCTRY_NEWPAGE;
 
            /*-------------------------------------------------------------------------*/
            /* PRINT FILE STATUS INFORMATION AND SCAN_ARRAY CONTENTS FOR ALL           */
            /* SUPPORTED FILES:                                                        */
            /*-------------------------------------------------------------------------*/
      CALL     SMPDCTRY_INITIAL_FILE_INFO;
 
            /*-------------------------------------------------------------------------*/
            /* PRINT MATCH_ARRAY CONTROL INFORMATION IF VALUES HAVE BEEN PROVIDED:     */
            /*-------------------------------------------------------------------------*/
      CALL     SMPDCTRY_INITIAL_MATCH_INFO;
 
      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_INFO*/
 %PAGE;
 SMPDCTRY_INITIAL_FILE_INFO: /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_INFO    */
   PROC;
 
      DCL  FILE_LIST_LINE_CT       FIXED BINARY(15,0);
 
            /*-------------------------------------------------------------------------*/
            /* ASSEMBLE TITLE3 LINE AND BEGIN A NEW PAGE:                              */
            /*-------------------------------------------------------------------------*/
      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  '  FILE  ';
      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)
                                      =  'STATUS INFORMATION AND SCAN ARRAY CONTENTS:';
 
      SIGNAL ENDPAGE(SMPDCTRY.FILEREF)/**/;                          /*START A NEW PAGE*/
 
            /*-------------------------------------------------------------------------*/
            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */
            /*-------------------------------------------------------------------------*/
 
      DO  IFILE = IFILE_MIN TO IFILE_MAX;                     /*FOR EACH SUPPORTED FILE*/
 
        IF   (SMPLIST(IFILE).ACTIVE)                            /*IF THE FILE IS ACTIVE*/
          THEN     CALL SMPDCTRY_INITIAL_FILE_F_INFO        /*WHEN THE FILE IS   ACTIVE*/;
          ELSE  /* CALL SMPDCTRY_INITIAL_FILE_F_INFO        /*WHEN THE FILE IS INACTIVE*/;
 
      END;                       /*END OF IFILE DO GROUP*/
 
      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_INFO*/
     %PAGE;
 SMPDCTRY_INITIAL_FILE_F_INFO:     /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_INFO*/
   PROC;                        /*IFILE IS SET ON ENTRY  TO SMPDCTRY_INITIAL_FILE_F_INFO*/
            /*-------------------------------------------------------------------------*/
            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */
            /*-------------------------------------------------------------------------*/
      IF   (SMPLIST(IFILE).ACTIVE)                              /*IF THE FILE IS ACTIVE*/
        THEN  FILE_LIST_LINE_CT = 01 + SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT
                                     + SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE;
        ELSE  FILE_LIST_LINE_CT = 01;
 
      IF         (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ -(FILE_LIST_LINE_CT+02)))
          THEN                                   /*IF LISTING WILL FIT ON CURRENT PAGE*/
              IF (LINENO(SMPDCTRY.FILEREF) >=  SMPDCTRY.CURR_PAGE.INFO_1STLINE)
               THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);     /*CONTINUE ON CURRENT PAGE*/
               ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);     /*CONTINUE ON CURRENT PAGE*/
          ELSE                                   /*IF LISTING WON'T FIT ON CURRENT PAGE*/
              IF (LINENO(SMPDCTRY.FILEREF) >=  SMPDCTRY.CURR_PAGE.INFO_1STLINE)
               THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);        /*START ON A NEW PAGE     */
               ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);     /*CONTINUE ON CURRENT PAGE*/
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('FILE(',IFILE,') IS:')                               (COL(001),A,P'999',A);
 
      IF   (SMPLIST(IFILE).ACTIVE)                /*ONE LINE FOR EACH ACTIVE INPUT FILE*/
        THEN                                                    /*IF THE FILE IS ACTIVE*/
          DO;
            PUT FILE(SMPDCTRY.FILEREF) EDIT('ACTIVE')                        (COL(016),A)
                    ('LIST DDNAME=')                                         (COL(026),A)
                    ( SMPLIST(IFILE).DDNAME)                                          (A)
                    ('SCAN SELECTION IS:')                                   (COL(051),A);
            IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)
              THEN  PUT FILE(SMPDCTRY.FILEREF) EDIT('ACTIVE')                (COL(071),A);
              ELSE  PUT FILE(SMPDCTRY.FILEREF) EDIT('INACTIVE')              (COL(071),A);
            IF (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))
              THEN  PUT FILE(SMPDCTRY.FILEREF)           /*IF ENTRIES ARE BEING WRITTEN*/
                        EDIT('SCAN DDNAME=',SMPSCAN(IFILE).DDNAME) (SKIP(1),COL(026),A,A)
                            ('SOUT DDNAME=',SMPSOUT(IFILE).DDNAME) (SKIP(1),COL(026),A,A)
                            ('DATA DDNAME=',SMPDATA(IFILE).DDNAME) (SKIP(1),COL(026),A,A)
                            ('OUTPUT OPTION IS:')                            (COL(052),A)
                            ( DATA_OUTPUT_OPTION(IFILE))                     (COL(071),A);
              ELSE  PUT FILE(SMPDCTRY.FILEREF)       /*IF ENTRIES ARE NOT BEING WRITTEN*/
                        EDIT('**ENTRIES ARE NOT BEING WRITTEN**')    (SKIP(1),COL(026),A);
            IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)             /*SCAN ARRAY INFO FOR FILE*/
              THEN  CALL     SMPDCTRY_INITIAL_FILE_FS_INFO;
          END;                   /*END OF ACTIVE IFILE DO GROUP*/
        ELSE                                                  /*IF THE FILE IS INACTIVE*/
          DO;
            PUT FILE(SMPDCTRY.FILEREF) EDIT('INACTIVE')                      (COL(016),A);
          END;                   /*END OF INACTIVE IFILE DO GROUP*/
 
      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_F_INFO*/
 %PAGE;
 SMPDCTRY_INITIAL_FILE_FS_INFO:    /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_F_INFO*/
   PROC;                        /*IFILE IS SET ON ENTRY  TO SMPDCTRY_INITIAL_FILE_FS_INFO*/
            /*-------------------------------------------------------------------------*/
            /* IF SCAN SELECTION IS BEING USED WITH A FILE, PRINT THE SCAN_ARRAY:      */
            /*-------------------------------------------------------------------------*/
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('SCAN_ARRAY:')                                       (SKIP(1),COL(011),A)
              ('FILE SELECT OPTION IS:')                                    (COL(047),A)
              (SCAN_ARRAY.FILE(IFILE).SELECT_OPTION)                        (COL(071),A);
      DO  IPLANE = IPLANE_MIN TO IPLANE_MAX;
        IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)       /*IF PLANE IS ACTIVE*/
          THEN
            DO;
              PUT FILE(SMPDCTRY.FILEREF)
                  EDIT('PLANE(',IPLANE,'):')               (SKIP(1),COL(016),A,P'999',A)
                      ('PLANE SELECT OPTION IS:')                           (COL(046),A)
                      (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION)  (COL(071),A);
              DO  IROW = IROW_MIN TO IROW_MAX;
                IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)
                 THEN
                   DO;
                     PUT FILE(SMPDCTRY.FILEREF)
                         EDIT('ROW(',IROW,'):')            (SKIP(1),COL(022),A,P'999',A)
                             ('ROW SELECT OPTION IS:')                      (COL(048),A)
                             (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION)
                                                                            (COL(071),A);
                     DO  ICOL = ICOL_MIN TO ICOL_MAX;
                       IF  (SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL) > 0)  /*IF STRING*/
                         THEN  CALL  SMPDCTRY_INITIAL_FILE_FSE_INFO;
 
                     END;          /*END OF ICOL          DO GROUP*/
                   END;            /*END OF ACTIVE IROW   DO GROUP*/
              END;                 /*END OF IROW          DO GROUP*/
            END;                   /*END OF ACTIVE IPLANE DO GROUP*/
      END;                         /*END OF IPLANE        DO GROUP*/
      RETURN;                      /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_FS_INFO*/
 %PAGE;
 SMPDCTRY_INITIAL_FILE_FSE_INFO:   /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_FS_INFO*/
   PROC;                            /*IFILE, IPLANE, IROW, AND ICOL ARE SET ON ENTRY   */
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('COL(',ICOL,'):')                           (SKIP(1),COL(026),A,P'999',A);
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('OP=',
                SCAN_ARRAY(IFILE).OP(IPLANE,IROW,ICOL))              (COL(037),A,A(008));
 
      IF   (SCAN_ARRAY(IFILE).STR_NIX(IPLANE,IROW,ICOL) <  NTRYINDX_MIN)
        THEN
          DO;
            PUT FILE(SMPDCTRY.FILEREF)
                EDIT('BEGIN POS=',
                      SCAN_ARRAY(IFILE).BEG_POS(IPLANE,IROW,ICOL))   (COL(049),A,P'999');
            PUT FILE(SMPDCTRY.FILEREF)
                EDIT('END POS=',
                      SCAN_ARRAY(IFILE).END_POS(IPLANE,IROW,ICOL))   (COL(064),A,P'999');
          END;
        ELSE
          DO;
            PUT FILE(SMPDCTRY.FILEREF)
                EDIT('ENTRY INDEX=',
                      SCAN_ARRAY(IFILE).STR_NIX(IPLANE,IROW,ICOL))   (COL(060),A,P'999');
          END;
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('STR LEN=',
                SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL))         (COL(077),A,P'999');
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('STRING=',
               '"',SCAN_ARRAY(IFILE).STRING(IPLANE,IROW,ICOL),'"')    (COL(090),A,A,A,A);
 
   END SMPDCTRY_INITIAL_FILE_FSE_INFO;
  %SKIP(2);
   END SMPDCTRY_INITIAL_FILE_FS_INFO;
  %SKIP(2);
   END SMPDCTRY_INITIAL_FILE_F_INFO;
  %SKIP(2);
   END SMPDCTRY_INITIAL_FILE_INFO;
 %PAGE;
 SMPDCTRY_INITIAL_MATCH_INFO: /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_INFO   */
   PROC;
      DCL  MATCH_LIST_LINE_CT      FIXED BINARY(15,0);
            /*-------------------------------------------------------------------------*/
            /* ASSEMBLE TITLE3 LINE AND BEGIN A NEW PAGE:                              */
            /*-------------------------------------------------------------------------*/
      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  ' MATCH  ';
      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)
                                      =  'STATUS INFORMATION AND MATCH ARRAY CONTENTS:';
 
      SIGNAL ENDPAGE(SMPDCTRY.FILEREF)/**/;                          /*START A NEW PAGE*/
 
            /*-------------------------------------------------------------------------*/
            /* PRINT MATCH_ARRAY CONTENTS AND STATUS INFORMATION:                      */
            /*-------------------------------------------------------------------------*/
      IF  (SMPLIST_CNTL.A_MATCH.ACTIVE)           /*TEST FOR ENTRY MATCH TESTS PROVIDED*/
        THEN                              /*IF ANY ENTRY MATCH TESTS HAVE BEEN PROVIDED*/
          DO    IMATCH = IMATCH_MIN TO IMATCH_MAX;
            IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE    /*IF MATCH ENTRY ACTIVE*/
              THEN                                  /*WHEN MATCH ARRAY ENTRY IS   ACTIVE*/
                  CALL  SMPDCTRY_INITIAL_MATCH_E_INFO;
              ELSE                                  /*WHEN MATCH ARRAY ENTRY IS INACTIVE*/
               /* CALL  SMPDCTRY_INITIAL_MATCH_E_INFO/**/;
          END;                    /*END OF IMATCH DO GROUP*/
 
        ELSE                      /*IF NO  ENTRY MATCH TESTS HAVE BEEN PROVIDED*/
            PUT FILE(SMPDCTRY.FILEREF)
                EDIT('***MATCH ARRAY IS NOT ACTIVE -- ')             (SKIP(3),COL(016),A)
                    ('FILE MATCHING WILL BE BASED ON SCAN RESULTS***')                (A);
 
      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_MATCH_INFO*/
 %PAGE;
 SMPDCTRY_INITIAL_MATCH_E_INFO:
                             /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_MATCH_INFO*/
   PROC;
            /*-------------------------------------------------------------------------*/
            /* PRINT MATCH_ARRAY ENTRY CONTENTS AND STATUS INFORMATION:                */
            /*-------------------------------------------------------------------------*/
      IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE         /*IF MATCH ENTRY ACTIVE*/
        THEN  MATCH_LIST_LINE_CT  =  01 + SMPLIST_CNTL.A_STAT.#_F_ACTIVE;
        ELSE  MATCH_LIST_LINE_CT  =  01;
 
      IF (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ - (MATCH_LIST_LINE_CT + 02)))
        THEN                                      /*IF LISTING WILL FIT ON CURRENT PAGE*/
            IF (LINENO(SMPDCTRY.FILEREF) >= SMPDCTRY.CURR_PAGE.INFO_1STLINE)
              THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);      /*CONTINUE ON CURRENT PAGE*/
              ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);      /*CONTINUE ON CURRENT PAGE*/
        ELSE                                     /*IF LISTING WON'T FIT ON CURRENT PAGE*/
            IF (LINENO(SMPDCTRY.FILEREF) >= SMPDCTRY.CURR_PAGE.INFO_1STLINE)
              THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);         /*START ON A NEW PAGE     */
              ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);      /*CONTINUE ON CURRENT PAGE*/
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('ENTRY(',IMATCH,'):')                                (COL(001),A,P'999',A)
              ('ENTRY   TYPE=')                                              (COL(015),A)
              ( MATCH_ARRAY.ENTRY(IMATCH).TYPE)                                       (A);
 
      IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE         /*IF MATCH ENTRY ACTIVE*/
        THEN                                         /*WHEN MATCH ARRAY ENTRY IS ACTIVE*/
            CALL  SMPDCTRY_INITIAL_MATCH_F_INFO;
        ELSE                                     /*WHEN MATCH ARRAY ENTRY IS NOT ACTIVE*/
            PUT FILE(SMPDCTRY.FILEREF)
                EDIT('***ENTRY IS NOT ACTIVE***')                            (COL(036),A);
 
      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_MATCH_E_INFO*/
 %PAGE;
 SMPDCTRY_INITIAL_MATCH_F_INFO:
                           /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_MATCH_E_INFO*/
   PROC;
      DCL  MATCH_FILE_LINE_NO      FIXED BINARY(15,0);
            /*-------------------------------------------------------------------------*/
            /* PRINT FILE MATCH INFORMATION FOR THE MATCH_ARRAY ENTRY:                 */
            /*-------------------------------------------------------------------------*/
      MATCH_FILE_LINE_NO = 0;                           /*PRESET FOR IFILE DO GROUP*/
      DO   IFILE = IFILE_MIN TO IFILE_MAX;
        IF (SMPLIST(IFILE).ACTIVE)                /*ONE LINE FOR EACH ACTIVE INPUT FILE*/
          THEN                                                  /*IF THE FILE IS ACTIVE*/
            DO;
              MATCH_FILE_LINE_NO = MATCH_FILE_LINE_NO + 1;
 
              IF    (MATCH_FILE_LINE_NO = 1)
                THEN PUT FILE(SMPDCTRY.FILEREF)     SKIP(1)
                         EDIT('COMPARE TEST=')                               (COL(015),A)
                             ( MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST)                (A);
                ELSE PUT FILE(SMPDCTRY.FILEREF)     SKIP(1);
 
              PUT FILE(SMPDCTRY.FILEREF)
                  EDIT('FILE(',IFILE,'):')                          (COL(036),A,P'999',A)
                      ('COMPARE: OPTION=')                                   (COL(048),A)
                      ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION)    (A(009));
              IF       (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION ^= 'NOCOMPARE')
                THEN PUT FILE(SMPDCTRY.FILEREF)
                         EDIT('SELECT=')                                         (X(2),A)
                             ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT)
                                                                                 (A(008));
              PUT FILE(SMPDCTRY.FILEREF)
                  EDIT('WRITE: OPTION=')                                     (COL(094),A)
                      ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION)      (A(007));
              IF       (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION ^= 'NOWRITE')
                THEN PUT FILE(SMPDCTRY.FILEREF)
                         EDIT('SELECT=')                                         (X(2),A)
                             ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT)
                                                                                 (A(008));
            END;                  /*END OF ACTIVE IFILE DO GROUP*/
      END;                        /*END OF IFILE DO GROUP*/
 
   END SMPDCTRY_INITIAL_MATCH_F_INFO;
  %SKIP(1);
   END SMPDCTRY_INITIAL_MATCH_E_INFO;
  %SKIP(1);
   END SMPDCTRY_INITIAL_MATCH_INFO;
  %SKIP(2);
   END SMPDCTRY_INITIAL_INFO;
 %PAGE;
 SMPDCTRY_ENTRY_INFO:            /********************************************************/
                                 /*                                                      */
                                 /*                                                      */
                                 /********************************************************/
   PROC;
      DCL  ENTRY_INFO_LINE_NO      FIXED BINARY(15,0);
 
      ON ENDPAGE(SMPDCTRY.FILEREF) CALL SMPDCTRY_NEWPAGE;
 
            /*-------------------------------------------------------------------------*/
            /* IF THIS IS THE FIRST ENTRY BEING REPORTED, OR IF THE ENTRY TYPE IS      */
            /* CHANGING, ASSEMBLE NEW TITLE2 AND TITLE3 LINES:                         */
            /*-------------------------------------------------------------------------*/
      IF     (SMPDCTRY.CURR_PAGE.NTRYINDX  <  NTRYINDX_MIN)   /*IF FIRST ENTRY TO WRITE*/
          |                                                   /*OR NEW ENTRY TYPE      */
             (SMPDCTRY.CURR_PAGE.NTRYINDX  ^= SMPLIST_CNTL.E_CMPR.NTRYINDX)
        THEN
          DO;                                /*ASSEMBLE TITLES 2 & 3 FOR NEW ENTRY TYPE*/
            SMPDCTRY.CURR_PAGE.TITLE2_DATA  =    'DIRECTORY OF MATCHING'
                                              ||  ' '
                                              ||  ENTRY_TYPE(SMPLIST_CNTL.E_CMPR.NTRYINDX)
                                              ||  ' '
                                              ||  'ENTRIES:';
            SMPDCTRY.CURR_PAGE.TITLE3_DATA  =     '  NAME  ';
            SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)  =  'STATUS';
            SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,066)  =  'LOCATOR INFORMATION';
          END;
     %PAGE;
            /*-------------------------------------------------------------------------*/
            /* DETERMINE WHETHER TO START A NEW PAGE, REPRINT TITLES 2 & 3 OF THE      */
            /* CURRENT PAGE, OR MERELY SPACE ONE LINE BEFORE STARTING TO PRINT THE     */
            /* ENTRY INFORMATION FOR THE CURRENT MATCHING ENTRY:                       */
            /*-------------------------------------------------------------------------*/
      IF     (SMPDCTRY.CURR_PAGE.NTRYINDX  <  NTRYINDX_MIN)   /*IF FIRST ENTRY TO WRITE*/
 
        |    (SMPDCTRY.CURR_PAGE.NTRYINDX  ^= SMPLIST_CNTL.E_CMPR.NTRYINDX
           & (LINENO(SMPDCTRY.FILEREF)                     /*IF NOT ENOUGH ROOM ON PAGE*/
                 >  (SMPDCTRY.PAGE_SZ - (SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 01 + 05))))
 
        |    (SMPDCTRY.CURR_PAGE.NTRYINDX   = SMPLIST_CNTL.E_CMPR.NTRYINDX
           & (LINENO(SMPDCTRY.FILEREF)                     /*IF NOT ENOUGH ROOM ON PAGE*/
                 >  (SMPDCTRY.PAGE_SZ - (SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 01))))
 
        THEN      SIGNAL ENDPAGE(SMPDCTRY.FILEREF);      /*START ON A NEW PAGE         */
        ELSE                                             /*CONTINUE ON THE CURRENT PAGE*/
          IF (SMPDCTRY.CURR_PAGE.NTRYINDX  ^= SMPLIST_CNTL.E_CMPR.NTRYINDX)
 
          /*THEN    CALL SMPDCTRY_NEWTITLE_2_3           /*REWRITE TITLE LINES 2 & 3   */
            THEN  SIGNAL ENDPAGE(SMPDCTRY.FILEREF)       /*START ON A NEW PAGE ANYWAYS */;
            ELSE    PUT  FILE(SMPDCTRY.FILEREF)  SKIP(1);  /*SPACE ONE LINE            */
     %SKIP(3);
            /*-------------------------------------------------------------------------*/
            /* PRINT THE ENTRY INFORMATION REPORT LINES FOR THE CURRENT MATCHING       */
            /* ENTRY:                                                                  */
            /*-------------------------------------------------------------------------*/
 
      SMPDCTRY.CURR_PAGE.NTRYINDX  = SMPLIST_CNTL.E_CMPR.NTRYINDX;
      ENTRY_INFO_LINE_NO           = 0;          /*RESET ENTRY INFORMATION LINE COUNTER*/
 
      DO  IFILE = IFILE_MIN TO IFILE_MAX;         /*WRITE LOCATOR INFORMATION FOR ENTRY*/
        IF   (SMPLIST(IFILE).ACTIVE)              /*ONE LINE FOR EACH ACTIVE INPUT FILE*/
          THEN                                                  /*IF THE FILE IS ACTIVE*/
               CALL SMPDCTRY_ENTRY_FILE_INFO;
      END;                               /*END OF IFILE DO GROUP*/
 
      RETURN;                                    /*TO THE CALLER OF SMPDCTRY_ENTRY_INFO*/
 %PAGE;
 SMPDCTRY_ENTRY_FILE_INFO:
   PROC;                       /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_INFO     */
            /*-------------------------------------------------------------------------*/
            /* PRINT THE ENTRY INFORMATION REPORT LINE FOR THIS SMPLIST DATA SET:      */
            /*-------------------------------------------------------------------------*/
 
      ENTRY_INFO_LINE_NO  =  ENTRY_INFO_LINE_NO  +  1;            /*UPDATE LINE COUNTER*/
 
      IF    ENTRY_INFO_LINE_NO <= 01
        THEN  PUT FILE(SMPDCTRY.FILEREF)  SKIP(1)                 /*  ENTRY NAME       */
                  EDIT(SMPLIST_CNTL.E_CMPR.NTRYNAME)                       (COL(001),A);
        ELSE  PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);                /*SPACE ONE LINE     */
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('ZONE=',SMPLIST(IFILE).CURR_NTRY.ZONENAME)                (COL(011),A,A)
                  ('/',SMPLIST(IFILE).CURR_NTRY.ZONETYPE_C)                       (A,A);
     %PAGE;
      IF    SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST_CNTL.E_CMPR.NTRYINDX).ENTRY_CT > 0
        THEN                                     /*IF ENTRIES OF THIS TYPE WERE LISTED*/
          DO;
            IF   (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
              THEN                           /*IF ENTRY WAS FOUND IN THIS LISTING FILE*/
                DO;
                  CALL SMPDCTRY_ENTRY_FILE_STYPE_INFO;          /*FILL IN COLS 026-040*/
                  PUT FILE(SMPDCTRY.FILEREF)                              /*LINE COUNT*/
                      EDIT('LNCT=',SMPLIST(IFILE).CURR_NTRY.LINE_CT) (COL(041),A,P'9999');
                  IF  SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT /*SPILL FILE*/
                    THEN     PUT FILE(SMPDCTRY.FILEREF) EDIT('>UT<')            (X(1),A);
                    ELSE     PUT FILE(SMPDCTRY.FILEREF) EDIT('    ')            (X(1),A);
 
                  IF      SMPLIST(IFILE).SCAN_CUBE.ACTIVE               /*SCAN ACTIVE?*/
                    THEN
                      IF  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT          /*SCAN RESULTS*/
                        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','SEL') (COL(056),A,A);
                        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','XCL') (COL(056),A,A);
                    ELSE     PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','NOT') (COL(056),A,A);
 
                  PUT FILE(SMPDCTRY.FILEREF)               /*INPUT LISTING PAGE NUMBER*/
                      EDIT(SUBSTR(SMPLIST(IFILE).DDNAME,004),'PG=',
                           SMPLIST(IFILE).CURR_NTRY.PAGE_NO)    (X(2),A,X(1),A,P'Z9999');
 
                  IF (SMPLIST(IFILE).CURR_NTRY.WRITE_OUT)
                    THEN                /*IF ENTRY WAS WRITTEN TO OUTPUT DATA SETS*/
                        CALL SMPDCTRY_ENTRY_FILE_WRT_INFO;
                    ELSE                /*IF ENTRY WAS NOT WRITTEN TO OUTPUT DATA SETS*/
                        PUT FILE(SMPDCTRY.FILEREF) EDIT('**ENTRY NOT WRITTEN**') (X(2),A);
                END;                       /*END OF SUCCESSFUL CMPR_RESULT DO GROUP*/
 
              ELSE                      /*IF ENTRY WAS NOT FOUND IN THIS LISTING FILE*/
                    PUT FILE(SMPDCTRY.FILEREF)  EDIT('**ENTRY NOT FOUND**')  (COL(056),A);
          END;                          /*END OF POSITIVE ENTRY_CT DO GROUP*/
        ELSE                            /*IF ENTRIES OF THIS TYPE WERE NOT LISTED*/
            PUT FILE(SMPDCTRY.FILEREF)
                EDIT('***',ENTRY_TYPE(SMPLIST_CNTL.E_CMPR.NTRYINDX),
                     'ENTRIES NOT FOUND***')                        (COL(056),A,A,X(1),A);
      RETURN;                           /*TO THE CALLER OF SMPDCTRY_ENTRY_FILE_INFO*/
 %PAGE;
 SMPDCTRY_ENTRY_FILE_STYPE_INFO:
   PROC;                     /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_STYPE_INFO */
      SELECT;
        WHEN((SMPLIST(IFILE).CURR_NTRY.FMID        ^=  ' ')         /*FMID*/
           & (SMPLIST(IFILE).CURR_NTRY.ZONETYPE_C  ^=  'G'))
          PUT FILE(SMPDCTRY.FILEREF)
              EDIT(' FMID=',SMPLIST(IFILE).CURR_NTRY.FMID)    (COL(026),A,A);
 
        WHEN((SMPLIST(IFILE).CURR_NTRY.SOURCEID    ^=  ' '))       /*SRCID*/
          PUT FILE(SMPDCTRY.FILEREF)
              EDIT('SRCID=',SMPLIST(IFILE).CURR_NTRY.SOURCEID) (COL(026),A,A);
 
        WHEN((SMPLIST(IFILE).CURR_NTRY.SYSLIB1     ^=  ' ')      /*SYSLIB1*/
           & (SMPLIST(IFILE).CURR_NTRY.SYSLIB2      =  ' '))     /*SYSLIB2*/
          PUT FILE(SMPDCTRY.FILEREF)
              EDIT(' SLIB=',SMPLIST(IFILE).CURR_NTRY.SYSLIB1)  (COL(026),A,A);
 
        WHEN((SMPLIST(IFILE).CURR_NTRY.SYSLIB1     ^=  ' ')      /*SYSLIB1*/
           & (SMPLIST(IFILE).CURR_NTRY.SYSLIB2     ^=  ' '))     /*SYSLIB2*/
          PUT FILE(SMPDCTRY.FILEREF)
              EDIT('SLIB1=',SMPLIST(IFILE).CURR_NTRY.SYSLIB1)  (COL(026),A,A);
 
        OTHERWISE;
      END;
   END SMPDCTRY_ENTRY_FILE_STYPE_INFO;
 %PAGE;
 SMPDCTRY_ENTRY_FILE_WRT_INFO:
   PROC;                       /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_WRT_INFO */
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT(SUBSTR(SMPSCAN(IFILE).DDNAME,004),'PG=')                  (X(2),A,X(1),A);
      IF (SMPSCAN(IFILE).ACTIVE  & SMPSCAN(IFILE).OPEN)
        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSCAN(IFILE).CURR_NTRY.PAGE_NO) (P'Z9999');
        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                                 (A);
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT(SUBSTR(SMPSOUT(IFILE).DDNAME,004),'PG=')                  (X(2),A,X(1),A);
      IF (SMPSOUT(IFILE).ACTIVE  & SMPSOUT(IFILE).OPEN)
        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSOUT(IFILE).CURR_NTRY.PAGE_NO) (P'Z9999');
        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                                 (A);
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT(SUBSTR(SMPDATA(IFILE).DDNAME,004),'SQ=')                  (X(2),A,X(1),A);
      IF (SMPDATA(IFILE).ACTIVE  & SMPDATA(IFILE).OPEN)
        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPDATA(IFILE).CURR_NTRY.SEQ_NO)
                                                                           (P'99999999');
        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('--------')                             (A);
 
   END SMPDCTRY_ENTRY_FILE_WRT_INFO;
  %SKIP(3);
   END SMPDCTRY_ENTRY_FILE_INFO;
  %SKIP(3);
   END SMPDCTRY_ENTRY_INFO;
 %PAGE;
 SMPDCTRY_FINAL_INFO:
   PROC;
 
            /*-------------------------------------------------------------------------*/
            /* ASSEMBLE TITLE2/3 LINES AND SET UP END-OF-PAGE CONTROL:                 */
            /*-------------------------------------------------------------------------*/
 
      SMPDCTRY.CURR_PAGE.NTRYINDX     =  NTRYINDX_MAX + 1;
      SMPDCTRY.CURR_PAGE.TITLE2_DATA  = 'FINAL PROCESSING TOTALS:';
      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  '  FILE  ';
      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,035)
                                      =  'FINAL TOTALS BY FILE AND ENTRY TYPE:';
 
      ON ENDPAGE(SMPDCTRY.FILEREF)        CALL SMPDCTRY_NEWPAGE;
      SIGNAL ENDPAGE(SMPDCTRY.FILEREF);              /*START FINAL TOTALS ON A NEW PAGE*/
 
            /*-------------------------------------------------------------------------*/
            /* PRINT FINAL TOTALS AND OTHER INFORMATION FOR SUPPORTED, ACTIVE FILES:   */
            /*-------------------------------------------------------------------------*/
 
      DO        IFILE = IFILE_MIN TO IFILE_MAX;               /*FOR EACH SUPPORTED FILE*/
        IF     (SMPLIST(IFILE).ACTIVE)      /*PRODUCE TOTALS FOR EACH ACTIVE INPUT FILE*/
          THEN  CALL  SMPDCTRY_FINAL_FILE_F_T_INFO;
      END;
 
      RETURN;                    /*TO THE CALLER OF SMPDCTRY_FINAL_INFO*/
 %PAGE;
 SMPDCTRY_FINAL_FILE_F_T_INFO:   /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_FINAL_INFO  */
   PROC;                         /*IFILE IS SET ON ENTRY TO SMPDCTRY_FINAL_FILE_INFO   */
 
      DCL  FILE_LIST_LINE_CT       FIXED BINARY(15,0);
 
            /*-------------------------------------------------------------------------*/
            /* BEGIN A NEW PAGE FOR THIS FILE'S TOTALS IF NECESSARY:                   */
            /*-------------------------------------------------------------------------*/
        FILE_LIST_LINE_CT =        01                      /*FIRST FILE LINE*/
                              +    01                      /*SPILL FILE LINE*/
                              +    SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT
                              + 3*(SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND+01);
 
        IF         (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ -(FILE_LIST_LINE_CT+02)))
            THEN                                 /*IF LISTING WILL FIT ON CURRENT PAGE*/
                IF (LINENO(SMPDCTRY.FILEREF) >  SMPDCTRY.CURR_PAGE.INFO_1STLINE)
                 THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);   /*CONTINUE ON CURRENT PAGE*/
                 ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);   /*CONTINUE ON CURRENT PAGE*/
            ELSE                                 /*IF LISTING WON'T FIT ON CURRENT PAGE*/
                IF (LINENO(SMPDCTRY.FILEREF) >  SMPDCTRY.CURR_PAGE.INFO_1STLINE)
                 THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);      /*START ON A NEW PAGE     */
                 ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);   /*CONTINUE ON CURRENT PAGE*/
     %PAGE;
            /*-------------------------------------------------------------------------*/
            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */
            /*-------------------------------------------------------------------------*/
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('FILE(',IFILE,'):')                                 (COL(001),A,P'999',A);
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('LIST  DDNAME=',SMPLIST(IFILE).DDNAME)                     (COL(012),A,A)
              ('HIGHEST PAGE=',SMPLIST(IFILE).CURR_PAGE.PAGE_NO)
                                                              (COL(035),A,X(3),P'Z9999')
              ('TOTAL LINES READ=',SMPLIST(IFILE).FILE_TOTALS.RCRD_CT)
                                                         (COL(058),A,X(2),P'ZZ,ZZZ,ZZ9')
              ('ENTRY LINES READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT)
                                                              (COL(103),A,P'ZZ,ZZZ,ZZ9');
 
      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
          EDIT('SPILL DDNAME=',SMPUT(IFILE).DDNAME)                       (COL(012),A,A)
              ('WRITE:')                                                    (COL(035),A)
              ('SAVECT=',SMPUT(IFILE).WRITE.SAVE_CT)                  (X(2),A,P'ZZ,ZZ9')
              ('OPENCT=',SMPUT(IFILE).WRITE.OPEN_CT)                  (X(2),A,P'ZZ,ZZ9')
              ('LINECT=',SMPUT(IFILE).WRITE.LINE_CT)                 (X(2),A,P'ZZZ,ZZ9')
              ('READ:')                                                     (COL(094),A)
              ('OPENCT=',SMPUT(IFILE).READ.OPEN_CT)                   (X(2),A,P'ZZ,ZZ9')
              ('LINECT=',SMPUT(IFILE).READ.LINE_CT)                  (X(2),A,P'ZZZ,ZZ9');
 
      IF  (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))          /*IF FILE COULD HAVE HAD OUTPUT*/
        THEN   CALL SMPDCTRY_FINAL_FILE_F_W_INFO;
 
 
      DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX+1;
        IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT >  0)
            | (NTRYINDX_IX  =  NTRYINDX_MAX+1)
          THEN CALL SMPDCTRY_FINAL_FILE_E_T_INFO;
      END;
 
      RETURN;                    /*TO THE CALLER OF SMPDCTRY_FINAL_FILE_F_T_INFO*/
 %PAGE;
 SMPDCTRY_FINAL_FILE_F_W_INFO:          /*THIS SUBROUTINE IS INTERNAL TO                 */
                                        /*SMPDCTRY_FINAL_FILE_F_W_INFO.                  */
   PROC;                                /*IFILE IS SET ON ENTRY.                         */
 
      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
          EDIT('SCAN  DDNAME=',SMPSCAN(IFILE).DDNAME)                     (COL(012),A,A)
              ('HIGHEST PAGE=')                                             (COL(035),A);
      IF (SMPSCAN(IFILE).ACTIVE  & SMPSCAN(IFILE).OPEN)
        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSCAN(IFILE).CURR_PAGE.PAGE_NO)
                                                                          (X(3),P'Z9999');
        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                            (X(3),A);
 
      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
          EDIT('SOUT  DDNAME=',SMPSOUT(IFILE).DDNAME)                     (COL(012),A,A)
              ('HIGHEST PAGE=')                                             (COL(035),A);
      IF (SMPSOUT(IFILE).ACTIVE  & SMPSOUT(IFILE).OPEN)
        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSOUT(IFILE).CURR_PAGE.PAGE_NO)
                                                                          (X(3),P'Z9999');
        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                            (X(3),A);
 
      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
          EDIT('DATA  DDNAME=',SMPSCAN(IFILE).DDNAME)                     (COL(012),A,A)
              ('HIGHEST SEQ#=')                                             (COL(035),A);
      IF (SMPDATA(IFILE).ACTIVE  & SMPDATA(IFILE).OPEN)
        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPDATA(IFILE).CURR_CARD.SEQ_NO)  (P'(8)9');
        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('--------')                             (A);
 
   END SMPDCTRY_FINAL_FILE_F_W_INFO;
 %PAGE;
 SMPDCTRY_FINAL_FILE_E_T_INFO:          /*THIS SUBROUTINE IS INTERNAL TO                 */
                                        /*SMPDCTRY_FINAL_FILE_F_T_INFO.                  */
   PROC;                                /*IFILE AND NTRYINDX_IX ARE SET ON ENTRY.        */
 
      SELECT;                   /*SELECT LINE HEADING FOR ENTRY_INDEX*/
         WHEN(NTRYINDX_IX <= NTRYINDX_MAX)
             PUT FILE(SMPDCTRY.FILEREF)               SKIP(1)
                 EDIT(ENTRY_TYPE(NTRYINDX_IX),'ENTRIES:')            (COL(012),A,X(1),A);
         WHEN(NTRYINDX_IX  = NTRYINDX_MAX+1)
             PUT FILE(SMPDCTRY.FILEREF)               SKIP(1)
                 EDIT('ALL ENTRY TYPES:')                                   (COL(012),A);
         OTHERWISE;
      END;
 
      PUT FILE(SMPDCTRY.FILEREF)
          EDIT('INPUT TOTALS:')                                            (COL(035),A)
              ('FIRST PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGELO)
                                                             (COL(058),A,X(2),P'Z9999')
              ('LAST PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGEHI)
                                                             (COL(081),A,X(2),P'Z9999')
              ('ENTRY LINES READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT)
                                                             (COL(103),A,P'ZZ,ZZZ,ZZ9');
 
      PUT FILE(SMPDCTRY.FILEREF)                       SKIP(1)
          EDIT('ENTRY TOTALS:')                                             (COL(035),A)
              ('READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT)
                                                                 (COL(058),A,P'ZZZ,ZZ9')
              ('SELECTED=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).SELECT_CT)
                                                                 (COL(075),A,P'ZZZ,ZZ9')
              ('MATCHED=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT)
                                                                 (COL(096),A,P'ZZZ,ZZ9')
              ('WRITTEN=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).WRITE_CT)
                                                                 (COL(115),A,P'ZZZ,ZZ9');
      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
          EDIT('LARGEST ENTRY:')                                            (COL(035),A)
              ('NAME=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXNAME)  (COL(058),A,A)
              ('LINECT=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE)
                                                                 (COL(077),A,P'ZZZ,ZZ9')
              ('PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXPAGE)
                                                              (COL(099),A,X(2),P'Z9999');
   END SMPDCTRY_FINAL_FILE_E_T_INFO;
  %SKIP(1);
   END SMPDCTRY_FINAL_FILE_F_T_INFO;
  %SKIP(2);
   END SMPDCTRY_FINAL_INFO;
 %PAGE;
 CONTROL_VALUE_INPUT:
   PROC;
    /******************************************************************/
    /*   ALLOCATE EXECUTION CONTROL VARIABLE STRUCTURES               */
    /******************************************************************/
      ALLOCATE   FILE_ACTIVE_OPTION;
      ALLOCATE   MATCH_ARRAY;
      ALLOCATE   SCAN_ARRAY;
      ALLOCATE   DATA_OUTPUT_OPTION;
    /******************************************************************/
    /*   INITIALIZE EXECUTION CONTROL VARIABLE VALUES                 */
    /******************************************************************/
      DO IFILE = IFILE_MIN TO IFILE_MAX;
              FILE_ACTIVE_OPTION(IFILE)              = '';
              DATA_OUTPUT_OPTION(IFILE)              = '';
              SCAN_ARRAY.FILE(IFILE).SELECT_OPTION   = '';
 
        DO IPLANE = IPLANE_MIN TO IPLANE_MAX;
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION   = '';
 
          DO IROW = IROW_MIN TO IROW_MAX;
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION   = '';
 
            DO ICOL = ICOL_MIN TO ICOL_MAX;
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).BEG_POS  =
                                                                  LIST_LINE_DBGN - 001;
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).END_POS  =
                                                                  LIST_LINE_DEND + 001;
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).POS_LEN  =  000;
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).OP       = '';
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).OP_OIX   =  000;
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STRING   = '';
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STR_LEN  =  000;
              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STR_NIX  =
                                                                        NTRYINDX_MIN-1;
            END;           /*END OF ICOL   DO GROUP*/
 
          END;             /*END OF IROW   DO GROUP*/
        END;               /*END OF IPLANE DO GROUP*/
      END;                 /*END OF IFILE  DO GROUP*/
 
      DO IMATCH = IMATCH_MIN TO IMATCH_MAX;
              MATCH_ARRAY.ENTRY(IMATCH).TYPE         = '';
              MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST = '';
        DO IFILE = IFILE_MIN TO IFILE_MAX;
              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = '';
              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = '';
              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION   = '';
              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = '';
        END;               /*END OF IFILE  DO GROUP*/
      END;                 /*END OF IMATCH DO GROUP*/
   %PAGE;
    /******************************************************************/
    /*   READ EXECUTION CONTROL VARIABLE VALUES                       */
    /******************************************************************/
      OPEN  FILE(SYSIN);                                  /*READ THE SEARCH ARGUMENTS */
      SYSIN_EOF = '0'B;
      ON ENDFILE(SYSIN)
         BEGIN;
              SYSIN_EOF = '1'B;     /*SIGNAL END OF FILE ON INPUT*/
              SYSIN_CONTROL_CARD = REPEAT(SEMI_C,079);
         END;
 
         /*READ THE EXECUTION CONTROL VARIABLES FROM "SYSIN"*/
      READ FILE(SYSIN) INTO(SYSIN_CONTROL_CARD);      /*READ THE FIRST CONTOL CARD IMAGE*/
      DO WHILE(^(SYSIN_EOF));
         IF SUBSTR(SYSIN_CONTROL_CARD,001,001) ^= '*'  /*COMMENT RECORD  */
           THEN
                GET STRING(SUBSTR(SYSIN_CONTROL_CARD,001,072) || SEMI_C)
                    DATA(
                         FILE_ACTIVE_OPTION,
 
                         MATCH_ARRAY,
 
                         SCAN_ARRAY.FILE.SELECT_OPTION,
                         SCAN_ARRAY.FILE.PLANE.SELECT_OPTION,
                         SCAN_ARRAY.FILE.PLANE.ROW.SELECT_OPTION,
                         SCAN_ARRAY.FILE.PLANE.ROW.COL.BEG_POS,
                         SCAN_ARRAY.FILE.PLANE.ROW.COL.END_POS,
                         SCAN_ARRAY.FILE.PLANE.ROW.COL.POS_LEN,
                         SCAN_ARRAY.FILE.PLANE.ROW.COL.OP,
                         SCAN_ARRAY.FILE.PLANE.ROW.COL.STRING,
 
                         DATA_OUTPUT_OPTION
                        );
         READ FILE(SYSIN) INTO(SYSIN_CONTROL_CARD);   /*READ THE NEXT CONTROL CARD IMAGE*/
      END;
      CLOSE FILE(SYSIN);
   %SKIP(2);
    /******************************************************************/
    /*   VALIDATE EXECUTION CONTROL VARIABLE VALUES                   */
    /******************************************************************/
      DO IFILE = IFILE_MIN TO IFILE_MAX;
        FILE_ACTIVE_OPTION(IFILE)
               = VALIDATE_FILE_ACTIVE_OPTION(FILE_ACTIVE_OPTION(IFILE));
        DATA_OUTPUT_OPTION(IFILE) = VALIDATE_DATA_OUTPUT_OPTION(DATA_OUTPUT_OPTION(IFILE));
        CALL VALIDATE_SCAN_ARRAY;
      END;
      CALL VALIDATE_MATCH_ARRAY;
      RETURN;          /*TO THE CALLER OF CONTROL_VALUE_INPUT*/
 %PAGE;
  VALIDATE_MATCH_ARRAY:
  /**************************************************/
  /*VALIDATE THE MATCH_ARRAY INPUT VALUES           */
  /**************************************************/
  PROC;
 
     DO IMATCH = IMATCH_MIN TO IMATCH_MAX;
 
       MATCH_ARRAY.ENTRY(IMATCH).TYPE
               = VALIDATE_MATCH_TYPE_OPTION(MATCH_ARRAY.ENTRY(IMATCH).TYPE);
 
       MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST
               = VALIDATE_MATCH_TEST_OPTION(MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST);
 
       DO IFILE = IFILE_MIN TO IFILE_MAX;
         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION
                = VALIDATE_MATCH_COMPARE_OPTION
                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION);
         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT
                = VALIDATE_MATCH_SELECT_OPTION
                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT);
         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION
                = VALIDATE_MATCH_WRITE_OPTION
                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION);
         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT
                = VALIDATE_MATCH_SELECT_OPTION
                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT);
       END;             /*END OF IFILE  DO GROUP*/
 
     END;               /*END OF IMATCH DO GROUP*/
  END   VALIDATE_MATCH_ARRAY;
 %PAGE;
  VALIDATE_SCAN_ARRAY:           /**************************************************/
                                 /*VALIDATE THE SCAN_ARRAY INPUT VALUES            */
                                 /**************************************************/
  PROC;                              /*IFILE IS SET ON ENTRY TO VALIDATE_SCAN_ARRAY*/
 
     DCL 01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)
                                     LIKE SCAN_ARRAY.PLANE.ROW.COL;
 
     SCAN_ARRAY.FILE(IFILE).SELECT_OPTION
               = VALIDATE_SCAN_SELECT_OPTION
                         (SCAN_ARRAY.FILE(IFILE).SELECT_OPTION);
 
     DO IPLANE = IPLANE_MIN TO IPLANE_MAX;
       SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION
               = VALIDATE_SCAN_SELECT_OPTION
                         (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION);
 
       DO IROW = IROW_MIN TO IROW_MAX;
         SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION
               = VALIDATE_SCAN_SELECT_OPTION
                         (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION);
 
         DO ICOL = ICOL_MIN TO ICOL_MAX;
           SCAN_ARRAY_ELEMENT_ADDR
                 =  ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));
           IF  LENGTH(SCAN_ARRAY_ELEMENT.STRING) <= 0
             THEN   CALL RESET_ARRAY_ELEMENT;  /*RESET ELEMENT IF NO STRING*/
             ELSE DO;               /*A STRING VALUE HAS BEEN SPECIFIED*/
                    CALL VALIDATE_POSITION_BOUNDS;
                    CALL SET_OP_POSITION_BOUNDS;
                    CALL RESET_STRING_SIZE;
                  END;     /*END OF ICOL ACTIVE ELEMENT DO GROUP*/
         END;              /*END OF ICOL   DO GROUP*/
 
       END;                /*END OF IROW   DO GROUP*/
     END;                  /*END OF IPLANE DO GROUP*/
  RETURN;           /*TO THE CALLER OF VALIDATE_SCAN_ARRAY*/
 %PAGE;
  VALIDATE_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
                            /*TO INITIALIZE ANY UNSUPPLIED FIELDS,                */
                            /*VALIDATE THE BEGINNING AND ENDING COLUMN            */
                            /*SPECIFICATIONS, AND FORCE THE BEGIN COLUMN VALUE    */
                            /*TO BE <= THE ENDING COLUMN VALUE:                   */
    PROC;
       DCL  SAVE_POS                   FIXED BIN(15,0);
       SCAN_ARRAY_ELEMENT.STR_LEN
                   =  LENGTH(SCAN_ARRAY_ELEMENT.STRING);
 
       IF     SCAN_ARRAY_ELEMENT.BEG_POS
           >  SCAN_ARRAY_ELEMENT.END_POS
         THEN CALL SWAP_POSITION_BOUNDS;
 
       IF    (SCAN_ARRAY_ELEMENT.POS_LEN > 000)                             /*IF SUPPLIED*/
           & (SCAN_ARRAY_ELEMENT.BEG_POS >= LIST_LINE_DBGN)                 /*IF SUPPLIED*/
           & (SCAN_ARRAY_ELEMENT.BEG_POS <= LIST_LINE_DEND)                  /*AND VALID */
           & (SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND)               /*IF NOTSUPPLIED*/
         THEN SCAN_ARRAY_ELEMENT.END_POS
                         =    SCAN_ARRAY_ELEMENT.BEG_POS
                            + SCAN_ARRAY_ELEMENT.POS_LEN - 1;
 
       IF     SCAN_ARRAY_ELEMENT.BEG_POS
           >  SCAN_ARRAY_ELEMENT.END_POS
         THEN CALL SWAP_POSITION_BOUNDS;
 
       RETURN;
      %SKIP(3);
       SWAP_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_POSITION_BOUNDS"   */
                             /*TO SWAP THE BEGINNING AND ENDING COLUMN             */
         PROC;               /*SPECIFICATIONS:                                     */
            DCL  SAVE_POS                   FIXED BIN(15,0);
            SAVE_POS                    =  SCAN_ARRAY_ELEMENT.BEG_POS;
            SCAN_ARRAY_ELEMENT.BEG_POS  =  SCAN_ARRAY_ELEMENT.END_POS;
            SCAN_ARRAY_ELEMENT.END_POS  =  SAVE_POS;
         END SWAP_POSITION_BOUNDS;
    END VALIDATE_POSITION_BOUNDS;
 %PAGE;
  SET_OP_POSITION_BOUNDS:   /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
                            /*TO VALIDATE AND SET THE ENDING POSITION             */
                            /*IN SCAN_ARRAY BASED ON THE TYPE OF SCAN OPERATION:  */
    PROC;
       SCAN_ARRAY_ELEMENT.OP = TRIM(SCAN_ARRAY_ELEMENT.OP);
       SELECT(SCAN_ARRAY_ELEMENT.OP);
         WHEN('EQENTRY','EQNTRY','EQN')              CALL SET_NTRY_POSITION_BOUNDS(12);
         WHEN('NEENTRY','NENTRY','NEN')              CALL SET_NTRY_POSITION_BOUNDS(13);
         WHEN('^EQENTRY','^EQNTRY','^EQN')           CALL SET_NTRY_POSITION_BOUNDS(13);
 
         WHEN('EQLINE','EQLIN','EQL')                CALL SET_LINE_POSITION_BOUNDS(22);
         WHEN('NELINE','NELIN','NEL')                CALL SET_LINE_POSITION_BOUNDS(23);
         WHEN('^EQLINE','^EQLIN','^EQL')             CALL SET_LINE_POSITION_BOUNDS(23);
 
         WHEN('EQGLINE','EQGLIN','EQGL')             CALL SET_GLIN_POSITION_BOUNDS(32);
         WHEN('NEGLINE','NEGLIN','NEGL')             CALL SET_GLIN_POSITION_BOUNDS(33);
         WHEN('^EQGLINE','^EQGLIN','^EQGL')          CALL SET_GLIN_POSITION_BOUNDS(33);
 
         WHEN('EQSCAN','EQSCN','EQS')                CALL SET_SCAN_POSITION_BOUNDS(42);
         WHEN('NESCAN','NESCN','NES')                CALL SET_SCAN_POSITION_BOUNDS(43);
         WHEN('^EQSCAN','^EQSCN','^EQS')             CALL SET_SCAN_POSITION_BOUNDS(43);
 
         WHEN('EQGSCAN','EQGSCN','EQGS')             CALL SET_GSCN_POSITION_BOUNDS(52);
         WHEN('NEGSCAN','NEGSCN','NEGS')             CALL SET_GSCN_POSITION_BOUNDS(53);
         WHEN('^EQGSCAN','^EQGSCN','^EQGS')          CALL SET_GSCN_POSITION_BOUNDS(53);
 
         WHEN('LTCMPR','LTCPR','LTC','LT')           CALL SET_CMPR_POSITION_BOUNDS(60);
         WHEN('^GECMPR','^GECPR','^GEC','^GE')       CALL SET_CMPR_POSITION_BOUNDS(60);
         WHEN('LECMPR','LECPR','LEC','LE')           CALL SET_CMPR_POSITION_BOUNDS(61);
         WHEN('^GTCMPR','^GTCPR','^GTC','^GT')       CALL SET_CMPR_POSITION_BOUNDS(61);
         WHEN('EQCMPR','EQCPR','EQC','EQ')           CALL SET_CMPR_POSITION_BOUNDS(62);
         WHEN('NECMPR','NECPR','NEC','NE')           CALL SET_CMPR_POSITION_BOUNDS(63);
         WHEN('^EQCMPR','^EQCPR','^EQC','^EQ')       CALL SET_CMPR_POSITION_BOUNDS(63);
         WHEN('GECMPR','GECPR','GEC','GE')           CALL SET_CMPR_POSITION_BOUNDS(64);
         WHEN('^LTCMPR','^LTCPR','^LTC','^LT')       CALL SET_CMPR_POSITION_BOUNDS(64);
         WHEN('GTCMPR','GTCPR','GTC','GT')           CALL SET_CMPR_POSITION_BOUNDS(65);
         WHEN('^LECMPR','^LTCPR','^LTC','^LT')       CALL SET_CMPR_POSITION_BOUNDS(65);
 
         WHEN('EQGCMPR','EQGCPR','EQGC','EQG')       CALL SET_GCPR_POSITION_BOUNDS(72);
         WHEN('NEGCMPR','NEGCPR','NEGC','NEG')       CALL SET_GCPR_POSITION_BOUNDS(73);
         WHEN('^EQGCMPR','^EQGCPR','^EQGC','^EQG')   CALL SET_GCPR_POSITION_BOUNDS(73);
 
         OTHERWISE
           DO;
               SCAN_ARRAY_ELEMENT.OP = 'EQSCAN';
               CALL                              SET_SCAN_POSITION_BOUNDS(42);
           END;
       END;   /*END OF SCAN_ARRAY.OP   SELECT GROUP*/
 
       RETURN;
 %PAGE;
  SET_NTRY_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
                            /*TO VALIDATE AND SET THE ENDING POSITION             */
                            /*IN SCAN_ARRAY FOR ENTRY TYPE COMPARE OPERATIONS:    */
    PROC(OIX);
       DCL  OIX                       FIXED BIN(15,0);
       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;
       SCAN_ARRAY_ELEMENT.BEG_POS  =  LIST_LINE_DBGN;
       SCAN_ARRAY_ELEMENT.END_POS  =  LIST_LINE_DEND;
       SCAN_ARRAY_ELEMENT.STR_NIX  =  ENTRY_INDEX(SCAN_ARRAY_ELEMENT.STRING);
    END SET_NTRY_POSITION_BOUNDS;
 %SKIP(3);
  SET_LINE_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
  SET_GLIN_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING POSITION             */
                            /*IN SCAN_ARRAY FOR LINE TYPE COMPARE OPERATIONS:     */
    PROC(OIX);
       DCL  OIX                       FIXED BIN(15,0);
       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;
       SCAN_ARRAY_ELEMENT.BEG_POS  =  LIST_LINE_LBGN;
       SCAN_ARRAY_ELEMENT.END_POS  =  LIST_LINE_LEND;
    END SET_LINE_POSITION_BOUNDS;
 %PAGE;
  SET_SCAN_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
  SET_GSCN_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING COLUMN               */
                            /*IN SCAN_ARRAY FOR LINE CONTENTS SCAN OPERATIONS:    */
    PROC(OIX);
       DCL  OIX                       FIXED BIN(15,0);
       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;
       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN
           &  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND
         THEN
           DO;
              SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_SBGN;
              SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;
           END;
       SCAN_ARRAY_ELEMENT.END_POS
           = MIN(LIST_LINE_DEND,
                 MAX( SCAN_ARRAY_ELEMENT.END_POS,
                     (SCAN_ARRAY_ELEMENT.BEG_POS +
                      SCAN_ARRAY_ELEMENT.STR_LEN - 1)));
    END SET_SCAN_POSITION_BOUNDS;
 %SKIP(3);
  SET_CMPR_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
  SET_GCPR_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING POSITION             */
                            /*IN SCAN_ARRAY FOR LINE CONTENTS COMPARE OPERATIONS: */
    PROC(OIX);
       DCL  OIX                       FIXED BIN(15,0);
       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;
       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN
           &  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND
         THEN
           DO;
              SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_SBGN;
              SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;
           END;
       SCAN_ARRAY_ELEMENT.END_POS
         = MIN(LIST_LINE_DEND,
               (SCAN_ARRAY_ELEMENT.BEG_POS +
                SCAN_ARRAY_ELEMENT.STR_LEN - 1));
    END SET_CMPR_POSITION_BOUNDS;
   %SKIP(2);
    END SET_OP_POSITION_BOUNDS;
 %PAGE;
  RESET_STRING_SIZE:        /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
                      /*TO LIMIT THE SIZE OF THE SEARCH STRING TO                 */
                      /*THE EXTENT OF THE  BEGIN AND END LINE POSTITIONS:         */
    PROC;
       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN
           |  SCAN_ARRAY_ELEMENT.BEG_POS > LIST_LINE_DEND
         THEN SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_DBGN;
 
       IF     SCAN_ARRAY_ELEMENT.END_POS < LIST_LINE_DBGN
           |  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND
         THEN SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;
 
       SCAN_ARRAY_ELEMENT.POS_LEN        =    SCAN_ARRAY_ELEMENT.END_POS
                                            - SCAN_ARRAY_ELEMENT.BEG_POS + 1;
 
       IF         SCAN_ARRAY_ELEMENT.POS_LEN
               <  SCAN_ARRAY_ELEMENT.STR_LEN
 
         THEN     SCAN_ARRAY_ELEMENT.STRING
               =
           SUBSTR(SCAN_ARRAY_ELEMENT.STRING,
                  1,
                  SCAN_ARRAY_ELEMENT.POS_LEN);
 
       SCAN_ARRAY_ELEMENT.STR_LEN        =  LENGTH(SCAN_ARRAY_ELEMENT.STRING);
 
    END RESET_STRING_SIZE;
 %SKIP(3);
  RESET_ARRAY_ELEMENT:      /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
                            /*TO RESET THE VALUES IN A SCAN_ARRAY ELEMENT         */
                            /*WHEN THE STRING PROVIDED IS EMPTY OR NULL:          */
    PROC;
       SCAN_ARRAY_ELEMENT.BEG_POS  =  000;
       SCAN_ARRAY_ELEMENT.END_POS  =  000;
       SCAN_ARRAY_ELEMENT.POS_LEN  =  000;
       SCAN_ARRAY_ELEMENT.OP       =  '';
       SCAN_ARRAY_ELEMENT.OP_OIX   =  000;
       SCAN_ARRAY_ELEMENT.STRING   =  '';
       SCAN_ARRAY_ELEMENT.STR_LEN  =  000;
       SCAN_ARRAY_ELEMENT.STR_NIX  =  NTRYINDX_MIN-1;
    END RESET_ARRAY_ELEMENT;
 %SKIP(3);
  END VALIDATE_SCAN_ARRAY;
 %PAGE;
  VALIDATE_MATCH_TYPE_OPTION:
  PROC(ENT_TYP)                   RETURNS(CHAR(016) VARYING);
     DCL    ENT_TYP               CHAR(*) VARYING;
     SELECT(TRIM(ENT_TYP));     /*EVALUATE OPTION AND STANDARDIZE IT*/
        WHEN('')                                      RETURN('NONE');
        WHEN('ALL','A')                               RETURN('ALL');
        WHEN('NONE','NO','N')                         RETURN('NONE');
        OTHERWISE           RETURN(ENTRY_TYPE(ENTRY_INDEX(ENT_TYP)));
     END;
  END VALIDATE_MATCH_TYPE_OPTION; /*IN CONTROL_VALUE_INPUT*/
 %SKIP(2);
  VALIDATE_MATCH_TEST_OPTION:
  PROC(TST_TYP)                   RETURNS(CHAR(008) VARYING);
     DCL    TST_TYP               CHAR(*) VARYING;
     SELECT(TRIM(TST_TYP));     /*EVALUATE OPTION AND STANDARDIZE IT*/
        WHEN('')                                      RETURN('ALL');
        WHEN('ALL','AND','A','N')                     RETURN('ALL');
        WHEN('ANY','OR','O')                          RETURN('ANY');
        OTHERWISE                                     RETURN('ALL');
     END;
  END VALIDATE_MATCH_TEST_OPTION; /*IN CONTROL_VALUE_INPUT*/
 %PAGE;
  VALIDATE_MATCH_COMPARE_OPTION:
  PROC(CPR_OPT)                   RETURNS(CHAR(012) VARYING);
     DCL    CPR_OPT               CHAR(*) VARYING;
     SELECT(TRIM(CPR_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
        WHEN('')                                      RETURN('IFCOMPARE');
        WHEN('NOCOMPARE','NOCMPR','NOCPR','NOC')      RETURN('NOCOMPARE');
        WHEN('COMPARE','CMPR','CPR','C')              RETURN('COMPARE');
        WHEN('IFCOMPARE','IFCMPR','IFCPR','IFC')      RETURN('IFCOMPARE');
        WHEN('IGCOMPARE','IGCMPR','IGCPR','IGC')      RETURN('IFCOMPARE');
        WHEN('IGNORE','IGNR','IG')                    RETURN('IFCOMPARE');
        OTHERWISE                                     RETURN('IFCOMPARE');
     END;
  END VALIDATE_MATCH_COMPARE_OPTION; /*IN CONTROL_VALUE_INPUT*/
 %SKIP(2);
  VALIDATE_MATCH_SELECT_OPTION:
  PROC(SEL_OPT)                   RETURNS(CHAR(012) VARYING);
     DCL    SEL_OPT               CHAR(*) VARYING;
     SELECT(TRIM(SEL_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
        WHEN('')                                      RETURN('IGNORE');
        WHEN('NOSELECT','NOSEL','NOS')                RETURN('NOSELECT');
        WHEN('EXCLUDE','EXCL','EXC','EX','E','X')     RETURN('NOSELECT');
        WHEN('SELECT','SEL','S')                      RETURN('SELECT');
        WHEN('IFSELECT','IFSEL','IFS')                RETURN('IGNORE');
        WHEN('IGSELECT','IGSEL','IGS')                RETURN('IGNORE');
        WHEN('IGNORE','IGNR','IG')                    RETURN('IGNORE');
        OTHERWISE                                     RETURN('IGNORE');
     END;
  END VALIDATE_MATCH_SELECT_OPTION; /*IN CONTROL_VALUE_INPUT*/
 %SKIP(2);
  VALIDATE_MATCH_WRITE_OPTION:
  PROC(WRT_OPT)                   RETURNS(CHAR(012) VARYING);
     DCL    WRT_OPT               CHAR(*) VARYING;
     SELECT(TRIM(WRT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
        WHEN('')                                      RETURN('WRITE');
        WHEN('NOWRITE','NOWRT','NOWR','NOW')          RETURN('NOWRITE');
        WHEN('WRITE','WRT','WR','W')                  RETURN('WRITE');
        OTHERWISE                                     RETURN('WRITE');
     END;
  END VALIDATE_MATCH_WRITE_OPTION; /*IN CONTROL_VALUE_INPUT*/
 %PAGE;
  VALIDATE_FILE_ACTIVE_OPTION:
  PROC(ACT_OPT)                   RETURNS(CHAR(008) VARYING);
     DCL    ACT_OPT               CHAR(*) VARYING;
     SELECT(TRIM(ACT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
        WHEN('')                                      RETURN('INACTIVE');
        WHEN('INACTIVE','INACT','NO','N','OFF')       RETURN('INACTIVE');
        WHEN('ACTIVE','ACT','A','YES','Y','ON')       RETURN('ACTIVE');
        OTHERWISE                                     RETURN('INACTIVE');
     END;
  END VALIDATE_FILE_ACTIVE_OPTION; /*IN CONTROL_VALUE_INPUT*/
 %SKIP(2);
  VALIDATE_SCAN_SELECT_OPTION:
  PROC(SEL_OPT)                   RETURNS(CHAR(008) VARYING);
     DCL    SEL_OPT               CHAR(*) VARYING;
     SELECT(TRIM(SEL_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
        WHEN('')                                      RETURN('SELECT');
        WHEN('EXCLUDE','EXCL','EXC','EX','E','X')     RETURN('EXCLUDE');
        WHEN('SELECT','SEL','S')                      RETURN('SELECT');
        OTHERWISE                                     RETURN('SELECT');
     END;
  END VALIDATE_SCAN_SELECT_OPTION; /*IN CONTROL_VALUE_INPUT*/
 %SKIP(2);
  VALIDATE_DATA_OUTPUT_OPTION:
  PROC(OUT_OPT)                   RETURNS(CHAR(008) VARYING);
     DCL    OUT_OPT               CHAR(*) VARYING;
     SELECT(TRIM(OUT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
        WHEN('')                                      RETURN('NONE');
        WHEN('NONE')                                  RETURN('NONE');
        WHEN('ALL')                                   RETURN('ALL');
        WHEN('ID')                                    RETURN('ID');
        WHEN('ID1')                                   RETURN('ID1');
        WHEN('SELECT','SEL','S')                      RETURN('SELECT');
        OTHERWISE                                     RETURN('ID1');
     END;
  END VALIDATE_DATA_OUTPUT_OPTION; /*IN CONTROL_VALUE_INPUT*/
 %SKIP(3);
  END CONTROL_VALUE_INPUT;
 %PAGE;
 SMPLIST_OPEN:             /*************************************************************/
                           /*                                                           */
                           /*   INITIALIZE THE SMPLIST FILE MANAGEMENT ARRAY,           */
                           /*   AND OPEN THE SMPLIST DATA SET(S).                       */
                           /*                                                           */
  PROC;                    /*************************************************************/
     ALLOCATE     SMPLIST_CNTL,SMPLIST;            /*ALLOCATE INPUT  FILE STRUCTURES*/
     ALLOCATE     SMPUT,SMPSCAN,SMPSOUT,SMPDATA;   /*ALLOCATE OUTPUT FILE STRUCTURES*/
 
     CALL SMPLIST_CNTL_A_STAT_INIT;                /*INITIALIZE A_STAT  SUBSTRUCTURE*/
     CALL SMPLIST_CNTL_E_CMPR_INIT;                /*INITIALIZE E_CMPR  SUBSTRUCTURE*/
     CALL SMPLIST_CNTL_A_MATCH_INIT;               /*INITIALIZE A_MATCH SUBSTRUCTURE*/
 
     DO    IFILE = IFILE_MIN TO IFILE_MAX;
       CALL  SMPLIST_INIT;                   /*INITIALIZE SMPLIST(IFILE) MAJOR STRUCTURE*/
       CALL  SMPUT_INIT;                     /*INITIALIZE SMPUT(IFILE)   MAJOR STRUCTURE*/
       CALL  SMPSCAN_INIT;                   /*INITIALIZE SMPSCAN(IFILE) MAJOR STRUCTURE*/
       CALL  SMPSOUT_INIT;                   /*INITIALIZE SMPSOUT(IFILE) MAJOR STRUCTURE*/
       CALL  SMPDATA_INIT;                   /*INITIALIZE SMPDATA(IFILE) MAJOR STRUCTURE*/
       IF FILE_ACTIVE_OPTION(IFILE) = 'ACTIVE'
         THEN DO;                            /*IF THE FILE IS TO BE PROCESSED*/
                 SMPLIST(IFILE).ACTIVE = '1'B;      /*INDICATE FILE ACTIVE*/
                 CALL SMPLIST_SCAN_CUBE_BUILD;
                 OPEN  FILE(SMPLIST(IFILE).FILEREF) INPUT
                       TITLE(SMPLIST(IFILE).DDNAME);
               END;
         ELSE DO;                            /*IF THE FILE IS NOT TO BE PROCESSED*/
                 CALL      SMPLIST_CURR_PAGE_EOF;   /*SIMULATE IMMEDIATE END-OF-FILE*/
                 SMPLIST(IFILE).CURR_NTRY  =  SMPLIST(IFILE).CURR_PAGE,  BY NAME;
              END;
     END;
 
     CALL  SMPLIST_CNTL_A_MATCH_BUILD;          /*BUILD SMPLIST_CNTL.A_MATCH SUBSTRUCTURE*/
 
     DO    IFILE = IFILE_MIN TO IFILE_MAX;    /*READ FIRST LINES FOR ACTIVE SMPLIST FILES*/
       IF (SMPLIST(IFILE).ACTIVE)                    /*IF FILE IS ACTIVE,                */
         THEN
           DO;
             CALL SMPLIST_ENTRY_LINE_READ;                   /*READ 1ST LINE OF 1ST ENTRY*/
             IF  (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))      /*IF A CANDIDATE FOR OUTPUT,*/
               THEN DO;
                       CALL SMPSCAN_ACTIVATE;                 /*ACTIVATE SCAN OUTPUT FILE*/
                       CALL SMPSOUT_ACTIVATE;                 /*ACTIVATE LIST OUTPUT FILE*/
                       CALL SMPDATA_ACTIVATE;                 /*ACTIVATE DATA OUTPUT FILE*/
                    END;
             SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT = SMPLIST(IFILE).ACTIVE;/*FLAG 1ST READ*/
           END;
     END;
 
     CALL  SMPLIST_CNTL_A_STAT_BUILD;           /*BUILD SMPLIST_CNTL.A_STAT  SUBSTRUCTURE*/
 
     RETURN;                      /*TO THE CALLER OF SMPLIST_OPEN*/
 %PAGE;
  SMPLIST_CNTL_A_STAT_INIT:       /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES VARIABLES IN THE A_STAT          */
                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/
  PROC;                           /**************************************************/
     SMPLIST_CNTL.A_STAT.#_F_ACTIVE = 0;
  END  SMPLIST_CNTL_A_STAT_INIT;
 %SKIP(3);
  SMPLIST_CNTL_A_STAT_BUILD:      /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT CALCULATES VALUES TO BE PLACED IN THE A_STAT */
                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/
  PROC;                           /**************************************************/
     DO    IFILE = IFILE_MIN TO IFILE_MAX;
       IF    SMPLIST(IFILE).ACTIVE                           /*PROCESS ONLY ACTIVE FILES*/
         THEN
           DO;
             SMPLIST_CNTL.A_STAT.#_F_ACTIVE = SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 1;
           END;
     END;
  END  SMPLIST_CNTL_A_STAT_BUILD;
 %SKIP(3);
  SMPLIST_CNTL_E_CMPR_INIT:       /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES VARIABLES IN THE E_CMPR          */
                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/
  PROC;                           /**************************************************/
     SMPLIST_CNTL.HIGH_PAGE.NTRYNAME  =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.NTRYNAME));
     SMPLIST_CNTL.HIGH_PAGE.NTRYINDX  =    NTRYINDX_MAX + 1;
     SMPLIST_CNTL.HIGH_PAGE.PAGEKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.PAGEKEY));
     SMPLIST_CNTL.HIGH_PAGE.NTRYKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.NTRYKEY));
     SMPLIST_CNTL.HIGH_PAGE.CMPRKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.CMPRKEY));
 
     SMPLIST_CNTL.HIGH_CMPR          =     SMPLIST_CNTL.HIGH_PAGE,    BY NAME;
     SMPLIST_CNTL.HIGH_CMPR.RESULT   =     '0'B;
 
     SMPLIST_CNTL.E_CMPR               =   SMPLIST_CNTL.HIGH_CMPR,    BY NAME;
  END  SMPLIST_CNTL_E_CMPR_INIT;
 %PAGE;
  SMPLIST_CNTL_A_MATCH_INIT:      /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES THE A_MATCH SUBSTRUCTURE         */
                                  /*IN THE SMPLIST FILE CONTROL STRUCTURE.          */
  PROC;                           /**************************************************/
          SMPLIST_CNTL.A_MATCH.ACTIVE   =  '0'B;
          SMPLIST_CNTL.A_MATCH.RESULT   =  '0'B;
 
     DO     NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;
          SMPLIST_CNTL.A_MATCH.M_E_TYPE(NTRYINDX_IX) = '0'B;
     END;           /*END OF NTRYINDX_IX DO GROUP*/
 
     DO     IFILE   = IFILE_MIN  TO IFILE_MAX;
          SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)  =  '0'B;
     END;           /*END OF IFILE  DO GROUP*/
 
     DO     IMATCH  = IMATCH_MIN TO IMATCH_MAX;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX  =  NTRYINDX_MIN - 1;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE    =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST     =  '0'B;
       DO   IFILE   = IFILE_MIN  TO IFILE_MAX;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR     =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR   =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR   =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL      =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL    =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL    =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT      =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL      =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL    =  '0'B;
          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL    =  '0'B;
       END;         /*END OF IFILE  DO GROUP*/
     END;           /*END OF IMATCH DO GROUP*/
  END SMPLIST_CNTL_A_MATCH_INIT;
 %PAGE;
  SMPLIST_CNTL_A_MATCH_BUILD:     /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT SETS UP THE A_MATCH SUBSTRUCTURE             */
                                  /*IN THE SMPLIST FILE CONTROL STRUCTURE.          */
  PROC;                           /**************************************************/
     DO     IMATCH  = IMATCH_MIN TO IMATCH_MAX;
       SELECT(MATCH_ARRAY.ENTRY(IMATCH).TYPE);
         WHEN('NONE')  NTRYINDX_IX  =  NTRYINDX_MIN - 1;
         WHEN('ALL')   NTRYINDX_IX  =  NTRYINDX_MAX + 1;
         OTHERWISE     NTRYINDX_IX  =  ENTRY_INDEX(MATCH_ARRAY.ENTRY(IMATCH).TYPE);
       END;
       SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX = NTRYINDX_IX;
 
       IF       (NTRYINDX_IX >= NTRYINDX_MIN)     /*IF A SPECIFIC ENTRY TYPE OR "ALL"*/
         THEN                                          /*IF THE MATCH ENTRY IS ACTIVE*/
           DO;
             IF (NTRYINDX_IX <= NTRYINDX_MAX)
               THEN                                  /*IF THE MATCH ENTRY TYPE IS ONE*/
                     SMPLIST_CNTL.A_MATCH.M_E_TYPE(NTRYINDX_IX) = '1'B;
               ELSE                                /*IF THE MATCH ENTRY TYPE IS "ALL"*/
                     SMPLIST_CNTL.A_MATCH.M_E_TYPE(*)           = '1'B;
 
             SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE  = '1'B;             /*ACTIVE*/
 
             SELECT(MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST);
               WHEN('ANY') SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST  = '0'B;
               OTHERWISE   SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST  = '1'B;
             END;                        /*END OF COMPARE_TEST SELECT GROUP*/
 
             DO      IFILE   = IFILE_MIN  TO IFILE_MAX;
               IF   (SMPLIST(IFILE).ACTIVE)                         /*IF FILE IS ACTIVE*/
                 THEN
                     CALL      SMPLIST_CNTL_A_MATCH_F_BUILD;
             END;                        /*END OF        IFILE  DO GROUP*/
           END;                          /*END OF ACTIVE IMATCH    DO GROUP*/
 
         ELSE
             SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE  = '0'B;            /*INACTIVE*/
 
       SMPLIST_CNTL.A_MATCH.ACTIVE   =     SMPLIST_CNTL.A_MATCH.ACTIVE
                                        |  SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE;
     END;                                /*END OF        IMATCH DO GROUP*/
    %PAGE;
     IF  (SMPLIST_CNTL.A_MATCH.ACTIVE)
       THEN                                        /*IF    MATCH ENTRIES WERE ACTIVE*/
         DO   IFILE   = IFILE_MIN  TO IFILE_MAX;  /*ACTIVE  FILES CAN PRODUCE OUTPUT*/
               SMPLIST(IFILE).M_E_TYPE(*)            =   (SMPLIST(IFILE).ACTIVE
                                                        & SMPLIST_CNTL.A_MATCH.M_E_TYPE(*));
         END;                         /*END OF        IFILE  DO GROUP*/
 
       ELSE                                        /*IF NO MATCH ENTRIES WERE ACTIVE*/
         DO;
            SMPLIST_CNTL.A_MATCH.M_E_TYPE(*) = '1'B; /*CONSIDER ALL ENTRY TYPES ACTIVE */
            DO   IFILE   = IFILE_MIN  TO IFILE_MAX;  /*SCANNED FILES CAN PRODUCE OUTPUT*/
               SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)  =   (SMPLIST(IFILE).ACTIVE
                                                        & SMPLIST(IFILE).SCAN_CUBE.ACTIVE);
               SMPLIST(IFILE).M_E_TYPE(*)            =   (SMPLIST(IFILE).ACTIVE
                                                        & SMPLIST(IFILE).SCAN_CUBE.ACTIVE
                                                        & SMPLIST_CNTL.A_MATCH.M_E_TYPE(*));
            END;                         /*END OF        IFILE  DO GROUP*/
         END;
     RETURN;                             /*TO THE CALLER OF SMPLIST_CNTL_A_MATCH_BUILD*/
 %PAGE;
  SMPLIST_CNTL_A_MATCH_F_BUILD:   /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO                  */
                                  /*SMPLIST_CNTL_A_MATCH_BUILD IN SMPLIST_OPEN.     */
                                  /*IT SETS THE MATCH/SCAN/WRITE BITS FOR A FILE.   */
                                  /**************************************************/
  PROC;                           /*IMATCH & IFILE ARE SET ON ENTRY                 */
 
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = 'COMPARE');
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR
              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = 'NOCOMPARE');
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR
              =    ^ (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR);
 
 
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL
              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)
                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = 'SELECT');
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL
              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)
                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = 'NOSELECT');
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL
              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)
                &  ^ (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL
                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL);
 
 
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT
              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION   = 'WRITE');
 
 
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL
              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)
                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = 'SELECT');
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL
              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)
                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = 'NOSELECT');
     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL
              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)
                &  ^ (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL
                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL);
    %PAGE;
     SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)        /*IF FILE IS A CANDIDATE FOR OUTPUT*/
              =      (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))
 
                |   ((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST)              /*ALL*/
                 & (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR)
                   | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR))
                   & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)))
 
                |  ((^SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST)              /*ANY*/
                 &   (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT));
 
 
  END  SMPLIST_CNTL_A_MATCH_F_BUILD;
 %SKIP(2);
  END  SMPLIST_CNTL_A_MATCH_BUILD;
 %PAGE;
  SMPLIST_INIT:                   /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES VARIABLES IN THE SMPLIST         */
                                  /*MAJOR STRUCTURE.                                */
                                  /**************************************************/
  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPLIST_INIT        */
     SMPLIST(IFILE).FILEREF               =  DTFLIST_LIST(IFILE);   /*FILE REFERENCE*/
     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
       WHEN(1)                          /*IF IN SINGLE DIGITS*/
           PUT STRING(SMPLIST(IFILE).DDNAME) EDIT(DDIPFX,'LIST',IFILE) (A,A,P'9'); /*DDN*/
       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
           PUT STRING(SMPLIST(IFILE).DDNAME) EDIT(DDIPFX,'LST',IFILE) (A,A,P'99'); /*DDN*/
     END;
     SMPLIST(IFILE).ACTIVE                =  '0'B;      /*ASSUME FILE IS NOT ACTIVE */
     SMPLIST(IFILE).EOF                   =  '0'B;      /*ASSUME FILE NOT AT EOF    */
     SMPLIST(IFILE).LINE_SZ               =  LIST_LINE_SIZE; /*INITIALIZE LINE SIZE */
 
     SMPLIST(IFILE).CURR_PAGE.PAGE_BS     =  00000;     /*INITIALIZE PAGE NMBR BASE */
     SMPLIST(IFILE).CURR_PAGE.PAGE_NO     =  0000;      /*INITIALIZE PAGE NUMBER    */
     SMPLIST(IFILE).CURR_PAGE.PAGE_HI     =  0000;      /*INITIALIZE PAGE NUMBER    */
     SMPLIST(IFILE).CURR_PAGE.LINE_NO     =  0000;      /*INITIALIZE LINE NUMBER    */
     SMPLIST(IFILE).CURR_PAGE.FLUSH       =  '0'B;      /*INITIALIZE PAGE FLUSH IND.*/
     SMPLIST(IFILE).CURR_PAGE.LINE_CT     =  0000;      /*INITIALIZE LINE COUNT     */
     SMPLIST(IFILE).CURR_PAGE.WRITE_OUT   = '0'B;       /*INITIALIZE WRITE_OUT  IND.*/
     SMPLIST(IFILE).CURR_PAGE.CMPR_RESULT = '0'B;       /*INITIALIZE CMPR_RESULTIND.*/
     SMPLIST(IFILE).CURR_PAGE.SCAN_RESULT = '0'B;       /*INITIALIZE CMPR_RESULTIND.*/
     SMPLIST(IFILE).CURR_PAGE.ZONENAME    = ' ';        /*INITIALIZE ZONE NAME      */
     SMPLIST(IFILE).CURR_PAGE.ZONEINDX    =  0;         /*INITIALIZE ZONE INDEX     */
     SMPLIST(IFILE).CURR_PAGE.ZONETYPE    = ' ';        /*INITIALIZE ZONE TYPE      */
     SMPLIST(IFILE).CURR_PAGE.ZONETYPE_C  = ' ';        /*INITIALIZE ZONE TYPE CHR  */
     SMPLIST(IFILE).CURR_PAGE.NTRYNAME    = ' ';        /*INITIALIZE ENTRY NAME     */
     SMPLIST(IFILE).CURR_PAGE.NTRYINDX    =  0;         /*INITIALIZE ENTRY INDEX    */
     SMPLIST(IFILE).CURR_PAGE.NTRYTYPE    = ' ';        /*INITIALIZE ENTRY TYPE     */
     SMPLIST(IFILE).CURR_PAGE.FMID        = ' ';        /*INITIALIZE ENTRY FMID     */
     SMPLIST(IFILE).CURR_PAGE.SOURCEID    = ' ';        /*INITIALIZE ENTRY SOURCE ID*/
     SMPLIST(IFILE).CURR_PAGE.SYSLIB1     = ' ';        /*INITIALIZE ENTRY SYSLIB1  */
     SMPLIST(IFILE).CURR_PAGE.SYSLIB2     = ' ';        /*INITIALIZE ENTRY SYSLIB2  */
     SMPLIST(IFILE).CURR_PAGE.PAGEKEY     = ' ';        /*INITIALIZE PAGE KEY FOR NEWPAGE*/
     SMPLIST(IFILE).CURR_PAGE.NTRYKEY     = ' ';        /*INITIALIZE ENTRY KEY FOR CMPR*/
     SMPLIST(IFILE).CURR_PAGE.CMPRKEY     = ' ';        /*INITIALIZE COMPARE KEY    */
     SMPLIST(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */
     SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */
     SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */
 
     STRING(SMPLIST(IFILE).CURR_LINE)     = ' ';        /*INITIALIZE LINE DATA      */
 
     SMPLIST(IFILE).CURR_NTRY             =   SMPLIST(IFILE).CURR_PAGE,   BY NAME;
 
     SMPLIST(IFILE).M_E_TYPE(*)           = '0'B;
 
     CALL  SMPLIST_SCAN_CUBE_INIT;               /*INITIALIZE SCAN_CUBE SUBSTRUCTURE*/
    %PAGE;
     SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE                 = 0; /*INITIALIZE FILE TOTALS*/
     SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT                 = 0; /*INITIALIZE FILE TOTALS*/
     SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND                = 0; /*INITIALIZE FILE TOTALS*/
     SMPLIST(IFILE).FILE_TOTALS.RCRD_CT                    = 0; /*INITIALIZE FILE TOTALS*/
 
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT  = 0; /*INITIALIZE NTRY TOTALS*/
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGELO = 0;
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGEHI = 0;
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT   = 0; /*INITIALIZE NTRY TOTALS*/
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXNAME   = ' ';
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE   = 0; /*INITIALIZE NTRY TOTALS*/
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXPAGE   = 0; /*INITIALIZE NTRY TOTALS*/
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT = 0; /*INITIALIZE NTRY TOTALS*/
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT  = 0; /*INITIALIZE NTRY TOTALS*/
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT  = 0; /*INITIALIZE NTRY TOTALS*/
 
     DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;
       SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX)            =
                                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1), BY NAME;
     END;                  /*END OF NTRYINDX_IX DO GROUP*/
 
  END  SMPLIST_INIT;
 %PAGE;
  SMPLIST_SCAN_CUBE_INIT:         /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES THE SCAN_CUBE SUBSTRUCTURE       */
                                  /*IN THE SMPLIST FILE MANAGEMENT STRUCTURE.       */
                                  /**************************************************/
  PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPLIST_SCAN_CUBE_INIT  */
         SMPLIST(IFILE).SCAN_CUBE.RESULT   = '0'B;
         SMPLIST(IFILE).SCAN_CUBE.SELECT   = '0'B;
         SMPLIST(IFILE).SCAN_CUBE.ACTIVE   = '0'B;
     DO  IPLANE = IPLANE_MIN TO IPLANE_MAX;
         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT   = '0'B;
         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT   = '0'B;
         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE   = '0'B;
       DO  IROW = IROW_MIN   TO IROW_MAX;
         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT   = '0'B;
         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT   = '0'B;
         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE   = '0'B;
       END;                /*END OF IROW DO GROUP*/
     END;                  /*END OF IPLANE DO GROUP*/
 
  END  SMPLIST_SCAN_CUBE_INIT;
 %PAGE;
  SMPLIST_SCAN_CUBE_BUILD:        /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT SETS UP THE SCAN_CUBE SUBSTRUCTURE           */
                                  /*IN THE SMPLIST FILE MANAGEMENT STRUCTURE.       */
                                  /**************************************************/
  PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPLIST_SCAN_CUBE_BUILD */
     DO     IPLANE  = IPLANE_MIN TO IPLANE_MAX;
       DO     IROW  = IROW_MIN   TO IROW_MAX;
         DO   ICOL  = ICOL_MIN   TO ICOL_MAX;
 
           IF SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL) > 0   /*IF STRING SUPPLIED*/
             THEN      /*IF ANY COLUMN IN THE ROW IS ACTIVE, SET THE ROW ACTIVE IND.*/
               DO;
                SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE = '1'B;
                SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =
                               SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;
               END;
 
         END;              /*END OF ICOL DO GROUP*/
 
         IF    (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)
           THEN       /*IF ANY COLUMN IN THE ROW IS ACTIVE, SET THE ROW SELECT OPTION*/
             DO;      /*AND THE PLANE ACTIVE OPTION                                  */
               SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE = '1'B;
               IF SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION = 'SELECT'
                 THEN SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT  = '1'B;
               SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =
                              SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;
             END;
 
       END;                /*END OF IROW DO GROUP*/
 
       IF    (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)
         THEN         /*IF ANY ROW IN THE PLANE IS ACTIVE, SET THE PLANE SELECT OPTION*/
           DO;        /*AND THE CUBE  ACTIVE OPTION                                   */
             SMPLIST(IFILE).SCAN_CUBE.ACTIVE = '1'B;
             IF SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION = 'SELECT'
               THEN SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT  = '1'B;
             SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =
                            SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;
           END;
 
     END;                  /*END OF IPLANE DO GROUP*/
 
     IF    (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)
       THEN           /*IF ANY PLANE IN THE CUBE IS ACTIVE, SET THE CUBE SELECT OPTION*/
         DO;
            IF SCAN_ARRAY.FILE(IFILE).SELECT_OPTION = 'SELECT'
              THEN SMPLIST(IFILE).SCAN_CUBE.SELECT  = '1'B;
            SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =
                           SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;
           END;
 
  END  SMPLIST_SCAN_CUBE_BUILD;
 %PAGE;
  SMPUT_INIT:                     /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES VARIABLES IN THE SMPUT MAJOR     */
                                  /*STRUCTURE.                                      */
                                  /**************************************************/
  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPUT_INIT          */
     SMPUT(IFILE).FILEREF             =  DTFUT_LIST(IFILE);         /*FILE REFERENCE*/
     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
       WHEN(1)                          /*IF IN SINGLE DIGITS*/
           PUT STRING(SMPUT(IFILE).DDNAME) EDIT(DDIPFX,'UT',IFILE)     (A,A,P'9'); /*DDN*/
       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
           PUT STRING(SMPUT(IFILE).DDNAME) EDIT(DDIPFX,'UT',IFILE)    (A,A,P'99'); /*DDN*/
     END;
     SMPUT(IFILE).WRITE.SAVE_CT       =  0000;         /*INITIALIZE WRITE SAVE COUNT*/
     SMPUT(IFILE).WRITE.OPEN_CT       =  0000;         /*INITIALIZE WRITE OPEN COUNT*/
     SMPUT(IFILE).WRITE.LINE_CT       =  0000;         /*INITIALIZE WRITE LINE COUNT*/
 
     SMPUT(IFILE).READ                =  SMPUT(IFILE).WRITE,  BY NAME;
  END  SMPUT_INIT;
 %PAGE;
  SMPSCAN_INIT:                   /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES VARIABLES IN THE SMPSCAN MAJOR   */
                                  /*STRUCTURE.                                      */
                                  /**************************************************/
  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPSCAN_INIT        */
     SMPSCAN(IFILE).FILEREF           =  DTFSCAN_LIST(IFILE);       /*FILE REFERENCE*/
     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
       WHEN(1)                          /*IF IN SINGLE DIGITS*/
           PUT STRING(SMPSCAN(IFILE).DDNAME) EDIT(DDOPFX,'SCAN',IFILE) (A,A,P'9'); /*DDN*/
       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
           PUT STRING(SMPSCAN(IFILE).DDNAME) EDIT(DDOPFX,'SCN',IFILE) (A,A,P'99'); /*DDN*/
     END;
     SMPSCAN(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/
     SMPSCAN(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/
     SMPSCAN(IFILE).PAGE_SZ           =  060;           /*INITIALIZE PAGE SIZE*/
     SMPSCAN(IFILE).LINE_SZ           =  LIST_LINE_SIZE + 012; /*INITIALIZE LINE SIZE*/
     SMPSCAN(IFILE).CURR_PAGE.PAGE_NO =  0000;          /*INITIALIZE PAGE NUMBER*/
     SMPSCAN(IFILE).CURR_PAGE.PAGEKEY = ' ';            /*INITIALIZE PAGE KEY FOR NEWPAGE*/
     SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */
     SMPSCAN(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */
     SMPSCAN(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */
 
     SMPSCAN(IFILE).CURR_NTRY         =   SMPSCAN(IFILE).CURR_PAGE, BY NAME;
  END  SMPSCAN_INIT;
 %SKIP(3);
  SMPSOUT_INIT:                   /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES VARIABLES IN THE SMPSOUT MAJOR   */
                                  /*STRUCTURE.                                      */
                                  /**************************************************/
  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPSOUT_INIT        */
     SMPSOUT(IFILE).FILEREF           =  DTFSOUT_LIST(IFILE);       /*FILE REFERENCE*/
     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
       WHEN(1)                          /*IF IN SINGLE DIGITS*/
           PUT STRING(SMPSOUT(IFILE).DDNAME) EDIT(DDOPFX,'SOUT',IFILE) (A,A,P'9'); /*DDN*/
       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
           PUT STRING(SMPSOUT(IFILE).DDNAME) EDIT(DDOPFX,'SOU',IFILE) (A,A,P'99'); /*DDN*/
     END;
     SMPSOUT(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/
     SMPSOUT(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/
     SMPSOUT(IFILE).PAGE_SZ           =  060;           /*INITIALIZE PAGE SIZE*/
     SMPSOUT(IFILE).LINE_SZ           =  LIST_LINE_SIZE; /*INITIALIZE LINE SIZE*/
     SMPSOUT(IFILE).CURR_PAGE.PAGE_NO =  0000;          /*INITIALIZE PAGE NUMBER*/
     SMPSOUT(IFILE).CURR_PAGE.PAGEKEY =  ' ';           /*INITIALIZE PAGE KEY FOR NEWPAGE*/
     SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */
     SMPSOUT(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */
     SMPSOUT(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */
 
     SMPSOUT(IFILE).CURR_NTRY         =   SMPSOUT(IFILE).CURR_PAGE, BY NAME;
  END  SMPSOUT_INIT;
 %PAGE;
  SMPDATA_INIT:                   /**************************************************/
                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
                                  /*IT INITIALIZES VARIABLES IN THE SMPDATA MAJOR   */
                                  /*STRUCTURE.                                      */
                                  /**************************************************/
  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPDATA_INIT        */
     SMPDATA(IFILE).FILEREF           =  DTFDATA_LIST(IFILE);       /*FILE REFERENCE*/
     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
       WHEN(1)                          /*IF IN SINGLE DIGITS*/
           PUT STRING(SMPDATA(IFILE).DDNAME) EDIT(DDOPFX,'DATA',IFILE) (A,A,P'9'); /*DDN*/
       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
           PUT STRING(SMPDATA(IFILE).DDNAME) EDIT(DDOPFX,'DAT',IFILE) (A,A,P'99'); /*DDN*/
     END;
     SMPDATA(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/
     SMPDATA(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/
     SMPDATA(IFILE).LINE_SZ           =  LIST_LINE_RCZD; /*INITIALIZE LINE(RECORD SIZE*/
     SMPDATA(IFILE).CURR_CARD.DATA    =  ' ';           /*CLEAR DATA OUTPUT AREA*/
     SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  000000000;     /*INITIALIZE SEQUENCE NUMBER*/
 
     SMPDATA(IFILE).CURR_NTRY         =   SMPDATA(IFILE).CURR_CARD, BY NAME;
  END  SMPDATA_INIT;
 %PAGE;
     SMPSCAN_ACTIVATE:           /***************************************************/
                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */
                                 /*IT ACTIVATES THE SMPSCAN DATA SET FOR THIS IFILE.*/
                                 /***************************************************/
       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPSCAN_ACTIVATE   */
 
          SMPSCAN(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/
          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;
 
       END SMPSCAN_ACTIVATE;
     %SKIP(3);
     SMPSOUT_ACTIVATE:           /***************************************************/
                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */
                                 /*IT ACTIVATES THE SMPSOUT DATA SET FOR THIS IFILE.*/
                                 /***************************************************/
       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPSOUT_ACTIVATE   */
 
          SMPSOUT(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/
          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;
 
       END SMPSOUT_ACTIVATE;
     %SKIP(3);
     SMPDATA_ACTIVATE:           /***************************************************/
                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */
                                 /*IT ACTIVATES THE SMPDATA DATA SET FOR THIS IFILE.*/
                                 /***************************************************/
       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPDATA_ACTIVATE   */
          IF  DATA_OUTPUT_OPTION(IFILE)  ^=  'NONE'
            THEN           /*IF DATA_OUTPUT_OPTION = 'ID1' | 'ID' | 'SELECT' | 'ALL'*/
              DO;
                SMPDATA(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/
              END;
          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;
       END SMPDATA_ACTIVATE;
 %SKIP(5);
  END SMPLIST_OPEN;
 %PAGE;
  SMPLIST_CURR_PAGE_EOF:    /********************************************************/
                            /*THE SMPLIST_CURR_PAGE_EOF SUBROUTINE IS CALLED BY     */
                            /*SMPLIST_OPEN FOR INACTIVE FILES, AND BY               */
                            /*SMPLIST_ENTRY_LINE_READ WHEN ATTEMPTING TO BEGIN A    */
                            /*NEW ENTRY AT END-OF-FILE.  THIS SUBROUTINE SETS HIGH  */
                            /*KEY VALUES AND OTHERWISE RESETS VALUES IN THE         */
                            /*CURR_PAGE SUBSTRUCTURE OF THE SMPLIST MAJOR STRUCTURE.*/
                            /********************************************************/
  PROC;                        /*IFILE IS SET PRIOR TO CALLING SMPLIST_CURR_PAGE_EOF*/
 
     STRING(SMPLIST(IFILE).CURR_LINE)                 =  ' ';      /*CLEAR LINE DATA*/
     SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,LIST_LINE_NBGN,LIST_LINE_NWID)
                                           = HIGH(LIST_LINE_NWID);/*ENTRY NAME FIELD*/
 
     SMPLIST(IFILE).CURR_PAGE           =  SMPLIST_CNTL.HIGH_PAGE,  BY NAME;
 
  END  SMPLIST_CURR_PAGE_EOF;
 %PAGE;
  SMPLIST_ENTRY_LINE_READ:
  /********************************************************/
  /*READ THE NEXT LINE FROM THE CURRENT SMPLIST DATA SET, */
  /********************************************************/
  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_READ*/
     DCL    ENTRY_DATA_LINE         BIT(1);               /*ASSUME NOT A DATA LINE  */
 
     ON ENDFILE(SMPLIST(IFILE).FILEREF)
        BEGIN;
           SMPLIST(IFILE).EOF = '1'B;                 /*SIGNAL END-OF-FILE ON INPUT */
        END;
 
     SMPLIST_TITLE1_MAP_ADDR,
     SMPLIST_TITLE2_MAP_ADDR,
     SMPLIST_TITLE3_MAP_ADDR  = ADDR(SMPLIST(IFILE).CURR_LINE.IN.DATA);
    %PAGE;
     READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
     ENTRY_DATA_LINE = '0'B;              /*ASSUME NOT A DATA LINE*/
 
     DO WHILE(^(SMPLIST(IFILE).EOF))      /*IF EOF WAS NOT RECOGNIZED       */
                                          /*  (AN INPUT LINE WAS JUST READ),*/
                                          /*DETERMINE WHETHER THE LINE      */
        UNTIL(ENTRY_DATA_LINE);           /*IS PART OF AN ENTRY LISTING.    */
 
        SMPLIST(IFILE).FILE_TOTALS.RCRD_CT = SMPLIST(IFILE).FILE_TOTALS.RCRD_CT + 1;
 
        SELECT(SMPLIST(IFILE).CURR_LINE.IN.PRTCTL); /*UPDATE LINE NUMBER ON PAGE*/
          WHEN('1') SMPLIST(IFILE).CURR_PAGE.LINE_NO = 01;         /*TOP-OF-PAGE*/
          WHEN('+') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 0;
          WHEN(' ') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 1;
          WHEN('0') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 2;
          WHEN('-') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 3;
          OTHERWISE;
        END;
 
        SELECT;            /*PROCESS THE LISTING LINE JUST READ FROM SMPLIST:*/
         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 01       /*IF TITLE1 LINE*/
              & SMPLIST_TITLE1_MAP.EDATE         =  'DATE'
              & SMPLIST_TITLE1_MAP.ETIME         =  'TIME'
              & SMPLIST_TITLE1_MAP.EGIMSMP       =  'GIMSMP'
              & SMPLIST_TITLE1_MAP.ESMPLIST      =  'SMPLIST'
              & SMPLIST_TITLE1_MAP.EOUTPUT       =  'OUTPUT' )
            DO;
                IF      SMPLIST_TITLE1_MAP.PAGE_NO   = '0000'    /*PAGE NUMBER RECYCLE?*/
                  THEN  SMPLIST(IFILE).CURR_PAGE.PAGE_BS
                                                     =  SMPLIST(IFILE).CURR_PAGE.PAGE_BS
                                                     +  10000;
                SMPLIST(IFILE).CURR_PAGE.PAGE_NO     =  SMPLIST(IFILE).CURR_PAGE.PAGE_BS
                                                     +  SMPLIST_TITLE1_MAP.PAGE_NO;
                SMPLIST(IFILE).CURR_PAGE.FLUSH       = '0'B;     /*SET TO PROCESS PAGE*/
                IF      SMPLIST_TITLE1_MAP.ZONETYPE  = 'GLOBAL'
                  THEN  SMPLIST(IFILE).CURR_PAGE.ZONENAME
                                                     = 'GLOBAL';
                  ELSE  SMPLIST(IFILE).CURR_PAGE.ZONENAME
                                                     =  TRIM(SMPLIST_TITLE1_MAP.ZONENAME);
                SMPLIST(IFILE).CURR_PAGE.ZONEINDX    =
                                                 ZONE_INDEX(SMPLIST_TITLE1_MAP.ZONETYPE);
                SMPLIST(IFILE).CURR_PAGE.ZONETYPE    =
                                            ZONE_TYPE(SMPLIST(IFILE).CURR_PAGE.ZONEINDX);
                SMPLIST(IFILE).CURR_PAGE.ZONETYPE_C  =
                                          ZONE_TYPE_C(SMPLIST(IFILE).CURR_PAGE.ZONEINDX);
                SMPLIST(IFILE).CURR_PAGE.TITLE1_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;
                SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA,
                SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = ' ';      /*CLEAR TITLE2 & 3*/
                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
            END;
    %PAGE;
         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 03       /*IF TITLE2 LINE*/
              & SMPLIST_TITLE2_MAP.ZONENAME      =  SMPLIST(IFILE).CURR_PAGE.ZONENAME
                                                             /*IF VALID ENTRY TYPE*/
              & ENTRY_INDEX(ENTRY_TYPE_TRIM(SUBSTR(SMPLIST_TITLE2_MAP.NTRYTYPE,001))) > 0)
            DO;
                SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;
                SMPLIST(IFILE).CURR_PAGE.NTRYINDX    =
                   ENTRY_INDEX(ENTRY_TYPE_TRIM(SUBSTR(SMPLIST_TITLE2_MAP.NTRYTYPE,001)));
                SMPLIST(IFILE).CURR_PAGE.NTRYTYPE    =
                                           ENTRY_TYPE(SMPLIST(IFILE).CURR_PAGE.NTRYINDX);
                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
            END;
 
         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 03       /*IF MASS SUMMARY REPORT   */
                                                             /*OR SELECT SUMMARY REPORT */
            & ( SMPLIST_TITLE2_MAP.ZONENAME      =  'LIST'   /*BYPASS THE PAGE ENTIRELY.*/
            &  (INDEX(SMPLIST_TITLE2_MAP.NTRYTYPE,'MASS SUMMARY REPORT') > 0
              | INDEX(SMPLIST_TITLE2_MAP.NTRYTYPE,'SELECT SUMMARY REPORT') > 0)) )
            DO;
                SMPLIST(IFILE).CURR_PAGE.FLUSH  =  '1'B;
                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
            END;
 
         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 06       /*IF TITLE3 LINE*/
              & SMPLIST_TITLE3_MAP.FILL01        =  ' '
              & SMPLIST_TITLE3_MAP.ENAME         =  'NAME'
              & SMPLIST_TITLE3_MAP.FILL02        =  ' ' )
            DO;
                SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;
                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
            END;
 
         WHEN(  SMPLIST(IFILE).CURR_PAGE.FLUSH              /*IF PAGE IS BEING SKIPPED*/
              | SMPLIST(IFILE).CURR_LINE.IN.DATA = ' ')     /*OR THE LINE IS BLANK*/
            DO;                                             /*THEN SKIP PAST THE LINE*/
                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
            END;
 
         OTHERWISE                 /*IF ALL OF THE PRECEEDING TESTS FAILED,          */
            DO;                    /*THE LINE JUST READ IS AN ENTRY LISTING LINE.    */
                ENTRY_DATA_LINE = '1'B;          /*INDICATE THAT A DATA LINE WAS READ*/
            END;
 
        END;           /*END OF SELECT GROUP FOR IDENTIFYING THE TYPE OF LINE READ*/
 
     END;              /*END OF DO WHILE(^SMPLIST(IFILE).EOF) UNTIL(ENTRY_DATA_LINE) GROUP*/
    %PAGE;
                                     /*AN ENTRY LISTING LINE HAS JUST BEEN READ.    */
                                     /*CHECK FOR THE START OF A NEW ENTRY LISTING.  */
                                     /*WE HAVE REACHED THE END OF THE CURRENT ENTRY */
                                     /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,    */
                                     /*OR IF END-OF-FILE WAS ENCOUNTERED.           */
                                     /*IN EITHER CASE, WE WRAP UP PROCESSING OF     */
                                     /*THE CURRENT ENTRY AND PREPARE TO BEGIN       */
                                     /*PROCESSING THE NEW ENTRY.                    */
 
     IF ( ^(SMPLIST(IFILE).EOF)      /*IF THE FIRST LINE OF A NEW ENTRY,            */
         & (SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,LIST_LINE_NBGN,LIST_LINE_NWID) ^= ' '))
      |    (SMPLIST(IFILE).EOF)      /*OR IF END-OF-FILE                            */
        THEN
          DO;          /*THE LINE JUST READ OR E-O-F ENDS THE PREVIOUS ENTRY LISTING*/
             /*---------------------------------------------*/
             /*PREPARE FOR PROCESSING A NEW ENTRY OR E-O-F  */
             /*---------------------------------------------*/
             IF  ^(SMPLIST(IFILE).EOF)
               THEN                                         /*FIRST LINE OF A NEW ENTRY */
                 DO;
                   SMPLIST(IFILE).CURR_LINE.LINETYPE   = ' ';  /*INITIALIZE FOR NEW ENTRY*/
                   SMPLIST(IFILE).CURR_LINE.LINETYPE   =
                                    LINE_TYPE(SMPLIST(IFILE).CURR_LINE.LINETYPE,
                                              SMPLIST(IFILE).CURR_LINE.IN.DATA);
                   SMPLIST(IFILE).CURR_PAGE.NTRYNAME   =
                                              TRIM(SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,
                                                          LIST_LINE_NBGN,LIST_LINE_NWID));
                   PUT STRING(SMPLIST(IFILE).CURR_PAGE.PAGEKEY)
                       EDIT('0')                                  (A(1))
                           (SMPLIST(IFILE).CURR_PAGE.ZONEINDX)    (P'9')
                           (SMPLIST(IFILE).CURR_PAGE.ZONENAME)    (A(007))
                           (SMPLIST(IFILE).CURR_PAGE.NTRYINDX)    (P'99');
                   SMPLIST(IFILE).CURR_PAGE.NTRYKEY  =   SMPLIST(IFILE).CURR_PAGE.PAGEKEY
                                                      || SMPLIST(IFILE).CURR_PAGE.NTRYNAME;
                   PUT STRING(SMPLIST(IFILE).CURR_PAGE.CMPRKEY)
                       EDIT('0')                                  (A(1))
                           (SMPLIST(IFILE).CURR_PAGE.NTRYINDX)    (P'99')
                           (SMPLIST(IFILE).CURR_PAGE.NTRYNAME)    (A(008));
                 END;
               ELSE                              /*IF ENTRY TERMINATED BY END-OF-FILE  */
                 DO;
                   CALL SMPLIST_CURR_PAGE_EOF;   /*SET CURR_PAGE VALUES FOR END-OF-FILE*/
                 END;
          END;
        ELSE
          DO;     /*THE LINE JUST READ IS A CONTINUATION OF THE CURRENT ENTRY LISTING*/
            SMPLIST(IFILE).CURR_LINE.LINETYPE  =      /*DETERMINE LINETYPE*/
                           LINE_TYPE(SMPLIST(IFILE).CURR_LINE.LINETYPE,
                                     SMPLIST(IFILE).CURR_LINE.IN.DATA);
          END;
     RETURN;
  END SMPLIST_ENTRY_LINE_READ;
 %PAGE;
  SMPLIST_ENTRY_READ:
  /********************************************************/
  /*READ THE NEXT ENTRY FROM THE ACTIVE SMPLIST DATA SETS */
  /********************************************************/
  PROC;
 
      DO      IFILE = IFILE_MIN TO IFILE_MAX;
        IF   (SMPLIST(IFILE).ACTIVE)                     /*PROCESS ONLY THE ACTIVE FILES */
          &  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)      /*THAT WERE PROCESSED LAST TIME.*/
          THEN
            DO;                                   /*UPDATE CURR_NTRY FOR NEW ENTRY OR EOF*/
              SMPLIST(IFILE).CURR_NTRY = SMPLIST(IFILE).CURR_PAGE   , BY NAME;
 
              IF   (SMPLIST(IFILE).EOF)              /*IF THE FILE IS AT ITS END,        */
                THEN;                                /*THEN FILE PROCESSING IS COMPLETE  */
                ELSE CALL SMPLIST_ENTRY_FILE_READ;   /*OTHERWISE READ THE NEXT ENTRY.    */
 
            END;            /*END OF ACTIVE IFILE/CMPR_RESULT DO GROUP*/
      END;                  /*END OF IFILE                    DO GROUP*/
 
      CALL SMPLIST_ENTRY_COMPARE;   /*COMPARE KEYS FOR ENTRIES READ*/
 
      CALL SMPLIST_ENTRY_MATCH;     /*SEE IF THESE ENTRIES SHOULD BE PROCESSED FURTHER*/
 
      RETURN;                       /*TO THE CALLER OF SMPLIST_ENTRY_READ*/
 %PAGE;
  SMPLIST_ENTRY_FILE_READ:
                              /***********************************************************/
                              /*THIS PROCEDURE IS INTERNAL TO "SMPLIST_ENTRY_READ".      */
                              /*IT READS THE NEXT ENTRY FROM THE CURRENT SMPLIST         */
                              /*DATA SET:                                                */
                              /***********************************************************/
  PROC;                       /*IFILE IS SET ON ENTRY TO SMPLIST_ENTRY_FILE_READ         */
     IF      (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))
       THEN
         DO;
              IF  (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)       /*IF ENTRIES ARE BEING SCANNED,*/
                THEN CALL  SMPLIST_ENTRY_SCAN_INIT;            /*INIT SCAN_CUBE FOR ENTRY*/
         END;
 
     DO WHILE(SMPLIST(IFILE).CURR_PAGE.NTRYKEY = SMPLIST(IFILE).CURR_NTRY.NTRYKEY);
        CALL               SMPLIST_ENTRY_LINE_EVAL;       /*EVALUATE THE CURRENT LINE    */
        IF   (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))
          THEN
            DO;
              IF  (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)       /*IF ENTRIES ARE BEING SCANNED,*/
                THEN CALL  SMPLIST_ENTRY_LINE_SCAN;       /*SCAN THE CURRENT LINE        */
              CALL         SMPLIST_ENTRY_LINE_SAVE;       /*SAVE THE CURRENT LINE        */
            END;
        CALL               SMPLIST_ENTRY_LINE_READ;       /*READ THE NEXT    LINE        */
     END;
     CALL                  SMPLIST_ENTRY_FILE_READ_WRAPUP;    /*CALC. CURR_NTRY FINAL VALS*/
 
     IF      (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))
       THEN
         DO;
           IF (SMPLIST(IFILE).CURR_NTRY.LINE_CT > LINE_SAVE_LIMIT)/*IF SPILL FILE OPENED,*/
             THEN CLOSE FILE(SMPUT(IFILE).FILEREF) ENV(REREAD);   /*CLOSE IT.            */
 
           IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)            /*FINAL SCAN RESULTS FOR ENTRY*/
             THEN SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT = SMPLIST_ENTRY_SCAN_RESULT;
 
           IF (SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
             THEN
               DO;        /*IF THE SCAN_RESULT IS POSITIVE, UPDATE SELECT_CT TOTALS*/
                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT  =
                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT + 1;
                 SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST(IFILE).CURR_NTRY.NTRYINDX).SELECT_CT =
                 SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST(IFILE).CURR_NTRY.NTRYINDX).SELECT_CT
                                                                                    + 1;
               END;
         END;
 
     RETURN;                       /*TO THE CALLER OF SMPLIST_ENTRY_FILE_READ*/
 %PAGE;
  SMPLIST_ENTRY_SCAN_INIT:    /********************************************************/
                              /*INITIALIZE THE SCAN_CUBE IN SMPLIST FOR SCANNING THE  */
                              /*ENTRY.                                                */
                              /********************************************************/
  PROC;                       /*IFILE IS SET PRIOR TO ENTRY.                          */
                              /*SMPLIST_ENTRY_SCAN_INIT IS CALLED ONLY IF             */
                              /*SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.            */
                              /*I.E., THERE IS AT LEAST ONE ACTIVE SCAN PLANE.        */
                   SMPLIST(IFILE).SCAN_CUBE.RESULT = '0'B;
     DO            IPLANE  = IPLANE_MIN TO IPLANE_MAX;
       IF          SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE /*IF PLANE ACTIVE*/
         THEN
           DO;
                   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT = '1'B;
             DO    IROW  = IROW_MIN   TO IROW_MAX;
               IF  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE
                 THEN
                   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT = '0'B;
             END;                  /*END OF IROW          DO GROUP*/
           END;                    /*END OF ACTIVE IPLANE DO GROUP*/
     END;                          /*END OF IPLANE        DO GROUP*/
  END SMPLIST_ENTRY_SCAN_INIT;
 %SKIP(2);
  SMPLIST_ENTRY_LINE_SCAN:    /********************************************************/
                              /*SCAN THE CURRENT LINE AND SET ROW RESULTS.            */
                              /*PLANE AND CUBE SCAN RESULTS ARE CALCULATED LATER ON,  */
                              /*IN SMPLIST_ENTRY_SCAN_RESULT, AFTER ALL LINES         */
                              /*FOR AN ENTRY HAVE BEEN SCANNED.                       */
                              /********************************************************/
  PROC;                       /*IFILE IS SET PRIOR TO ENTRY.                          */
                              /*SMPLIST_ENTRY_LINE_SCAN IS CALLED ONLY IF             */
                              /*SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.            */
                              /*I.E., THERE IS AT LEAST ONE ACTIVE SCAN PLANE.        */
 
     DO         IPLANE  = IPLANE_MIN TO IPLANE_MAX;
       IF       SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE /*IF PLANE IS ACTIVE*/
         THEN
           DO     IROW  = IROW_MIN   TO IROW_MAX;
             IF                           /*IF THE ROW IS ACTIVE AND STILL NO LINE HIT*/
                 (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)
              & ^(SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT)
 
               THEN
                 SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT
                   =  SMPLIST_SCAN_LINE_DATA(SMPLIST(IFILE).CURR_NTRY.NTRYINDX,
                                             SMPLIST(IFILE).CURR_LINE.LINETYPE,
                                             SMPLIST(IFILE).CURR_LINE.IN.DATA);
 
           END;                  /*END OF IROW   DO GROUP*/
     END;                       /*END OF IPLANE DO GROUP*/
 
  END SMPLIST_ENTRY_LINE_SCAN;
 %PAGE;
  SMPLIST_ENTRY_LINE_EVAL:
  /***********************************************************/
  /*THIS PROCEDURE IS INTERNAL TO "SMPLIST_ENTRY_FILE_READ". */
  /*IT CALCULATES ANY CURR_NTRY VALUES THAT ARE BASED ON     */
  /*THE CURRENT LINE.                                        */
  /***********************************************************/
  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_EVAL*/
 
     NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;
 
     SMPLIST(IFILE).CURR_NTRY.LINE_CT = SMPLIST(IFILE).CURR_NTRY.LINE_CT + 1;
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT     =
                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT     + 1;
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT  =
                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT  + 1;
 
     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT = 0001)        /*FIRST LINE OF A NEW ENTRY*/
       THEN
         DO;
           SMPLIST(IFILE).CURR_NTRY.PAGE_NO =  SMPLIST(IFILE).CURR_PAGE.PAGE_NO;
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT    =
                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT    + 1;
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT =
                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT + 1;
 
           IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT         = 0001)
             THEN SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGELO      =
                                 SMPLIST(IFILE).CURR_NTRY.PAGE_NO;
           IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT      = 0001)
             THEN SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGELO   =
                                 SMPLIST(IFILE).CURR_NTRY.PAGE_NO;
         END;
 
     SMPLIST(IFILE).CURR_NTRY.PAGE_HI =  SMPLIST(IFILE).CURR_PAGE.PAGE_NO;
 
     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'FMID')
       THEN
           SMPLIST(IFILE).CURR_NTRY.FMID      =
                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,007);
     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'SOURCEID')
       THEN
           SMPLIST(IFILE).CURR_NTRY.SOURCEID  =
                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,008);
     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'SYSTEM LIBRARY')
       THEN
         DO;
           SMPLIST(IFILE).CURR_NTRY.SYSLIB1   =
                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,008);
           SMPLIST(IFILE).CURR_NTRY.SYSLIB2   =
                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN+010,008);
         END;
  END SMPLIST_ENTRY_LINE_EVAL;
 %PAGE;
  SMPLIST_ENTRY_LINE_SAVE:
  /***********************************************************/
  /*THIS PROCEDURE IS INTERNAL TO "SMPLIST_ENTRY_READ".      */
  /*IT SAVES THE CURRENT LINE OF THE CURRENT ENTRY FROM      */
  /*THE CURRENT SMPLIST DATA SET.  IF THE CAPACITY OF THE    */
  /*IN-STORAGE SAVE AREA HAS BEEN EXCEEDED, THE SPILL FILE   */
  /*(SMPUT?) IS OPENED, AND THE LINE IS WRITTEN TO THE       */
  /*SPILL FILE.                                              */
  /*                                                         */
  /***********************************************************/
  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_SAVE*/
 
     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT  =  0001)
       THEN
         DO;
             SMPUT(IFILE).WRITE.SAVE_CT = SMPUT(IFILE).WRITE.SAVE_CT + 1;
         END;
 
     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT  =  LINE_SAVE_LIMIT+1)
       THEN
         DO;
             SMPUT(IFILE).WRITE.OPEN_CT = SMPUT(IFILE).WRITE.OPEN_CT + 1;
             OPEN  FILE(SMPUT(IFILE).FILEREF) OUTPUT TITLE(SMPUT(IFILE).DDNAME);
         END;
 
     IF      SMPLIST(IFILE).CURR_NTRY.LINE_CT <=   LINE_SAVE_LIMIT
 
       THEN  SMPUT(IFILE).LINE_SAVE(SMPLIST(IFILE).CURR_NTRY.LINE_CT)
               =  SMPLIST(IFILE).CURR_LINE.IN.DATA;
       ELSE
         DO;
             SMPUT(IFILE).WRITE.LINE_CT = SMPUT(IFILE).WRITE.LINE_CT + 1;
             WRITE FILE(SMPUT(IFILE).FILEREF)  FROM(SMPLIST(IFILE).CURR_LINE.IN.DATA);
         END;
 
  END SMPLIST_ENTRY_LINE_SAVE;
 %PAGE;
  SMPLIST_ENTRY_FILE_READ_WRAPUP:
  /***********************************************************/
  /*THIS PROCEDURE IS INTERNAL TO "SMPLIST_ENTRY_FILE_READ". */
  /*IT CALCULATES ANY FINAL CURR_NTRY VALUES FOR THE CURRENT */
  /*ENTRY JUST ENDED.                                        */
  /***********************************************************/
  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_FILE_READ_WRAPUP*/
 
     NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;
 
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGEHI,
     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGEHI
                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_HI;
 
     IF   (SMPLIST(IFILE).CURR_NTRY.LINE_CT    >
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE)
       THEN
         DO;
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE
                                               = SMPLIST(IFILE).CURR_NTRY.LINE_CT;
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXNAME
                                               = SMPLIST(IFILE).CURR_NTRY.NTRYNAME;
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXPAGE
                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_NO;
         END;
 
     IF   (SMPLIST(IFILE).CURR_NTRY.LINE_CT    >
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE)
       THEN
         DO;
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE
                                               = SMPLIST(IFILE).CURR_NTRY.LINE_CT;
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXNAME
                                               = SMPLIST(IFILE).CURR_NTRY.NTRYNAME;
           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXPAGE
                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_NO;
         END;
  END SMPLIST_ENTRY_FILE_READ_WRAPUP;
 %PAGE;
  SMPLIST_ENTRY_SCAN_RESULT:    /**************************************************/
                                /*CALCULATE THE FINAL SCAN RESULT FOR THE ENTRY   */
                                /**************************************************/
 
  PROC   RETURNS(BIT(01));     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_SCAN_RESULT,*/
                               /*AND SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.   */
 
              SMPLIST(IFILE).SCAN_CUBE.RESULT = '0'B;           /*PRESET TO '0'B*/
     DO      IPLANE = IPLANE_MIN TO IPLANE_MAX;
       IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)
         THEN
            DO;                /*ANY ACTIVE PLANE FOR THE FILE CAN MATCH*/
                               /*ALL ACTIVE ROWS IN A PLANE   MUST MATCH*/
 
              SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT = '1'B;
              DO     IROW  = IROW_MIN   TO IROW_MAX
                WHILE(SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT);
 
                IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)
                  THEN
                      SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT   /*ALL ACTIVE ROWS*/
                       =  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT
                       & (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT =
                          SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT);
 
              END;             /*END OF IROW DO GROUP*/
 
              SMPLIST(IFILE).SCAN_CUBE.RESULT                       /*ANY ACTIVE PLANES*/
               =  SMPLIST(IFILE).SCAN_CUBE.RESULT
               | (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT =
                  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT);
 
            END;               /*END OF ACTIVE IPLANE DO GROUP*/
     END;                      /*END OF IPLANE DO GROUP*/
 
     RETURN((SMPLIST(IFILE).SCAN_CUBE.SELECT = SMPLIST(IFILE).SCAN_CUBE.RESULT));
 
  END SMPLIST_ENTRY_SCAN_RESULT;
 %SKIP(2);
  END SMPLIST_ENTRY_FILE_READ;
 %PAGE;
  SMPLIST_ENTRY_COMPARE:         /********************************************************/
                                 /*COMPARE THE ENTRY KEYS FOR ALL ACTIVE SMPLIST FILES,  */
                                 /*AND IDENTIFY THOSE THAT ARE LOWEST IN COLLATING SEQ:  */
                                 /********************************************************/
  PROC;
 
      SMPLIST_CNTL.E_CMPR  =  SMPLIST_CNTL.HIGH_CMPR,    BY NAME;          /*RESET VALUES*/
 
      DO    IFILE = IFILE_MIN TO IFILE_MAX; /*THE FIRST PASS FINDS THE LOWEST COMPARE KEY*/
        IF   (SMPLIST(IFILE).ACTIVE)                          /*PROCESS ONLY ACTIVE FILES*/
           & (SMPLIST(IFILE).CURR_NTRY.CMPRKEY < SMPLIST_CNTL.E_CMPR.CMPRKEY)
          THEN
            DO;
              SMPLIST_CNTL.E_CMPR         =  SMPLIST(IFILE).CURR_NTRY,  BY NAME;
              SMPLIST_CNTL.E_CMPR.RESULT  = '1'B;
            END;
      END;
 
      IF     (SMPLIST_CNTL.E_CMPR.RESULT)             /*IF ALL FILES WERE NOT AT E-O-F,  */
        THEN                                          /*THE SECOND PASS IDENTIFIES       */
          DO    IFILE = IFILE_MIN TO IFILE_MAX;       /*ENTRIES MATCHING THE COMPARE KEY.*/
            IF   (SMPLIST(IFILE).ACTIVE)
               & (SMPLIST(IFILE).CURR_NTRY.CMPRKEY     =  SMPLIST_CNTL.E_CMPR.CMPRKEY)
              THEN
                  SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT = '1'B;   /*SET FOR MATCHING KEYS */
          END;
 
  END SMPLIST_ENTRY_COMPARE;
 %PAGE;
  SMPLIST_ENTRY_MATCH:           /********************************************************/
                                 /*                                                      */
  PROC;                          /********************************************************/
     SMPLIST_CNTL.A_MATCH.RESULT  = '0'B;
     DO      IFILE = IFILE_MIN TO IFILE_MAX;
       SMPLIST(IFILE).CURR_NTRY.WRITE_OUT  =  '0'B;
     END;
 
     IF    (SMPLIST_CNTL.E_CMPR.RESULT)            /*IF ANY FILES HAVE ENTRIES TO PROCESS*/
       THEN CALL SMPLIST_ENTRY_NTRY_MATCH;         /*MATCH THEM UP AND DETERMINE RESULTS */
 
     IF    (SMPLIST_CNTL.A_MATCH.RESULT)
       THEN                 /*IF THE MATCH_RESULT IS POSITIVE, UPDATE MATCH_CT TOTALS*/
         DO IFILE = IFILE_MIN TO IFILE_MAX;
            IF  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
              THEN
                DO;
                  NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;
                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT    =
                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT    + 1;
                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT =
                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT + 1;
                END;             /*END OF CMPR_RESULT IFILE DO GROUP*/
         END;                    /*END OF IFILE DO GROUP*/
     RETURN;                     /*TO THE CALLER OF SMPLIST_ENTRY_MATCH*/
 %PAGE;
  SMPLIST_ENTRY_NTRY_MATCH:      /********************************************************/
                                 /*                                                      */
                                 /********************************************************/
  PROC;
 
     IF    (SMPLIST_CNTL.A_MATCH.ACTIVE)        /*TEST FOR ENTRY MATCH TESTS PROVIDED*/
       THEN                             /*IF ANY ENTRY MATCH TESTS HAVE BEEN PROVIDED*/
         DO IMATCH = IMATCH_MIN TO IMATCH_MAX;  /*APPLY ALL ACTIVE ONES FOR THIS TYPE*/
 
           IF      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE)                 /*ACTIVE*/
 
              &  (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX  =
                                                  SMPLIST_CNTL.E_CMPR.NTRYINDX)
                 & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX >= NTRYINDX_MIN)
                 & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX <= NTRYINDX_MAX))
 
                |  (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX >  NTRYINDX_MAX)) /*ALL*/
 
             THEN          /*SMPLIST_ENTRY_FILE_MATCH SETS SMPLIST(*).CURR_NTRY.WRITE_OUT*/
 
                SMPLIST_CNTL.A_MATCH.RESULT  =    SMPLIST_CNTL.A_MATCH.RESULT
                                               |  SMPLIST_ENTRY_FILE_MATCH;
 
         END;                    /*END OF IMATCH DO GROUP*/
 
       ELSE                          /*IF NO MATCHING ENTRY TESTS HAVE BEEN PROVIDED,*/
         DO IFILE = IFILE_MIN TO IFILE_MAX;       /*SUCCESSFUL SCAN/CMPRS ARE MATCHES*/
            IF     (SMPLIST(IFILE).ACTIVE)
              THEN
                DO;
                    SMPLIST(IFILE).CURR_NTRY.WRITE_OUT
                                                  =  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT
                                                    & SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT);
                    SMPLIST_CNTL.A_MATCH.RESULT   =   SMPLIST_CNTL.A_MATCH.RESULT
                                                  |  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT
                                                    & SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT);
                END;
         END;                    /*END OF  NO-MATCHING-ENTRY-TESTS IFILE DO GROUP*/
 
     RETURN;                     /*TO THE CALLER OF SMPLIST_ENTRY_NTRY_MATCH*/
 %PAGE;
  SMPLIST_ENTRY_FILE_MATCH:      /********************************************************/
                                 /*                                                      */
                                 /********************************************************/
  PROC RETURNS(BIT(1));          /*IMATCH IS SET ON ENTRY TO SMPLIST_ENTRY_FILE_MATCH    */
     DCL (FILE_MATCH_RESULT,C_TST_CNTL)          BIT(01);
 
     FILE_MATCH_RESULT,C_TST_CNTL  =  SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST;
 
     DO         IFILE = IFILE_MIN TO IFILE_MAX   WHILE(FILE_MATCH_RESULT = C_TST_CNTL);
        IF     (SMPLIST(IFILE).ACTIVE)
          THEN  FILE_MATCH_RESULT  =
 
                  (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
                                             &  SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR))
 
                &  ((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL
                                             &  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL
                                             & ^SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL)))
 
                |   (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR
                                             & ^SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT);
 
     END;        /*END OF IFILE DO GROUP*/
 
     IF       (FILE_MATCH_RESULT)                    /*IF THE FILE MATCH CRITERIA       */
       THEN                                       /*WERE SATISFIED FOR THIS MATCH ENTRY,*/
         DO         IFILE = IFILE_MIN TO IFILE_MAX;  /*SET REQUIRED WRITE_OUT INDICATORS*/
           IF      (SMPLIST(IFILE).ACTIVE)
                 & (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
             THEN
                SMPLIST(IFILE).CURR_NTRY.WRITE_OUT  =
                    (SMPLIST(IFILE).CURR_NTRY.WRITE_OUT)
                |
                   ((SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
                  & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)
                  &((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL
                                             &  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL
                                             & ^SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL)));
 
         END;    /*END OF IFILE DO GROUP*/
 
     RETURN(FILE_MATCH_RESULT);
  END SMPLIST_ENTRY_FILE_MATCH;
 %SKIP(1);
  END SMPLIST_ENTRY_NTRY_MATCH;
 %SKIP(1);
  END SMPLIST_ENTRY_MATCH;
 %SKIP(1);
  END SMPLIST_ENTRY_READ;
 %PAGE;
  SMPLIST_ENTRY_WRITE:          /********************************************************/
                                /*                                                      */
                                /*                                                      */
  PROC;                         /********************************************************/
     DCL   ENTRY_NTRYINDX_ADDR   POINTER,
           ENTRY_NTRYINDX        FIXED BIN(15,0) BASED(ENTRY_NTRYINDX_ADDR),
           ENTRY_LINE_LINETYPE   CHAR(015),
           ENTRY_LINE_DATA_ADDR  POINTER,
           ENTRY_LINE_DATA       CHAR(120) BASED(ENTRY_LINE_DATA_ADDR),
           ENTRY_LINE_SELECT     BIT(01),
        01 ENTRY_LINE_UNDR,              /*UNDERLINE LINE FOR LISTING LINE BEING WRITTEN*/
           05 PRTCTL             CHAR(001),                  /*SET TO "+" IF UNDERSCORES*/
           05 DATA,
              09 U_SCORE         CHAR(LIST_LINE_SIZE),       /*UNDERSCORES*/
              09 FILL01          CHAR(001),                  /*BLANKS*/
              09 A_FLAG          CHAR(011);                  /*ASTERISKS*/
    %PAGE;
     DO    IFILE = IFILE_MIN TO IFILE_MAX;
       IF  SMPLIST(IFILE).CURR_NTRY.WRITE_OUT    /*PROCESS ONLY THOSE FILES THAT */
                                                   /*HAVE DATA TO BE WRITTEN OUT.*/
         THEN                                    /*IF THE FILE IS TO BE PROCESSED*/
           DO;                                  /*WRITE THE CURRENT ENTRY LISTING*/
             ENTRY_LINE_SELECT      = '0'B;    /*ASSUME NO LINES WILL BE SELECTED*/
             STRING(ENTRY_LINE_UNDR) = ' ';    /*ASSUME UNDERLINES AREN'T PRESENT*/
             ENTRY_NTRYINDX_ADDR    = ADDR(SMPLIST(IFILE).CURR_NTRY.NTRYINDX);
             ENTRY_LINE_LINETYPE    = ' ';     /*INITIALIZE LINETYPE FOR ENTRY START*/
             SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT =
             SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT + 1;
             SMPLIST(IFILE).ENTRY_TOTALS(ENTRY_NTRYINDX).WRITE_CT =
             SMPLIST(IFILE).ENTRY_TOTALS(ENTRY_NTRYINDX).WRITE_CT + 1;
 
             IF      SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT
               THEN                 /*IF THE SPILL FILE WILL BE NEEDED, OPEN IT FOR INPUT*/
                 DO;
                     SMPUT(IFILE).READ.OPEN_CT = SMPUT(IFILE).READ.OPEN_CT + 1;
                     OPEN  FILE(SMPUT(IFILE).FILEREF) INPUT TITLE(SMPUT(IFILE).DDNAME);
                 END;
 
             DO        ILINE  =  001  TO   SMPLIST(IFILE).CURR_NTRY.LINE_CT;
 
                IF     ILINE <=  LINE_SAVE_LIMIT    /*GET ADDRESS OF THE NEXT ENTRY LINE*/
                  THEN     ENTRY_LINE_DATA_ADDR = ADDR(SMPUT(IFILE).LINE_SAVE(ILINE));
                  ELSE DO;
                           SMPUT(IFILE).READ.LINE_CT = SMPUT(IFILE).READ.LINE_CT + 1;
                           READ FILE(SMPUT(IFILE).FILEREF) SET(ENTRY_LINE_DATA_ADDR);
                       END;
                ENTRY_LINE_LINETYPE = LINE_TYPE(ENTRY_LINE_LINETYPE,ENTRY_LINE_DATA);
 
                IF SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT    /*IF THIS FILE'S ENTRIES ARE */
                                                            /*BEING SCANNED, AND THE SCAN*/
                                                            /*WAS SUCCESSFUL,            */
                                                            /*ASSEMBLE THE UNDERLINE LINE*/
                                           THEN CALL  SMPLIST_ENTRY_LINE_UNDRLINE;
                IF SMPSCAN(IFILE).ACTIVE   THEN CALL  SMPSCAN_ENTRY_LINE_WRITE;
                IF SMPSOUT(IFILE).ACTIVE   THEN CALL  SMPSOUT_ENTRY_LINE_WRITE;
                IF SMPDATA(IFILE).ACTIVE   THEN CALL  SMPDATA_ENTRY_LINE_WRITE;
             END;              /*END OF ILINE DO GROUP*/
 
             IF        SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT
               THEN                   /*IF THE SPILL FILE WAS OPENED FOR INPUT, CLOSE IT*/
                       CLOSE FILE(SMPUT(IFILE).FILEREF) ENV(REREAD);
 
           END;                /*END OF WRITE_OUT IFILE DO GROUP*/
     END;                      /*END OF IFILE DO GROUP*/
 
     RETURN;                   /*TO THE CALLER OF SMPLIST_ENTRY_WRITE*/
 %PAGE;
  SMPLIST_ENTRY_LINE_UNDRLINE:   /********************************************************/
                                 /*                                                      */
                                 /*                                                      */
                                 /********************************************************/
  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */
 
     DCL 01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)
                                     LIKE SCAN_ARRAY.PLANE.ROW.COL,
            STRING                  BUILTIN;
 
     ENTRY_LINE_SELECT       = '0'B;                          /*RESET LINE SELECT CONTROL*/
     STRING(ENTRY_LINE_UNDR) = ' ';                                /*CLEAR UNDERLINE LINE*/
 
     DO          IPLANE  = IPLANE_MIN TO IPLANE_MAX  WHILE(ENTRY_LINE_UNDR.PRTCTL ^= '+');
       IF       (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)/*IF PLANE ACTIVE, AND*/
            &   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT /*PLANE RESULTS SUCCESSFUL*/
               = SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT)
         THEN
           DO     IROW  = IROW_MIN   TO IROW_MAX     WHILE(ENTRY_LINE_UNDR.PRTCTL ^= '+');
            IF  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE    /*IF ROW ACTIVE*/
             &  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT    /*WITH RESULTS*/
             &  SMPLIST_SCAN_LINE_DATA(ENTRY_NTRYINDX,                   /*FROM THIS LINE*/
                                        ENTRY_LINE_LINETYPE,ENTRY_LINE_DATA)
               THEN
                 DO;
                   ENTRY_LINE_SELECT           = '1'B;     /*LINE IS SELECTED BY THIS ROW*/
                   ENTRY_LINE_UNDR.PRTCTL      = '+';               /*LINE IS HIGHLIGHTED*/
                   DO    ICOL  = ICOL_MIN   TO ICOL_MAX;             /*UNDERSCORE STRINGS*/
                     SCAN_ARRAY_ELEMENT_ADDR
                         = ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));
                     IF (SCAN_ARRAY_ELEMENT.STR_LEN > 0)                   /*IF STR SUPPL*/
                       THEN
                         CALL UNDERLINE_STRING_OP;
                   END;        /*END OF ICOL   DO GROUP*/
                   PUT STRING(ENTRY_LINE_UNDR.DATA.A_FLAG)
                         EDIT('**',IPLANE,',',IROW,'**')           (A,P'999',A,P'999',A);
                 END;          /*END OF ACTIVE/SELECTED IROW DO GROUP*/
           END;                /*END OF IROW   DO GROUP*/
     END;                      /*END OF IPLANE DO GROUP*/
 
     RETURN;                   /*TO THE CALLER OF SMPLIST_ENTRY_LINE_UNDRLINE*/
    %PAGE;
     UNDERLINE_STRING_OP:
     PROC;  /*UNDERLINE THE MATCHING STRINGS BASED ON                           */
            /*THE TYPE OF SCAN OPERATION:                                       */
        SELECT(SCAN_ARRAY_ELEMENT.OP_OIX);
          WHEN(12,13);  /* EQENTRY | NEENTRY */          /*NO UNDERLINES*/
 
          WHEN(22)      /* EQLINE  */       CALL UNDERLINE_STRING_OKLINE;
          WHEN(23)      /* NELINE  */       CALL UNDERLINE_STRING_OKLINE;
 
          WHEN(32)      /* EQGLINE */       CALL UNDERLINE_STRING_OKGLIN;
          WHEN(33)      /* NEGLINE */       CALL UNDERLINE_STRING_OKGLIN;
 
          WHEN(42)      /* EQSCAN  */       CALL UNDERLINE_STRING_EQSCAN;
          WHEN(43)      /* NESCAN  */       CALL UNDERLINE_STRING_NESCAN;
 
          WHEN(52)      /* EQGSCAN */       CALL UNDERLINE_STRING_EQGSCN;
          WHEN(53)      /* NEGSCAN */       CALL UNDERLINE_STRING_NEGSCN;
 
          WHEN(60)      /* LTCMPR  */       CALL UNDERLINE_STRING_OKCMPR;
          WHEN(61)      /* LECMPR  */       CALL UNDERLINE_STRING_OKCMPR;
          WHEN(62)      /* EQCMPR  */       CALL UNDERLINE_STRING_OKCMPR;
          WHEN(63)      /* NECMPR  */       CALL UNDERLINE_STRING_OKCMPR;
          WHEN(64)      /* GECMPR  */       CALL UNDERLINE_STRING_OKCMPR;
          WHEN(65)      /* GTCMPR  */       CALL UNDERLINE_STRING_OKCMPR;
 
          WHEN(72)      /* EQGCMPR */       CALL UNDERLINE_STRING_OKGCPR;
          WHEN(73)      /* NEGCMPR */       CALL UNDERLINE_STRING_OKGCPR;
 
        END;  /*END OF SELECT GROUP ON SCAN_ARRAY_ELEMENT.OP_OIX*/
        RETURN;
    %PAGE;
     UNDERLINE_STRING_EQSCAN:
     PROC;  /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS      */
            /*FOR THE SEARCH STRING.  WHEREVER THE SCAN STRING APPEARS,         */
            /*INSERT UNDERSCORE CHARACTERS INTO ENTRY_LINE_UNDR.DATA.U_SCORE    */
            /*A DO LOOP IS USED TO UNDERSCORE ALL OCCURRENCES OF THE SEARCH     */
            /*STRING WITHIN THE SCAN POSITIONS, AND NOT JUST THE FIRST.         */
 
        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/
             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/
 
        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
 
        DO   US_IX =  SCAN_ARRAY_ELEMENT.BEG_POS
               TO    (SCAN_ARRAY_ELEMENT.END_POS - US_LN + 1);
          IF   SUBSTR(ENTRY_LINE_DATA,US_IX,US_LN)
                   =  SCAN_ARRAY_ELEMENT.STRING
            THEN
              DO;   /*INSERT UNDERSCORES AND ADJUST POSITION INDEX FOR NEXT ATTEMPT*/
                SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
                US_IX = US_IX + US_LN - 1;
              END;
        END;
     END UNDERLINE_STRING_EQSCAN;
    %SKIP(3);
     UNDERLINE_STRING_EQGSCN:
     PROC;  /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS      */
            /*FOR THE SEARCH STRING.  WHEREVER THE SCAN STRING APPEARS,         */
            /*INSERT UNDERSCORE CHARACTERS INTO ENTRY_LINE_UNDR.DATA.U_SCORE    */
            /*A DO LOOP IS USED TO UNDERSCORE ALL OCCURRENCES OF THE SEARCH     */
            /*STRING WITHIN THE SCAN POSITIONS, AND NOT JUST THE FIRST.         */
 
        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/
             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/
 
        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
 
        DO   US_IX =  SCAN_ARRAY_ELEMENT.BEG_POS
               TO    (SCAN_ARRAY_ELEMENT.END_POS - US_LN + 1);
          IF GCOMPARE(SUBSTR(ENTRY_LINE_DATA,US_IX,US_LN),
                      SCAN_ARRAY_ELEMENT.STRING)
            THEN
              DO;   /*INSERT UNDERSCORES AND ADJUST POSITION INDEX FOR NEXT ATTEMPT*/
                SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
                US_IX = US_IX + US_LN - 1;
              END;
        END;
     END UNDERLINE_STRING_EQGSCN;
    %PAGE;
     UNDERLINE_STRING_NESCAN:
     UNDERLINE_STRING_NEGSCN:
     PROC;  /*FOR A SUCCESSFULL "^EQSCAN" OR "^EQGSCN" THAT SCANNED POSITIONS   */
            /*IN THE LISTING LINE WITHOUT FINDING THE SEARCH STRING, UNDERSCORE */
            /*THE SEARCH AREA UNLESS IT IS THE ENTIRE LINE.                     */
 
        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/
             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/
 
        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;
        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
 
        IF (US_IX > LIST_LINE_DBGN) | (US_LN < LIST_LINE_SIZE) /*IF AREA NOT ENTIRE LINE*/
          THEN SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
 
     END UNDERLINE_STRING_NESCAN;
    %PAGE;
     UNDERLINE_STRING_OKCMPR:
     UNDERLINE_STRING_OKGCPR:
     PROC;  /*FOR A COMPARE THAT WAS SUCCESSFUL, UNDERLINE THE STRING           */
            /*THAT COMPARED SUCCESSFULLY.  ONLY THE ONE OCCURRENCE              */
            /*IS UNDERSCORED.                                                   */
 
        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/
             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/
 
        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;
        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
 
        SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
 
     END UNDERLINE_STRING_OKCMPR;
    %SKIP(3);
     UNDERLINE_STRING_OKLINE:
     UNDERLINE_STRING_OKGLIN:
     PROC;  /*FOR A SUCCESSFULL LINE TYPE COMPARISON, UNDERLINE THE LINE TYPE   */
            /*FIELD IN THE LISTING LINE UNLESS THE FIELD IS ALL BLANK.          */
 
        DCL  US_IX               FIXED BIN(15,0),   /*UNDERSCORE POSITION INDEX*/
             US_PS               FIXED BIN(15,0),   /*UNDERSCORE POSITION LENGTH*/
             US_LN               FIXED BIN(15,0);   /*UNDERSCORE STRING   LENGTH*/
 
        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;
        US_PS      =  SCAN_ARRAY_ELEMENT.POS_LEN;
        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
 
        IF     SUBSTR(ENTRY_LINE_DATA,US_IX,US_PS) ^= ' ' /*IF LINETYPE FIELD NON-BLANK*/
          THEN SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
 
     END UNDERLINE_STRING_OKLINE;
    %SKIP(1);
     END UNDERLINE_STRING_OP;
    %SKIP(2);
  END SMPLIST_ENTRY_LINE_UNDRLINE;
 %PAGE;
  SMPSCAN_ENTRY_LINE_WRITE:      /********************************************************/
                                 /*                                                      */
                                 /*                                                      */
                                 /********************************************************/
  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */
     DCL   SAVE_PAGE_NO          FIXED BINARY(31,0);
 
     IF    ^(SMPSCAN(IFILE).OPEN)     THEN CALL SMPSCAN_OPEN;
     ON    ENDPAGE(SMPSCAN(IFILE).FILEREF) CALL SMPSCAN_NEWPAGE;
 
     IF       ILINE <= 001
 
       THEN                            /*IF THIS IS THE FIRST LINE OF A NEW ENTRY*/
         IF   (SMPSCAN(IFILE).CURR_PAGE.PAGE_NO  <  0001)
           |  (SMPSCAN(IFILE).CURR_PAGE.PAGEKEY  ^= SMPLIST(IFILE).CURR_NTRY.PAGEKEY)
 
           THEN           /*IF FIRST PAGE OF OUTPUT, OR FIRST ENTRY OF A NEW TYPE*/
             DO;
               SAVE_PAGE_NO                      =  SMPSCAN(IFILE).CURR_PAGE.PAGE_NO;
               SMPSCAN(IFILE).CURR_PAGE          =  SMPLIST(IFILE).CURR_NTRY  ,  BY NAME;
               SMPSCAN(IFILE).CURR_PAGE.PAGE_NO  =  SAVE_PAGE_NO;
               SIGNAL  ENDPAGE(SMPSCAN(IFILE).FILEREF);
             END;
           ELSE         /*IF NOT FIRST PAGE OF OUTPUT, AND NOT FIRST ENTRY OF A NEW TYPE*/
             IF LINENO(SMPSCAN(IFILE).FILEREF)      <  (SMPSCAN(IFILE).PAGE_SZ - 1)
               THEN
                 PUT FILE(SMPSCAN(IFILE).FILEREF)
                     EDIT(' ')                        (SKIP(1),A);
 
     PUT FILE(SMPSCAN(IFILE).FILEREF)                  SKIP(1)
         EDIT(ENTRY_LINE_DATA)                        (COL(001),A);
 
     IF     ENTRY_LINE_UNDR.PRTCTL = '+'           /*IF A LINE OF UNDERSCORES IS PRESENT*/
       THEN  PUT FILE(SMPSCAN(IFILE).FILEREF)          SKIP(0)
             EDIT(STRING(ENTRY_LINE_UNDR.DATA))       (COL(001),A);
 
     IF       ILINE <= 001             /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,*/
       THEN                            /*SAVE LOCATOR INFORMATION FOR SMPDCTRY.   */
               SMPSCAN(IFILE).CURR_NTRY          =  SMPSCAN(IFILE).CURR_PAGE  ,  BY NAME;
 
     RETURN;                           /*TO THE CALLER OF SMPSCAN_ENTRY_LINE_WRITE*/
     %PAGE;
     SMPSCAN_OPEN:       /***********************************************************/
                         /*THIS SUBROUTINE IS INTERNAL TO SMPSCAN_ENTRY_LINE_WRITE. */
                         /*IT OPENS THE SMPSCAN DATA SET FOR THIS IFILE.            */
                         /***********************************************************/
       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPSCAN_OPEN               */
 
          OPEN   FILE(SMPSCAN(IFILE).FILEREF) OUTPUT
                 PAGESIZE(SMPSCAN(IFILE).PAGE_SZ) LINESIZE(SMPSCAN(IFILE).LINE_SZ)
                 TITLE(SMPSCAN(IFILE).DDNAME);
 
          SMPSCAN(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/
 
       END SMPSCAN_OPEN;
     %SKIP(3);
     SMPSCAN_NEWPAGE:
       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSCAN_NEWPAGE*/
 
          SMPSCAN_TITLE1_MAP_ADDR = ADDR(SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA);
 
          IF LINENO(SMPSCAN(IFILE).FILEREF) > 1 THEN PUT FILE(SMPSCAN(IFILE).FILEREF) PAGE;
          SMPSCAN(IFILE).CURR_PAGE.PAGE_NO = SMPSCAN(IFILE).CURR_PAGE.PAGE_NO + 1;
 
          SMPSCAN_TITLE1_MAP.ESMPLIST =  'SMPSCAN';
          SMPSCAN_TITLE1_MAP.PAGE_NO  =  SMPSCAN(IFILE).CURR_PAGE.PAGE_NO;
 
          PUT FILE(SMPSCAN(IFILE).FILEREF)
              EDIT(SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA)  (COL(001),A)
                  (' ')                                   (SKIP(1),A)
                  (SMPSCAN(IFILE).CURR_PAGE.TITLE2_DATA)  (SKIP(1),A)
                  (' ')                                   (SKIP(1),A)
                  (' ')                                   (SKIP(1),A)
                  (SMPSCAN(IFILE).CURR_PAGE.TITLE3_DATA)  (SKIP(1),A)
                  (' ')                                   (SKIP(1),A);
 
       END SMPSCAN_NEWPAGE;
      %SKIP(3);
  END SMPSCAN_ENTRY_LINE_WRITE;
 %PAGE;
  SMPSOUT_ENTRY_LINE_WRITE:      /********************************************************/
                                 /*                                                      */
                                 /*                                                      */
                                 /********************************************************/
  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */
     DCL   SAVE_PAGE_NO          FIXED BINARY(31,0);
 
     IF    ^(SMPSOUT(IFILE).OPEN)     THEN CALL SMPSOUT_OPEN;
     ON    ENDPAGE(SMPSOUT(IFILE).FILEREF) CALL SMPSOUT_NEWPAGE;
 
     IF       ILINE <= 001
 
       THEN                            /*IF THIS IS THE FIRST LINE OF A NEW ENTRY*/
         IF   (SMPSOUT(IFILE).CURR_PAGE.PAGE_NO  <  0001)
           |  (SMPSOUT(IFILE).CURR_PAGE.PAGEKEY  ^= SMPLIST(IFILE).CURR_NTRY.PAGEKEY)
 
           THEN           /*IF FIRST PAGE OF OUTPUT, OR FIRST ENTRY OF A NEW TYPE*/
             DO;
               SAVE_PAGE_NO                      =  SMPSOUT(IFILE).CURR_PAGE.PAGE_NO;
               SMPSOUT(IFILE).CURR_PAGE          =  SMPLIST(IFILE).CURR_NTRY  ,  BY NAME;
               SMPSOUT(IFILE).CURR_PAGE.PAGE_NO  =  SAVE_PAGE_NO;
               SIGNAL  ENDPAGE(SMPSOUT(IFILE).FILEREF);
             END;
           ELSE         /*IF NOT FIRST PAGE OF OUTPUT, AND NOT FIRST ENTRY OF A NEW TYPE*/
             IF LINENO(SMPSOUT(IFILE).FILEREF)      <  (SMPSOUT(IFILE).PAGE_SZ - 1)
               THEN
                 PUT FILE(SMPSOUT(IFILE).FILEREF)
                     EDIT(' ')                        (SKIP(1),A);
 
     PUT FILE(SMPSOUT(IFILE).FILEREF)                  SKIP(1)
         EDIT(ENTRY_LINE_DATA)                        (COL(001),A);
 
     IF       ILINE <= 001             /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,*/
       THEN                            /*SAVE LOCATOR INFORMATION FOR SMPDCTRY.   */
               SMPSOUT(IFILE).CURR_NTRY          =  SMPSOUT(IFILE).CURR_PAGE  ,  BY NAME;
 
     RETURN;                           /*TO THE CALLER OF SMPSOUT_ENTRY_LINE_WRITE*/
     %PAGE;
     SMPSOUT_OPEN:       /***********************************************************/
                         /*THIS SUBROUTINE IS INTERNAL TO SMPSOUT_ENTRY_LINE_WRITE. */
                         /*IT OPENS THE SMPSOUT DATA SET FOR THIS IFILE.            */
                         /***********************************************************/
       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPSOUT_OPEN               */
 
          OPEN   FILE(SMPSOUT(IFILE).FILEREF) OUTPUT
                 PAGESIZE(SMPSOUT(IFILE).PAGE_SZ) LINESIZE(SMPSOUT(IFILE).LINE_SZ)
                 TITLE(SMPSOUT(IFILE).DDNAME);
 
          SMPSOUT(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/
 
       END SMPSOUT_OPEN;
     %SKIP(3);
     SMPSOUT_NEWPAGE:
       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSOUT_NEWPAGE*/
 
          SMPSOUT_TITLE1_MAP_ADDR = ADDR(SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA);
 
          IF LINENO(SMPSOUT(IFILE).FILEREF) > 1 THEN PUT FILE(SMPSOUT(IFILE).FILEREF) PAGE;
          SMPSOUT(IFILE).CURR_PAGE.PAGE_NO = SMPSOUT(IFILE).CURR_PAGE.PAGE_NO + 1;
 
          SMPSOUT_TITLE1_MAP.PAGE_NO  =  SMPSOUT(IFILE).CURR_PAGE.PAGE_NO;
 
          PUT FILE(SMPSOUT(IFILE).FILEREF)
              EDIT(SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA)  (COL(001),A)
                  (' ')                                   (SKIP(1),A)
                  (SMPSOUT(IFILE).CURR_PAGE.TITLE2_DATA)  (SKIP(1),A)
                  (' ')                                   (SKIP(1),A)
                  (' ')                                   (SKIP(1),A)
                  (SMPSOUT(IFILE).CURR_PAGE.TITLE3_DATA)  (SKIP(1),A)
                  (' ')                                   (SKIP(1),A);
 
       END SMPSOUT_NEWPAGE;
      %SKIP(3);
  END SMPSOUT_ENTRY_LINE_WRITE;
 %PAGE;
  SMPDATA_ENTRY_LINE_WRITE:      /********************************************************/
                                 /*                                                      */
                                 /*                                                      */
                                 /********************************************************/
  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */
 
     IF    ^(SMPDATA(IFILE).OPEN)     THEN CALL SMPDATA_OPEN;
 
     IF   (DATA_OUTPUT_OPTION(IFILE) = 'ID1'    &  ILINE = 001)   /*IF LINE TO BE WRITTEN*/
        | (DATA_OUTPUT_OPTION(IFILE) = 'ID'     &  ILINE = 001)
        | (DATA_OUTPUT_OPTION(IFILE) = 'SELECT' & (ILINE = 001 | ENTRY_LINE_SELECT))
        | (DATA_OUTPUT_OPTION(IFILE) = 'ALL')
 
       THEN           /*FORMAT THE LINE BASED ON TYPE OF ENTRY, AND LINETYPE WITHIN ENTRY*/
 
         SELECT(ENTRY_NTRYINDX);     /*DETERMINE FORMATTING BY TYPE OF ENTRY AND LINETYPE*/
 
           WHEN(ENTRY_INDEX('ASSEM'))             /*ENTRY TYPE = ASSEMBLER*/
             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,015));
               WHEN('ASSEMBLER INPUT')        CALL WRITE_DATA_FORMAT2_LINE;
               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;
             END;               /*END OF ASSEM      ENTRY_LINE_LINETYPE SELECT GROUP*/
 
           WHEN(ENTRY_INDEX('LMOD'))              /*ENTRY TYPE = LOAD MODULE*/
             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,012));
               WHEN('LKED CONTROL')           CALL WRITE_DATA_FORMAT2_LINE;
               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;
             END;               /*END OF LMOD       ENTRY_LINE_LINETYPE SELECT GROUP*/
 
           WHEN(ENTRY_INDEX('SYSMOD'))            /*ENTRY TYPE = SYSMOD*/
             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,004));
               WHEN('HOLD')                   CALL WRITE_DATA_FORMAT3_LINE;
               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;
             END;               /*END OF SYSMOD     ENTRY_LINE_LINETYPE SELECT GROUP*/
 
           WHEN(ENTRY_INDEX('M.C.S.'))            /*ENTRY TYPE = M.C.S.*/
                                              CALL WRITE_DATA_FORMAT2_LINE;
 
           OTHERWISE                              /*ENTRY TYPE = ALL OTHERS*/
             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,015));
               WHEN('SYSMOD HISTORY')         CALL WRITE_DATA_FORMAT4_LINE;
               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;
             END;               /*END OF OTHERWISE  ENTRY_LINE_LINETYPE SELECT GROUP*/
 
         END;                   /*END OF ENTRY_NTRYINDX                 SELECT GROUP*/
     RETURN;
     %PAGE;
     SMPDATA_OPEN:       /***********************************************************/
                         /*THIS SUBROUTINE IS INTERNAL TO SMPDATA_ENTRY_LINE_WRITE. */
                         /*IT OPENS THE SMPSOUT DATA SET FOR THIS IFILE.            */
                         /***********************************************************/
       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPDATA_OPEN               */
 
          OPEN   FILE(SMPDATA(IFILE).FILEREF) OUTPUT
                 LINESIZE(SMPDATA(IFILE).LINE_SZ)
                 TITLE(SMPDATA(IFILE).DDNAME);
 
          SMPDATA(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/
 
       END SMPDATA_OPEN;
    %PAGE;
     WRITE_DATA_FORMAT1_LINE:
     PROC;
 
        DCL  LDATA          FIXED BIN(15,0),         /*DATA RECORD # FOR CURRENT LINE*/
             LPOS(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,069,109),
             LGTH(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(068,040,012),
             LCOL(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029,029);
 
        DO   LDATA = 001 TO 003;
          IF    (SUBSTR(ENTRY_LINE_DATA,LPOS(LDATA),LGTH(LDATA))  ^= ' ')
            &  ((DATA_OUTPUT_OPTION(IFILE) ^= 'ID1') | (LDATA = 001))
            THEN
              DO;
                SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(LDATA),LGTH(LDATA)) =
                                          SUBSTR(ENTRY_LINE_DATA,LPOS(LDATA),LGTH(LDATA));
 
                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';
                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
 
                SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
 
                PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
                    EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
                        (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
 
                IF   ((LDATA = 001) & (ILINE = 001))
                  THEN
                         SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;
 
              END;
        END;                    /*END OF LDATA DO GROUP*/
 
     END WRITE_DATA_FORMAT1_LINE;
    %PAGE;
     WRITE_DATA_FORMAT2_LINE:
     PROC;
 
        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029),
             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(028,072),
             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,001);
 
        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  ^= ' ')
          THEN
            DO;
              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =
                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));
 
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
 
              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
 
              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
 
              IF      (ILINE = 001)
                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;
 
            END;
 
        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  ^= ' ')
            &   (DATA_OUTPUT_OPTION(IFILE) ^= 'ID1')
          THEN
            DO;
              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =
                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));
 
              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
 
              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
 
            END;
 
     END WRITE_DATA_FORMAT2_LINE;
    %PAGE;
     WRITE_DATA_FORMAT3_LINE:
     PROC;
 
        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,039),
             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(038,072),
             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,001);
 
        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  ^= ' ')
          THEN
            DO;
              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =
                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));
 
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
 
              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
 
              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
 
              IF      (ILINE = 001)
                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;
 
            END;
 
        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  ^= ' ')
            &   (DATA_OUTPUT_OPTION(IFILE) ^= 'ID1')
          THEN
            DO;
              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =
                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));
 
              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
 
              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
 
            END;
 
     END WRITE_DATA_FORMAT3_LINE;
    %PAGE;
     WRITE_DATA_FORMAT4_LINE:
     PROC;
 
        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029),
             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(028,065),
             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,004);
 
        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  ^= ' ')
          THEN
            DO;
              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =
                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));
 
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
 
              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
 
              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
 
              IF      (ILINE = 001)
                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;
 
            END;
 
        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  ^= ' ')
            &   (DATA_OUTPUT_OPTION(IFILE) ^= 'ID1')
          THEN
            DO;
              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =
                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));
 
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,002,002)  = '/*';
              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
 
              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
 
              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
 
            END;
 
     END WRITE_DATA_FORMAT4_LINE;
    %SKIP (1);
  END SMPDATA_ENTRY_LINE_WRITE;
  %SKIP(2);
  END SMPLIST_ENTRY_WRITE;
 %PAGE;
  SMPLIST_SCAN_LINE_DATA:     /********************************************************/
                              /*SCAN THE CURRENT LINE AND RETURN ROW RESULTS.         */
                              /*THIS SUBROUTINE IS CALLED FROM BOTH                   */
                              /*SMPLIST_ENTRY_LINE_SCAN IN SMPLIST_ENTRY_READ, AND    */
                              /*SMPLIST_ENTRY_LINE_UNDRLINE IN SMPLIST_ENTRY_WRITE.   */
                              /********************************************************/
  PROC(ENTRY_NTRYINDX,            /*IFILE, IPLANE, IROW ARE SET PRIOR TO ENTRY.       */
       ENTRY_LINE_LINETYPE,
       ENTRY_LINE_DATA)             RETURNS(BIT(01));
     DCL    ENTRY_NTRYINDX          FIXED BIN(15,0),
            ENTRY_LINE_LINETYPE     CHAR(*),
            ENTRY_LINE_DATA         CHAR(*),
         01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)
                                     LIKE SCAN_ARRAY.PLANE.ROW.COL,
            LINE_SCAN_RESULT        BIT(1);
    %PAGE;
     IF   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE
       THEN
         DO;                 /*ALL ACTIVE COLUMNS IN A ROW MUST MATCH ON THE SAME LINE*/
             LINE_SCAN_RESULT = '1'B;
             DO    ICOL  = ICOL_MIN   TO ICOL_MAX   WHILE(LINE_SCAN_RESULT);
               SCAN_ARRAY_ELEMENT_ADDR
                   = ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));
               IF (SCAN_ARRAY_ELEMENT.STR_LEN > 0)                 /*IF STRING SUPPLIED*/
                 THEN
                   SELECT(SCAN_ARRAY_ELEMENT.OP_OIX);
                     WHEN(12) /* EQENTRY */   LINE_SCAN_RESULT =  RESULT_STRING_NTRY;
                     WHEN(13) /* NEENTRY */   LINE_SCAN_RESULT = ^RESULT_STRING_NTRY;
 
                     WHEN(22) /* EQLINE  */   LINE_SCAN_RESULT =  RESULT_STRING_LINE;
                     WHEN(23) /* NELINE  */   LINE_SCAN_RESULT = ^RESULT_STRING_LINE;
 
                     WHEN(32) /* EQGLINE */   LINE_SCAN_RESULT =  RESULT_STRING_GLIN;
                     WHEN(33) /* NEGLINE */   LINE_SCAN_RESULT = ^RESULT_STRING_GLIN;
 
                     WHEN(42) /* EQSCAN  */   LINE_SCAN_RESULT = (RESULT_STRING_SCAN >  0);
                     WHEN(43) /* NESCAN  */   LINE_SCAN_RESULT = (RESULT_STRING_SCAN <= 0);
 
                     WHEN(52) /* EQGSCAN */   LINE_SCAN_RESULT = (RESULT_STRING_GSCN >  0);
                     WHEN(53) /* NEGSCAN */   LINE_SCAN_RESULT = (RESULT_STRING_GSCN <= 0);
 
                     WHEN(60) /* LTCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR <  0);
                     WHEN(61) /* LECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR <= 0);
                     WHEN(62) /* EQCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR =  0);
                     WHEN(63) /* NECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR ^= 0);
                     WHEN(64) /* GECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR >= 0);
                     WHEN(65) /* GTCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR >  0);
 
                     WHEN(72) /* EQGCMPR */   LINE_SCAN_RESULT =  RESULT_STRING_GCPR;
                     WHEN(73) /* NEGCMPR */   LINE_SCAN_RESULT = ^RESULT_STRING_GCPR;
                   END;    /*END OF SELECT GROUP ON SCAN_ARRAY_ELEMENT.OP_OIX*/
             END;          /*END OF ICOL   DO GROUP*/
         END;            /*END OF ACTIVE IROW DO GROUP*/
       ELSE  LINE_SCAN_RESULT = '0'B;
     RETURN (LINE_SCAN_RESULT);               /*TO THE CALLER OF SCAN_ENTRY_LINE*/
    %PAGE;
     RESULT_STRING_NTRY:
     PROC RETURNS(BIT(1));
            /*COMPARE THE ENTRY TYPE FOR THE CURRENT ENTRY                      */
            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */
            /*INDICATING THE RESULT OF THE COMPARE:                             */
 
        IF  (ENTRY_NTRYINDX = SCAN_ARRAY_ELEMENT.STR_NIX)
 
          THEN RETURN('1'B);                /*SAME ENTRY TYPE*/
          ELSE RETURN('0'B);                /*DIFF ENTRY TYPE*/
 
     END RESULT_STRING_NTRY;
    %SKIP(2);
     RESULT_STRING_LINE:
     PROC RETURNS(BIT(1));
            /*COMPARE THE LINE TYPE FOR THE CURRENT LINE                        */
            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */
            /*INDICATING THE RESULT OF THE COMPARE:                             */
 
        IF     SUBSTR(ENTRY_LINE_LINETYPE,001,SCAN_ARRAY_ELEMENT.STR_LEN)
           =   SCAN_ARRAY_ELEMENT.STRING
 
          THEN RETURN('1'B);                /*SAME LINE TYPE*/
          ELSE RETURN('0'B);                /*DIFF LINE TYPE*/
 
     END RESULT_STRING_LINE;
    %SKIP(2);
     RESULT_STRING_GLIN:
     PROC RETURNS(BIT(1));
            /*COMPARE THE LINE TYPE FOR THE CURRENT LINE                        */
            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */
            /*INDICATING THE RESULT OF THE GENERIC COMPARE:                     */
            /*                      1: GENERIC COMPARE SUCCESSFUL               */
            /*                      0: GENERIC COMPARE UNSUCCESSFUL             */
 
        RETURN(GCOMPARE(SUBSTR(ENTRY_LINE_LINETYPE,
                               001,
                               SCAN_ARRAY_ELEMENT.STR_LEN
                              ),
                        SCAN_ARRAY_ELEMENT.STRING
                       )
              );
 
     END RESULT_STRING_GLIN;
    %PAGE;
     RESULT_STRING_SCAN:
     PROC RETURNS(FIXED BIN(15,0));
            /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS         */
            /*FOR THE SEARCH STRING AND RETURN THE STRING LOCATION (1ST OCCURRENCE)*/
            /*RELATIVE TO THE BEGINNING OF THE LINE:                               */
 
        DCL STRING_INDEX            FIXED BIN(15,0);
 
        STRING_INDEX = INDEX(SUBSTR(ENTRY_LINE_DATA,
                                    SCAN_ARRAY_ELEMENT.BEG_POS,
                                    SCAN_ARRAY_ELEMENT.POS_LEN
                                   ),
                             SCAN_ARRAY_ELEMENT.STRING
                            );
 
        IF     STRING_INDEX > 0            /*ADJUST VALUE TO THE BEGINNING OF THE LINE*/
          THEN
               STRING_INDEX = STRING_INDEX + SCAN_ARRAY_ELEMENT.BEG_POS - 1;
        RETURN(STRING_INDEX);
 
     END RESULT_STRING_SCAN;
    %SKIP(2);
     RESULT_STRING_GSCN:
     PROC RETURNS(FIXED BIN(15,0));
            /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS         */
            /*FOR THE SEARCH STRING AND RETURN THE STRING LOCATION (1ST OCCURRENCE)*/
            /*RELATIVE TO THE BEGINNING OF THE LINE:                               */
 
        DCL STRING_INDEX         FIXED BIN(15,0),
            GS_IX                FIXED BIN(15,0),  /*GENERIC SCAN POSITION INDEX*/
            GS_LN                FIXED BIN(15,0);  /*GENERIC SCAN STRING  LENGTH*/
 
        STRING_INDEX  = 0;
        GS_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
 
        DO   GS_IX =  SCAN_ARRAY_ELEMENT.BEG_POS
               TO    (SCAN_ARRAY_ELEMENT.END_POS - GS_LN + 1)
                WHILE(STRING_INDEX=0);
 
          IF GCOMPARE(SUBSTR(ENTRY_LINE_DATA,GS_IX,GS_LN),
                      SCAN_ARRAY_ELEMENT.STRING)
 
            THEN      STRING_INDEX  =  GS_IX;
        END;
 
        RETURN(STRING_INDEX);
 
     END RESULT_STRING_GSCN;
    %PAGE;
     RESULT_STRING_CMPR:
     PROC RETURNS(FIXED BIN(15,0));
            /*COMPARE THE INPUT LINE STARTING AT THE BEGIN POSITION             */
            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BINARY       */
            /*FIXED POINT VALUE INDICATING THE RESULT OF THE COMPARE:           */
            /*                     -1: INPUT LINE DATA < STRING                 */
            /*                      0: INPUT LINE DATA = STRING                 */
            /*                     +1: INPUT LINE DATA > STRING                 */
 
        IF          SUBSTR(ENTRY_LINE_DATA,
                           SCAN_ARRAY_ELEMENT.BEG_POS,
                           SCAN_ARRAY_ELEMENT.STR_LEN
                          )
                 <  SCAN_ARRAY_ELEMENT.STRING
          THEN             RETURN(-1);                            /*LESS THAN*/
          ELSE IF   SUBSTR(ENTRY_LINE_DATA,
                           SCAN_ARRAY_ELEMENT.BEG_POS,
                           SCAN_ARRAY_ELEMENT.STR_LEN
                          )
                 =  SCAN_ARRAY_ELEMENT.STRING
                 THEN      RETURN(0);                             /*EQUAL TO*/
                 ELSE      RETURN(+1);                            /*GREATER THAN*/
 
     END RESULT_STRING_CMPR;
    %SKIP(3);
     RESULT_STRING_GCPR:
     PROC RETURNS(BIT(1));
            /*COMPARE THE INPUT LINE STARTING AT THE BEGIN POSITION             */
            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */
            /*INDICATING THE RESULT OF THE GENERIC COMPARE:                     */
            /*                      1: GENERIC COMPARE SUCCESSFUL               */
            /*                      0: GENERIC COMPARE UNSUCCESSFUL             */
 
        RETURN(GCOMPARE(SUBSTR(ENTRY_LINE_DATA,
                               SCAN_ARRAY_ELEMENT.BEG_POS,
                               SCAN_ARRAY_ELEMENT.STR_LEN
                              ),
                        SCAN_ARRAY_ELEMENT.STRING
                       )
              );
 
     END RESULT_STRING_GCPR;
    %SKIP(3);
  END SMPLIST_SCAN_LINE_DATA;
 %PAGE;
 SMPLIST_WRAPUP:           /*************************************************************/
                           /*   PERFORM FINAL INPUT FILE PROCESSING,                    */
                           /*   AND CALCULATE VALUES FOR FINAL TOTALS.                  */
                           /*************************************************************/
  PROC;
     DO    IFILE = IFILE_MIN TO IFILE_MAX;
       IF (SMPLIST(IFILE).ACTIVE)             /*IF THE INPUT FILE WAS ACTIVE*/
         THEN
           DO;
             DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;
               IF (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT >  0)
                 THEN  SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND =
                                      SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND + 1;
             END;     /*END OF NTRYINDX_IX DO GROUP*/
           END;       /*END OF IFILE       DO GROUP*/
     END;
     RETURN;                      /*TO THE CALLER OF SMPLIST_WRAPUP*/
  END SMPLIST_WRAPUP;
 %PAGE;
 SMPLIST_CLOSE:            /*************************************************************/
                           /*   PERFORM FINAL INPUT FILE PROCESSING,                    */
                           /*   AND CLOSE THE SMPLIST DATA SET(S).                      */
                           /*************************************************************/
  PROC;
     DO    IFILE = IFILE_MIN TO IFILE_MAX;
       IF (SMPLIST(IFILE).ACTIVE)             /*IF THE INPUT FILE WAS ACTIVE*/
         THEN
           DO;
             CLOSE FILE(SMPLIST(IFILE).FILEREF) ENV(LEAVE);
             IF  SMPSCAN(IFILE).OPEN THEN CALL SMPSCAN_CLOSE;
             IF  SMPSOUT(IFILE).OPEN THEN CALL SMPSOUT_CLOSE;
             IF  SMPDATA(IFILE).OPEN THEN CALL SMPDATA_CLOSE;
           END;
     END;
     RETURN;                      /*TO THE CALLER OF SMPLIST_CLOSE*/
     %SKIP(2);
     SMPSCAN_CLOSE:
       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSCAN_CLOSE*/
          CLOSE  FILE(SMPSCAN(IFILE).FILEREF) ENV(LEAVE);
          SMPSCAN(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/
       END SMPSCAN_CLOSE;
     %SKIP(2);
     SMPSOUT_CLOSE:
       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSOUT_CLOSE*/
          CLOSE  FILE(SMPSOUT(IFILE).FILEREF) ENV(LEAVE);
          SMPSOUT(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/
       END SMPSOUT_CLOSE;
     %SKIP(2);
     SMPDATA_CLOSE:
       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPDATA_CLOSE*/
          CLOSE  FILE(SMPDATA(IFILE).FILEREF) ENV(LEAVE);
          SMPDATA(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/
       END SMPDATA_CLOSE;
  %SKIP(5);
  END SMPLIST_CLOSE;
 %PAGE;
 ZONE_INDEX:  /*FUNCTION SUBROUTINE TO MAP THE TYPE OF ZONE TO                    */
              /*A BINARY SUBSCRIPT THAT CAN BE SORTED TO PRODUCE                  */
              /*THE ORDER:  GLOBAL < DLIB < TARGET.                               */
    PROC(ZONETYPE)                    /*RECEIVES THE ZONE TYPE IN EBCDIC          */
        RETURNS(FIXED BINARY(15,0));  /*RETURNS A BINARY NUMERIC VALUE:           */
        DCL  ZONETYPE CHAR(*);
        SELECT(TRIM(ZONETYPE));
           WHEN('GLOBAL')               RETURN(1);   /*GLOBAL  ZONE               */
           WHEN('DLIB')                 RETURN(2);   /*DLIB    ZONE               */
           WHEN('TARGET')               RETURN(3);   /*TARGET  ZONE               */
           OTHERWISE                    RETURN(0);   /*UNKNOWN ZONE TYPE          */
        END;
    END ZONE_INDEX;
 %SKIP(3);
 ZONE_TYPE:   /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                 */
              /*"ZONE_INDEX" FUNCTION AND RETURN THE ZONE TYPE NAME               */
              /*CORRESPONDING TO THE ZONE INDEX SUBSCRIPT.                        */
    PROC(ZONEINDX)                    /*RECEIVES THE ZONE INDEX IN BINARY         */
        RETURNS(CHAR(007) VAR);       /*RETURNS A CHARACTER STRING VALUE:         */
        DCL    ZONEINDX        FIXED BINARY(15,0);
        SELECT(ZONEINDX);
           WHEN(0)             RETURN('UNKNOWN');    /*UNKNOWN ZONE INDEX         */
           WHEN(1)             RETURN('GLOBAL');     /*GLOBAL  ZONE INDEX         */
           WHEN(2)             RETURN('DLIB');       /*DLIB    ZONE INDEX         */
           WHEN(3)             RETURN('TARGET');     /*TARGET  ZONE INDEX         */
           OTHERWISE           RETURN('INVALID');    /*INVALID ZONE INDEX         */
        END;
    END ZONE_TYPE;
 %SKIP(3);
 ZONE_TYPE_C: /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                 */
              /*"ZONE_INDEX" FUNCTION AND RETURN A ONE-CHARACTER ZONE TYPE        */
              /*CORRESPONDING TO THE ZONE INDEX SUBSCRIPT.                        */
    PROC(ZONEINDX)                    /*RECEIVES THE ZONE INDEX IN BINARY         */
        RETURNS(CHAR(001));           /*RETURNS A ONE_BYTE CHARACTER VALUE:       */
        DCL    ZONEINDX        FIXED BINARY(15,0);
        SELECT(ZONEINDX);
           WHEN(0)             RETURN('U');          /*UNKNOWN ZONE INDEX         */
           WHEN(1)             RETURN('G');          /*GLOBAL  ZONE INDEX         */
           WHEN(2)             RETURN('D');          /*DLIB    ZONE INDEX         */
           WHEN(3)             RETURN('T');          /*TARGET  ZONE INDEX         */
           OTHERWISE           RETURN('?');          /*INVALID ZONE INDEX         */
        END;
    END ZONE_TYPE_C;
 %PAGE;
 ENTRY_INDEX:  /*FUNCTION SUBROUTINE TO MAP THE LISTED ENTRY TYPE TO              */
               /*A BINARY SUBSCRIPT THAT IS IN ASCENDING ORDER                    */
               /*CORRESPONDING TO THE ORDER THAT ENTRIES ARE LISTED               */
               /*ON THE SMPLIST REPORT PRODUCED BY SMP/E.                         */
    PROC(NTRYTYPE)                    /*RECEIVES THE ENTRY TYPE IN EBCDIC         */
        RETURNS(FIXED BINARY(15,0));  /*RETURNS A BINARY NUMERIC VALUE:           */
 
        DCL  NTRYTYPE          CHAR(*) VAR;
 
        SELECT(ENTRY_TYPE_TRIM(NTRYTYPE));
           WHEN('ZONE','GZONE','DZONE','TZONE')  RETURN(01);  /*ZONE     ENTRY    */
           WHEN('OPTIONS')                       RETURN(02);  /*OPTIONS  ENTRY    */
           WHEN('UTILITY')                       RETURN(03);  /*UTILITY  ENTRY    */
           WHEN('FMIDSET')                       RETURN(04);  /*FMIDSET  ENTRY    */
           WHEN('DDDEF')                         RETURN(05);  /*DDDEF    ENTRY    */
           WHEN('ZONESET')                       RETURN(06);  /*ZONESET  ENTRY    */
           WHEN('ASSEM','ASSEMBLER')             RETURN(07);  /*ASSEM    ENTRY    */
           WHEN('LMOD','LOAD MODULE')            RETURN(08);  /*LMOD     ENTRY    */
           WHEN('MAC','MACRO')                   RETURN(09);  /*MACRO    ENTRY    */
           WHEN('MOD','MODULE')                  RETURN(10);  /*MODULE   ENTRY    */
           WHEN('SRC','SOURCE')                  RETURN(11);  /*SOURCE   ENTRY    */
           WHEN('DLIB')                          RETURN(12);  /*DLIB     ENTRY    */
           WHEN('SYSMOD','HOLDDATA')             RETURN(13);  /*SYSMOD / HOLDDATA */
           WHEN('M.C.S.')                        RETURN(14);  /*M.C.S.   ENTRY    */
           OTHERWISE                             RETURN(00);  /*UNKNOWN  ENTRY    */
        END;
    END ENTRY_INDEX;
 %PAGE;
 ENTRY_TYPE:   /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                */
               /*"ENTRY_INDEX" FUNCTION AND RETURN THE ENTRY TYPE NAME            */
               /*CORRESPONDING TO THE ENTRY INDEX SUBSCRIPT.                      */
    PROC(NTRYINDX)                    /*RECEIVES THE ENTRY INDEX IN BINARY        */
        RETURNS(CHAR(016) VAR);       /*RETURNS A CHARACTER STRING VALUE:         */
 
        DCL    NTRYINDX         FIXED BINARY(15,0);
 
        SELECT(NTRYINDX);
           WHEN(00)             RETURN('UNKNOWN');         /*UNKNOWN ENTRY INDEX  */
           WHEN(01)             RETURN('ZONE');            /*ZONE    ENTRY INDEX  */
           WHEN(02)             RETURN('OPTIONS');         /*OPTIONS ENTRY INDEX  */
           WHEN(03)             RETURN('UTILITY');         /*UTILITY ENTRY INDEX  */
           WHEN(04)             RETURN('FMIDSET');         /*FMIDSET ENTRY INDEX  */
           WHEN(05)             RETURN('DDDEF');           /*DDDEF   ENTRY INDEX  */
           WHEN(06)             RETURN('ZONESET');         /*ZONESET ENTRY INDEX  */
           WHEN(07)             RETURN('ASSEMBLER');       /*ASSEM   ENTRY INDEX  */
           WHEN(08)             RETURN('LOAD MODULE');     /*LMOD    ENTRY INDEX  */
           WHEN(09)             RETURN('MACRO');           /*MACRO   ENTRY INDEX  */
           WHEN(10)             RETURN('MODULE');          /*MODULE  ENTRY INDEX  */
           WHEN(11)             RETURN('SOURCE');          /*SOURCE  ENTRY INDEX  */
           WHEN(12)             RETURN('DLIB');            /*DLIB    ENTRY INDEX  */
           WHEN(13)             RETURN('SYSMOD');          /*SYSMOD  ENTRY INDEX  */
           WHEN(14)             RETURN('M.C.S.');          /*M.C.S.  ENTRY INDEX  */
           OTHERWISE            RETURN('INVALID');         /*INVALID ENTRY INDEX  */
        END;
    END ENTRY_TYPE;
 %PAGE;
 ENTRY_TYPE_TRIM:   /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS,  */
                    /*AND EXTRANEOUS WORDS FROM AN "ENTRY_TYPE" CHARACTER STRING. */
 
    PROC(NTRYTYPE)                    /*RECEIVES THE ENTRY TYPE IN EBCDIC         */
         RECURSIVE                    /*RETURNS A CHARACTER STRING VALUE          */
         RETURNS(CHAR(064) VARYING);  /*WITH LEADING AND TRAILING BLANKS REMOVED. */
 
       DCL  NTRYTYPE          CHAR(*)   VARYING,
            NTRYTYPE_TRIM     CHAR(064) VARYING;
 
       NTRYTYPE_TRIM  = TRIM(NTRYTYPE);    /*ELIMINATE LEADING AND TRAILING BLANKS*/
 
       IF               LENGTH(NTRYTYPE_TRIM) >  8
                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-8+1) = ' ENTRIES'
         THEN           NTRYTYPE_TRIM
                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-8));
         ELSE
       IF               LENGTH(NTRYTYPE_TRIM) >  6
                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-6+1) = ' ENTRY'
         THEN           NTRYTYPE_TRIM
                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-6));
         ELSE
       IF               LENGTH(NTRYTYPE_TRIM) >  1
                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-1+1) = ':'
         THEN           NTRYTYPE_TRIM
                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-1));
 
       RETURN(NTRYTYPE_TRIM);
 
    END ENTRY_TYPE_TRIM;
 %PAGE;
 LINE_TYPE:    /*FUNCTION SUBROUTINE TO DETERMINE THE LINE TYPE CHARACTER STRING  */
               /*ASSOCIATED WITH THE CURRENT SMPLIST ENTRY LISTING LINE.          */
 
    PROC(PREV_LINETYPE,                 /*STRING FOR PREVIOUS LINETYPE            */
         LINE_DATA)                     /*CURRENT ENTRY LISTING LINE              */
         RETURNS(CHAR(015));            /*RETURNS THE CURRENT LINE'S LINETYPE.    */
 
        DCL (LENGTH,MAX,MIN,SUBSTR,VERIFY)        BUILTIN,
             PREV_LINETYPE           CHAR(*),
             LINE_DATA               CHAR(*),
             LINE_LINETYPE           CHAR(LIST_LINE_LWID),
             VF_IX                   FIXED BINARY(15,0);
 
        LINE_LINETYPE  =  SUBSTR(LINE_DATA,LIST_LINE_LBGN,LIST_LINE_LWID);
 
        VF_IX          =  MIN(VERIFY(LINE_LINETYPE,' '),      /*LOCATE FIRST NON_BLANK*/
                              LENGTH(PREV_LINETYPE) + 1);     /*AND TEST FOR ALL BLANK*/
 
        SELECT;                             /*SELECT TO TEST THE VALUE OF VF_IX*/
          WHEN(VF_IX < 1) LINE_LINETYPE = PREV_LINETYPE; /*LINE_LINETYPE IS  ALL BLANKS*/
          WHEN(VF_IX = 1);                        /*LINE_LINETYPE HAS NO LEADING BLANKS*/
          WHEN(VF_IX > 1) LINE_LINETYPE =         /*LINE_LINETYPE HAS    LEADING BLANKS*/
                                   SUBSTR(PREV_LINETYPE,1,VF_IX-1)     /*MERGE PREVIOUS*/
                                || SUBSTR(LINE_LINETYPE,VF_IX);        /*WITH  CURRENT */
        END;                                /*END OF VF_IX SELECT GROUP*/
 
        RETURN(LINE_LINETYPE);              /*NEW LINETYPE VALUE TO THE CALLER*/
 
    END LINE_TYPE;
 %PAGE;
 GCOMPARE:    /****************************************************************************/
              /*FUNCTION SUBROUTINE TO GENERICALLY COMPARE A CHARACTER STRING AGAINST     */
              /*A PATTERN STRING AND RETURN THE RESULT AS A BIT STRING:                   */
              /*EQUAL('1'B) OR NOT-EQUAL('0'B).                                           */
              /*                                                                          */
              /*THE CHARACTER STRING IS COMPARED CHARACTER BY CHARACTER WITH THE PATTERN  */
              /*STRING, MOVING FROM LEFT TO RIGHT.  THE FIRST CHARACTER STRING CHARACTER  */
              /*NOT SATISFYING THE REQUIREMENTS OF ITS CORRESPONDING PATTERN STRING       */
              /*CHARACTER STOPS THE COMPARISON AND RESULTS IN A NOT-EQUAL RESULT BEING    */
              /*RETURNED.  A CHARACTER STRING LONGER THAN THE PATTERN STRING IS CHECKED   */
              /*TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT BEYOND THE LENGTH OF THE  */
              /*PATTERN STRING ARE BLANK.  A PATTERN STRING LONGER THAN THE CHARACTER     */
              /*STRING IS ALSO CHECKED TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT    */
              /*BEYOND THE LENGTH OF THE CHARACTER STRING ARE EITHER BLANK, OR THE "ANY"  */
              /*CHARACTER SELECTION BYTE("*").                                            */
              /*                                                                          */
              /*THE FOLLOWING CHARACTERS HAVE SPECIAL SIGNIFICANCE IN PATTERN STRINGS,    */
              /*AND ARE USED TO SELECT CLASSES OF CHARACTERS:                             */
              /*            "*" - THE CORRESPONDING CHARACTER STRING CHARACTER CAN BE     */
              /*                  ANY CHARACTER.                                          */
              /*                                                                          */
              /*            "#" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  NUMERIC AND CAN BE EITHER UPPER OR LOWER CASE.          */
              /*                                                                          */
              /*            "@" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  ALPHABETIC AND CAN BE EITHER UPPER OR LOWER CASE.       */
              /*                                                                          */
              /*            "[" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  ONE OF THE NATIONAL CHARACTERS: "$", "#", OR "@".       */
              /*                  BECAUSE OF THEIR BIT REPRESENTATIONS, NATIONAL          */
              /*                  CHARACTERS ARE UPPERCASE.                               */
              /*                                                                          */
              /*            "%" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  ALPHABETIC OR ONE OF THE NATIONAL CHARACTERS.           */
              /*                                                                          */
              /*            "_" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  ALPHABETIC, NUMERIC,  OR ONE OF THE NATIONAL CHARACTERS.*/
              /*                                                                          */
              /*            ">" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  ONE OF THE NATIONAL CHARACTERS, OR AN UPPERCASE         */
              /*                  ALPHABETIC OR NUMERIC CHARACTER.                        */
              /*                                                                          */
              /*            "<" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  A LOWERCASE ALPHABETIC OR NUMERIC CHARACTER.            */
              /*                                                                          */
              /*            "!" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  ONE OF THE SPECIAL CHARACTERS.                          */
              /*                                                                          */
              /*            "-" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  NON-NUMERIC.                                            */
              /*                                                                          */
              /*            "^" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  NON-BLANK.                                              */
              /*                                                                          */
              /*            "?" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
              /*                  ONE OF THE INVALID CHARACTERS.                          */
              /*                                                                          */
              /*ALL OTHER CHARACTERS IN A PATTERN STRING (BLANKS, ALPHABETICS, NUMERIC    */
              /*DIGITS, AND ESPECIALLY THE CHARACTERS "=" "." "," ":" "$" "(" AND ")" )   */
              /*REPRESENT THEMSELVES.  THE CORRESPONDING CHARACTER STRING CHARACTER MUST  */
              /*BE THE SAME AS THE PATTERN CHARACTER.  EVERY ATTEMPT WAS MADE TO CHOOSE   */
              /*GENERIC SELECTION CHARACTERS THAT WOULD BE UNLIKELY TO APPEAR IN THE      */
              /*DATA EXCEPT WHERE TRADITION STRONGLY DICTATED OTHERWISE.                  */
              /****************************************************************************/
 
    PROC(C_STRING,                  /*CHARACTER STRING TO BE COMPARED                     */
         P_STRING)                  /*PATTERN (GENERIC) CHARACTER STRING                  */
         RETURNS(BIT(01));          /*RETURNS EQUAL/NOT EQUAL INDICATOR                   */
 
        DCL (LENGTH,MAX,MIN,SIGN,SUBSTR,VERIFY)     BUILTIN,
             C_STRING                  CHAR(*),            /*CHARACTER STRING PARAMETER   */
             CS_IX                     FIXED BINARY(15,0), /*CHARACTER STRING INDEX VALUE */
             CS_CH                     CHAR(001),          /*CHARACTER STRING CHARACTER   */
             CS_CX                     FIXED BINARY(15,0), /*CHAR STRING CHAR BINARY VALUE*/
             CS_LN                     FIXED BINARY(15,0), /*CHARACTER STRING LENGTH      */
 
             P_STRING                  CHAR(*) VARYING,    /*PATTERN STRING PARAMETER     */
             PS_LN                     FIXED BINARY(15,0), /*PATTERN STRING LENGTH        */
 
             G_RESULT                  BIT(01);
       %SKIP(2);
        DCL     CH_TYPE_ADDR           POINTER;   /*DEFINE CH_TABLE BIT MEANINGS*/
        DCL  01 CH_TYPE                BASED(CH_TYPE_ADDR),
                05 INVALID             UNALIGNED     BIT(01),   /*BIT 0*/
                05 UPCASE              UNALIGNED     BIT(01),   /*BIT 1*/
                05 BIT2  /*RESERVED*/  UNALIGNED     BIT(01),   /*BIT 2*/
                05 SPECIAL             UNALIGNED     BIT(01),   /*BIT 3*/
                05 NATIONAL            UNALIGNED     BIT(01),   /*BIT 4*/
                05 ALPHABETIC          UNALIGNED     BIT(01),   /*BIT 5*/
                05 Z_NUM               UNALIGNED     BIT(01),   /*BIT 6*/
                05 NUMERIC             UNALIGNED     BIT(01);   /*BIT 7*/
       %SKIP(2);
        CS_LN = LENGTH(C_STRING);
        PS_LN = LENGTH(P_STRING);
        G_RESULT = '1'B;                               /*INITIALIZE FOR ENTERING DO GROUP*/
       %PAGE;
        DO  CS_IX = 001 TO MIN(CS_LN,PS_LN) WHILE(G_RESULT);
 
          CS_CH         =  SUBSTR(C_STRING,CS_IX,001);   /*SELECT CHARACTER FROM C_STRING*/
          UNSPEC(CS_CX) = '00000000'B || UNSPEC(CS_CH);  /*CONVERT CHARACTER TO AN INDEX */
          CH_TYPE_ADDR  =  ADDR(CH_TABLE(CS_CX));        /*-> ENTRY IN CHARACTER TYPE TBL*/
 
          SELECT(SUBSTR(P_STRING,CS_IX,001));     /*CONTROL WITH PATTERN STRING CHARACTER*/
            WHEN('*');                                           /*ANY CHARACTER IS VALID*/
            WHEN('#') IF     ^(CH_TYPE.NUMERIC)                  /*NUMERIC CHARACTER     */
                        THEN   G_RESULT = '0'B;
            WHEN('@') IF     ^(CH_TYPE.ALPHABETIC)               /*ALPHABETIC CHARACTER  */
                        THEN   G_RESULT = '0'B;
            WHEN('[') IF     ^(CH_TYPE.NATIONAL)                  /*NATIONAL CH ($#@)    */
                        THEN   G_RESULT = '0'B;
            WHEN('%') IF     ^(CH_TYPE.NATIONAL | CH_TYPE.ALPHABETIC)
                        THEN   G_RESULT = '0'B;
            WHEN('_') IF     ^(CH_TYPE.NATIONAL | CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC)
                        THEN   G_RESULT = '0'B;
            WHEN('>') IF     ^(CH_TYPE.NATIONAL |
                              (CH_TYPE.UPCASE & (CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC)))
                        THEN   G_RESULT = '0'B;
            WHEN('<') IF    ^(^CH_TYPE.UPCASE & (CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC))
                        THEN   G_RESULT = '0'B;
            WHEN('!') IF     ^(CH_TYPE.SPECIAL)                   /*SPECIAL CHARACTER    */
                        THEN   G_RESULT = '0'B;
            WHEN('-') IF      (CH_TYPE.NUMERIC)                   /*NON-NUMERIC CHARACTER*/
                        THEN   G_RESULT = '0'B;
            WHEN('^') IF      (CS_CH    = ' ')                    /*NON_BLANK CHARACTER  */
                        THEN   G_RESULT = '0'B;
            WHEN('?') IF     ^(CH_TYPE.INVALID)                   /*INVALID CHARACTER    */
                        THEN   G_RESULT = '0'B;
            WHEN(CS_CH);           /*A PATTERN CHARACTER NOT APPEARING IN THE ABOVE LIST,*/
                                                                   /*REPRESENTS ITSELF.  */
            OTHERWISE          G_RESULT = '0'B; /*IF ALL TESTS FAILED, THE COMPARE FAILED*/
          END;                       /*END OF PATTERN CHARACTER SELECT GROUP*/
 
        END;
 
        IF          (G_RESULT) & (CS_LN ^= PS_LN)        /*IF RESULT SO FAR IS SUCCESSFUL*/
          THEN
            IF                   (CS_LN < PS_LN)   /*BASE RESULT ON TAIL OF LONGER STRING*/
               THEN  G_RESULT = (VERIFY(SUBSTR(P_STRING,CS_LN+1),'* ')  <= 0);
               ELSE  G_RESULT = (VERIFY(SUBSTR(C_STRING,PS_LN+1),' ')   <= 0);
          ELSE;
 
        RETURN(G_RESULT);            /*RETURN COMPARISON RESULTS*/
       %PAGE;
        DCL  CH_TABLE(000:255)         BIT(08) ALIGNED  STATIC  INTERNAL
                INIT((01)('10000000'B),                                      /*   X'00'   */
                     (63)('10000000'B),                                      /*X'01'-X'3F'*/
                     (01)('01000000'B),    /*BLANK*/                         /*   X'40'   */
                     (09)('11000000'B),                                      /*X'41'-X'49'*/
                     (01)('01010000'B),    /*  [  */                         /*   X'4A'   */
                     (01)('01010000'B),    /*  .  */                         /*   X'4B'   */
                     (01)('01010000'B),    /*  <  */                         /*   X'4C'   */
                     (01)('01010000'B),    /*  (  */                         /*   X'4D'   */
                     (01)('01010000'B),    /*  +  */                         /*   X'4E'   */
                     (01)('01010000'B),    /*  |  */                         /*   X'4F'   */
                     (01)('01010000'B),    /*  &  */                         /*   X'50'   */
                     (09)('11000000'B),                                      /*X'51'-X'59'*/
                     (01)('01010000'B),    /*  !  */                         /*   X'5A'   */
                     (01)('01001000'B),    /*  $  */                         /*   X'5B'   */
                     (01)('01010000'B),    /*  *  */                         /*   X'5C'   */
                     (01)('01010000'B),    /*  )  */                         /*   X'5D'   */
                     (01)('01010000'B),    /*SEMICOLON*/                     /*   X'5E'   */
                     (01)('01010000'B),    /*  ^  */                         /*   X'5F'   */
                     (01)('01010000'B),    /*  -  */                         /*   X'60'   */
                     (01)('01010000'B),    /*  /  */                         /*   X'61'   */
                     (08)('11000000'B),                                      /*X'62'-X'69'*/
                     (01)('01010000'B),    /*  |  */                         /*   X'6A'   */
                     (01)('01010000'B),    /*  ,  */                         /*   X'6B'   */
                     (01)('01010000'B),    /*  %  */                         /*   X'6C'   */
                     (01)('01010000'B),    /*  _  */                         /*   X'6D'   */
                     (01)('01010000'B),    /*  >  */                         /*   X'6E'   */
                     (01)('01010000'B),    /*  ?  */                         /*   X'6F'   */
                     (09)('11000000'B),                                      /*X'70'-X'78'*/
                     (01)('01010000'B),    /*     */                         /*   X'79'   */
                     (01)('01010000'B),    /*  :  */                         /*   X'7A'   */
                     (01)('01001000'B),    /*  #  */                         /*   X'7B'   */
                     (01)('01001000'B),    /*  @  */                         /*   X'7C'   */
                     (01)('01010000'B),    /*  '  */                         /*   X'7D'   */
                     (01)('01010000'B),    /*  =  */                         /*   X'7E'   */
                     (01)('01010000'B),    /*  "  */                         /*   X'7F'   */
                     (01)('00000010'B),                                      /*   X'80'   */
                     (09)('00000110'B),    /*LOWERCASE "A" - "I"*/           /*X'81'-X'89'*/
                     (06)('10000000'B),                                      /*X'8A'-X'8F'*/
                     (01)('00000010'B),                                      /*   X'90'   */
                     (09)('00000110'B),    /*LOWERCASE "J" - "R"*/           /*X'91'-X'99'*/
                     (06)('10000000'B),                                      /*X'9A'-X'9F'*/
                     (01)('00000010'B),                                      /*   X'A0'   */
                     (01)('00010010'B),    /*  ~  */                         /*   X'A1'   */
                     (08)('00000110'B),    /*LOWERCASE "S" - "Z"*/           /*X'A2'-X'A9'*/
                     (06)('10000000'B),                                      /*X'AA'-X'AF'*/
                     (10)('00000001'B),    /*LOWERCASE "0" - "9"*/           /*X'B0'-X'B9'*/
                     (06)('10000000'B),                                      /*X'BA'-X'BF'*/
                     (01)('01010010'B),    /*  {  */                         /*   X'C0'   */
                     (09)('01000110'B),    /*UPPERCASE "A" - "I"*/           /*X'C1'-X'C9'*/
                     (06)('11000000'B),                                      /*X'CA'-X'CF'*/
                     (01)('01010010'B),    /*  }  */                         /*   X'D0'   */
                     (09)('01000110'B),    /*UPPERCASE "J" - "R"*/           /*X'D1'-X'D9'*/
                     (06)('11000000'B),                                      /*X'DA'-X'DF'*/
                     (01)('01010010'B),    /*  \  */                         /*   X'E0'   */
                     (01)('01000010'B),                                      /*   X'E1'   */
                     (08)('01000110'B),    /*UPPERCASE "S" - "Z"*/           /*X'E2'-X'E9'*/
                     (06)('11000000'B),                                      /*X'EA'-X'EF'*/
                     (10)('01000001'B),    /*UPPERCASE "0" - "9"*/           /*X'F0'-X'F9'*/
                     (06)('11000000'B));                                     /*X'FA'-X'FF'*/
       %SKIP(2);
    END GCOMPARE;
 %PAGE;
 DECLARE    /*ASSOCIATE SUBROUTINES AND ENTRY POINTS BASED ON PARAMETER ATTRIBUTES*/
 
         TRIM          GENERIC(CV_TRIM   WHEN(CHARACTER VARYING),
                               CF_TRIM   WHEN(CHARACTER));
 %SKIP(2);
 CF_TRIM:     /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS         */
              /*FROM A FIXED LENGTH CHARACTER STRING.                             */
    PROC(CF_STRING)                 /*RECEIVES THE CHARACTER STRING               */
         RETURNS(CHAR(256) VAR);    /*RETURNS A VARYING LENGTH STRING             */
 
        DCL  LENGTH            BUILTIN,
             CF_STRING         CHAR(*),
            (I,J,L)            FIXED BINARY(15,0);
 
        L = LENGTH(CF_STRING);
        IF  L > 0
          THEN DO;
                 DO I = 1 TO L BY +1 WHILE(SUBSTR(CF_STRING,I,1) = ' '); END;
                 DO J = L TO I BY -1 WHILE(SUBSTR(CF_STRING,J,1) = ' '); END;
                 IF I <= J                /* I -> FIRST NON-BLANK, J -> LAST NON-BLANK */
                   THEN RETURN(SUBSTR(CF_STRING,I,J-I+1)); /*STRING CONTAINS NON-BLANKS*/
                   ELSE RETURN('');                        /*STRING IS COMPLETELY BLANK*/
               END;
          ELSE RETURN('');                                 /*STRING IS NULL (LENGTH 0) */
    END CF_TRIM;
 %SKIP(2);
 CV_TRIM:     /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS         */
              /*FROM A VARYING LENGTH CHARACTER STRING.                           */
    PROC(CV_STRING)                 /*RECEIVES THE CHARACTER STRING               */
         RETURNS(CHAR(256) VAR);    /*RETURNS A VARYING LENGTH STRING             */
 
        DCL  LENGTH            BUILTIN,
             CV_STRING         CHAR(*) VARYING,
            (I,J,L)            FIXED BINARY(15,0);
 
        L = LENGTH(CV_STRING);
        IF  L > 0
          THEN DO;
                 DO I = 1 TO L BY +1 WHILE(SUBSTR(CV_STRING,I,1) = ' '); END;
                 DO J = L TO I BY -1 WHILE(SUBSTR(CV_STRING,J,1) = ' '); END;
                 IF I <= J                /* I -> FIRST NON-BLANK, J -> LAST NON-BLANK */
                   THEN RETURN(SUBSTR(CV_STRING,I,J-I+1)); /*STRING CONTAINS NON-BLANKS*/
                   ELSE RETURN('');                        /*STRING IS COMPLETELY BLANK*/
               END;
          ELSE RETURN('');                                 /*STRING IS NULL (LENGTH 0) */
    END CV_TRIM;
    %SKIP(05);
 END SMPSCAN;              /*END OF THE MAIN PROCEDURE*/
