 SCRIPT/VS 3.2.1: DEVICE 1403W8S CHARS MONO
 
 
 
 
 
 
 
                                          Clemson University Computer Center
                                          Clemson University Computer Center
                                          Clemson University Computer Center
                                          Clemson University Computer Center
                                               Structured Programming Macros
                                               Structured Programming Macros
                                               Structured Programming Macros
                                               Structured Programming Macros
                                                  User's Guide And Reference
                                                  User's Guide And Reference
                                                  User's Guide And Reference
                                                  User's Guide And Reference
 
 
 
 
 
 
                                                            March 27th, 1990
 
 
 
 
                                             Last revision: November 6, 1989
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           ii    Clemson Structured Macros
 
 
                                                                     PREFACE
                                                                     PREFACE
                                                                     PREFACE
                                                                     PREFACE
                                                                     _______
 
           The Structured Programming Macros is a programming tool developed
           at  Clemson  University for internal use by the staff of the Com-
           puter Center.  However, after they were written, the decision was
           made to release them to the public since they are very useful  to
           anyone who is programming in System/370 Assembler language.
 
           The  macros  were designed to make the programmer's job easier by
           handling the often confusing but necessary  code  needed  in  any
           program.    Things  like  program linkage, subroutines, parameter
           lists, loops, and conditional sections are handled easily by  use
           of  the macros.   This allows the user to concentrate on the pro-
           gram instead of the details, and also helps make  the  code  much
           easier to read and debug.
 
           The  Structured  Programming  Macros provide a means by which the
           Assembler  programmer  can  use  logical  programming  structures
           normally available only in high-level languages.  Structures like
           DO WHILE, DO UNTIL, IF-THEN-ELSE, and CASE are available directly
           through the macros.  More complex structures, such as SEARCH, may
           be  coded  simply  through a combination of the macros.  In addi-
           tion, some useful macros that perform common functions  (such  as
           flipping  bits  and  clearing  storage) are provided as a conven-
           ience.
 
           The macros are packaged in a macro library which may  be  concat-
           enated  to  SYSLIB for Assembler H.  (There are catalogued proce-
           dures available at Clemson that concatenate this macro library to
           SYS1.MACLIB.)
 
           Among other things, the Structured Programming Macros may be used
           to handle addressing mode switching  and  linkage  under  MVS/XA.
           Should you wish to use the 31-bit addressing features, you should
           be familiar with the concepts described in MVS/XA SPL: 31-Bit Ad-
                                                      ______________________
           dressing, GC28-1158.  Using the macros, it becomes very simple to
           _________
           change  and restore addressing modes, both inline and for subrou-
           tine calls.
 
           Since the Structured Programming Macros provide all of the needed
           control structures, the user should not have to code  any  branch
           instructions  (and  associated  statement  labels)  in a program.
           This makes the source code much neater and easier to read.
 
           This document will serve as an  introduction  to  the  Structured
           Programming Macros, and assumes that the reader is already famil-
           iar  with  the  uses of common structured programming techniques.
           While the Structured Programming Macros serve  as  a  programming
           aid,  they  are  not meant to be a substitute for a working know-
           ledge of System/370 Assembler language and  System/370  architec-
           tures.      When  using  these  macros,  the  reader  should  not
           arbitrarily assume that what the macros generate is some kind  of
 
                                                              Preface    iii
 
 
           "magic code". It's not: in fact, the code generated by the macros
           tends to look a lot like what a competent programmer would write.
           When using the macros, look at the macro expansions occasionally.
           Knowing  a little about how the macros work will help you to make
           better use of them.
 
         | Note: In order to achieve  the  desired  level  of  functionality
           Note:
           Note:
           Note:
         | within  the  Structured  Macros, they have been written in such a
         | way as to require the use of the Level  H  Assembler.    Although
         | some  of  the  macros might not currently require Assembler H, no
         | guarantee is made that any of the features  described  here  will
         | work  with  the Level F Assembler.  Use of these macros with any-
         | thing other than Assembler H is not recommended.
                                           not
                                           not
                                           not
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           iv    Clemson Structured Macros
 
 
                                                           TABLE OF CONTENTS
                                                           TABLE OF CONTENTS
                                                           TABLE OF CONTENTS
                                                           TABLE OF CONTENTS
                                                           _________________
 
           I. Structured Macros User's Guide  . . . . . . . . . . . . . .  1
           I. Structured Macros User's Guide  . . . . . . . . . . . . . .  1
           I. Structured Macros User's Guide  . . . . . . . . . . . . . .  1
           I. Structured Macros User's Guide  . . . . . . . . . . . . . .  1
 
           Chapter 1. Nesting Levels  . . . . . . . . . . . . . . . . . .  2
           Chapter 1. Nesting Levels  . . . . . . . . . . . . . . . . . .  2
           Chapter 1. Nesting Levels  . . . . . . . . . . . . . . . . . .  2
           Chapter 1. Nesting Levels  . . . . . . . . . . . . . . . . . .  2
 
           Chapter 2. Conditional Statements  . . . . . . . . . . . . . .  4
           Chapter 2. Conditional Statements  . . . . . . . . . . . . . .  4
           Chapter 2. Conditional Statements  . . . . . . . . . . . . . .  4
           Chapter 2. Conditional Statements  . . . . . . . . . . . . . .  4
           Standard Conditions  . . . . . . . . . . . . . . . . . . . . .  4
           Coding Conditional Expressions   . . . . . . . . . . . . . . .  5
         | User-Defined Conditions  . . . . . . . . . . . . . . . . . . .  7
 
           Chapter 3. Blocks  . . . . . . . . . . . . . . . . . . . . . . 10
           Chapter 3. Blocks  . . . . . . . . . . . . . . . . . . . . . . 10
           Chapter 3. Blocks  . . . . . . . . . . . . . . . . . . . . . . 10
           Chapter 3. Blocks  . . . . . . . . . . . . . . . . . . . . . . 10
           The Program Block  . . . . . . . . . . . . . . . . . . . . . . 10
           The Inline Block   . . . . . . . . . . . . . . . . . . . . . . 10
           The Subroutine Block   . . . . . . . . . . . . . . . . . . . . 11
           The ErrExit Block  . . . . . . . . . . . . . . . . . . . . . . 12
 
           Chapter 4. Program Environments  . . . . . . . . . . . . . . . 13
           Chapter 4. Program Environments  . . . . . . . . . . . . . . . 13
           Chapter 4. Program Environments  . . . . . . . . . . . . . . . 13
           Chapter 4. Program Environments  . . . . . . . . . . . . . . . 13
           DC Environment   . . . . . . . . . . . . . . . . . . . . . . . 13
             System Mode And User Mode  . . . . . . . . . . . . . . . . . 13
             Reentrancy Under IDMS/DC   . . . . . . . . . . . . . . . . . 14
             *NORENT  . . . . . . . . . . . . . . . . . . . . . . . . . . 14
             *NORENTSYS   . . . . . . . . . . . . . . . . . . . . . . . . 14
             *RENT  . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
             *RENTSYS   . . . . . . . . . . . . . . . . . . . . . . . . . 15
             *PWA   . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
             *PWASYS  . . . . . . . . . . . . . . . . . . . . . . . . . . 15
           OS Environment   . . . . . . . . . . . . . . . . . . . . . . . 15
             *NORENT  . . . . . . . . . . . . . . . . . . . . . . . . . . 15
             *RENT  . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
             *PWA   . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
             *MAIN  . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
             *NOMAIN  . . . . . . . . . . . . . . . . . . . . . . . . . . 17
             *SRVPRC  . . . . . . . . . . . . . . . . . . . . . . . . . . 17
           PL/I Environment   . . . . . . . . . . . . . . . . . . . . . . 17
             *STDPLI  . . . . . . . . . . . . . . . . . . . . . . . . . . 18
           Other Environments   . . . . . . . . . . . . . . . . . . . . . 18
           Subroutine Block Super Options   . . . . . . . . . . . . . . . 19
             *SWA   . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
             *NOSUBOPTS   . . . . . . . . . . . . . . . . . . . . . . . . 19
           Conclusion   . . . . . . . . . . . . . . . . . . . . . . . . . 19
 
           Chapter 5. Program and Subroutine Work Areas   . . . . . . . . 20
           Chapter 5. Program and Subroutine Work Areas   . . . . . . . . 20
           Chapter 5. Program and Subroutine Work Areas   . . . . . . . . 20
           Chapter 5. Program and Subroutine Work Areas   . . . . . . . . 20
           Program Work Areas   . . . . . . . . . . . . . . . . . . . . . 20
         | Reusable Program Work Areas  . . . . . . . . . . . . . . . . . 20
           Subroutine Work Areas  . . . . . . . . . . . . . . . . . . . . 21
           SWA Placement  . . . . . . . . . . . . . . . . . . . . . . . . 22
           PSDs and SSDs  . . . . . . . . . . . . . . . . . . . . . . . . 23
 
           Chapter 6. Large Program Management  . . . . . . . . . . . . . 24
           Chapter 6. Large Program Management  . . . . . . . . . . . . . 24
           Chapter 6. Large Program Management  . . . . . . . . . . . . . 24
           Chapter 6. Large Program Management  . . . . . . . . . . . . . 24
           PWAs and SWAs with Dynamic Storage Management  . . . . . . . . 24
             Recursive Subroutines with the DYN Option  . . . . . . . . . 25
 
                                                      Table of Contents    v
 
 
             Storage Calculations with the DYN Option   . . . . . . . . . 25
             SWA Addressability with the DYN Option   . . . . . . . . . . 26
             Super Options Used with the DYN Option   . . . . . . . . . . 26
             Storage Optimization with the DYN Option   . . . . . . . . . 26
           LONG and LOADBASE  . . . . . . . . . . . . . . . . . . . . . . 27
           Size Limitations   . . . . . . . . . . . . . . . . . . . . . . 28
           Conclusion   . . . . . . . . . . . . . . . . . . . . . . . . . 28
 
           Chapter 7. The IF Structure  . . . . . . . . . . . . . . . . . 29
           Chapter 7. The IF Structure  . . . . . . . . . . . . . . . . . 29
           Chapter 7. The IF Structure  . . . . . . . . . . . . . . . . . 29
           Chapter 7. The IF Structure  . . . . . . . . . . . . . . . . . 29
 
           Chapter 8. Loops   . . . . . . . . . . . . . . . . . . . . . . 32
           Chapter 8. Loops   . . . . . . . . . . . . . . . . . . . . . . 32
           Chapter 8. Loops   . . . . . . . . . . . . . . . . . . . . . . 32
           Chapter 8. Loops   . . . . . . . . . . . . . . . . . . . . . . 32
 
           Chapter 9. CASEs and CASE Blocks   . . . . . . . . . . . . . . 33
           Chapter 9. CASEs and CASE Blocks   . . . . . . . . . . . . . . 33
           Chapter 9. CASEs and CASE Blocks   . . . . . . . . . . . . . . 33
           Chapter 9. CASEs and CASE Blocks   . . . . . . . . . . . . . . 33
 
         | Chapter 10. Parameter Lists and Standard Linkage   . . . . . . 34
           Chapter 10. Parameter Lists and Standard Linkage   . . . . . . 34
           Chapter 10. Parameter Lists and Standard Linkage   . . . . . . 34
           Chapter 10. Parameter Lists and Standard Linkage   . . . . . . 34
         | Referencing Input Parameter Lists  . . . . . . . . . . . . . . 34
           Generating Parameter Lists   . . . . . . . . . . . . . . . . . 36
           Automatic Parameter Lists  . . . . . . . . . . . . . . . . . . 38
           Permanent Parameter Lists  . . . . . . . . . . . . . . . . . . 38
         | Calling Subroutines  . . . . . . . . . . . . . . . . . . . . . 39
           Parameter Lists on CALLSUB and CALLX   . . . . . . . . . . . . 40
           Recommendations  . . . . . . . . . . . . . . . . . . . . . . . 40
         | Example Source   . . . . . . . . . . . . . . . . . . . . . . . 41
 
         | Chapter 11. Location and Scope of Data Structures  . . . . . . 43
           Chapter 11. Location and Scope of Data Structures  . . . . . . 43
           Chapter 11. Location and Scope of Data Structures  . . . . . . 43
           Chapter 11. Location and Scope of Data Structures  . . . . . . 43
         | Local Scope within Subroutines   . . . . . . . . . . . . . . . 43
 
           Chapter 12. Miscellaneous Macros   . . . . . . . . . . . . . . 45
           Chapter 12. Miscellaneous Macros   . . . . . . . . . . . . . . 45
           Chapter 12. Miscellaneous Macros   . . . . . . . . . . . . . . 45
           Chapter 12. Miscellaneous Macros   . . . . . . . . . . . . . . 45
           Bit Manipulation   . . . . . . . . . . . . . . . . . . . . . . 45
           Testing A Register   . . . . . . . . . . . . . . . . . . . . . 45
           Initializing Storage   . . . . . . . . . . . . . . . . . . . . 46
           Register Loading   . . . . . . . . . . . . . . . . . . . . . . 46
           Executing Instructions   . . . . . . . . . . . . . . . . . . . 47
           Loading control block addresses  . . . . . . . . . . . . . . . 48
         | Controlling Structured Macro Operation   . . . . . . . . . . . 48
 
           Chapter 13. Miscellaneous Examples   . . . . . . . . . . . . . 49
           Chapter 13. Miscellaneous Examples   . . . . . . . . . . . . . 49
           Chapter 13. Miscellaneous Examples   . . . . . . . . . . . . . 49
           Chapter 13. Miscellaneous Examples   . . . . . . . . . . . . . 49
           A Search Loop  . . . . . . . . . . . . . . . . . . . . . . . . 49
           Scanning Text  . . . . . . . . . . . . . . . . . . . . . . . . 50
           A DCB EODAD Exit   . . . . . . . . . . . . . . . . . . . . . . 51
           Returning R0 and R1 with ENDBLK  . . . . . . . . . . . . . . . 52
 
         | Chapter 14. Structured Macros Listing Program  . . . . . . . . 53
           Chapter 14. Structured Macros Listing Program  . . . . . . . . 53
           Chapter 14. Structured Macros Listing Program  . . . . . . . . 53
           Chapter 14. Structured Macros Listing Program  . . . . . . . . 53
         | Output of the Listing Program  . . . . . . . . . . . . . . . . 53
         | Controlling Listing Program Operation  . . . . . . . . . . . . 54
 
           II. Structured Macros Reference  . . . . . . . . . . . . . . . 56
           II. Structured Macros Reference  . . . . . . . . . . . . . . . 56
           II. Structured Macros Reference  . . . . . . . . . . . . . . . 56
           II. Structured Macros Reference  . . . . . . . . . . . . . . . 56
 
           Chapter 15. BLOCK  . . . . . . . . . . . . . . . . . . . . . . 57
           Chapter 15. BLOCK  . . . . . . . . . . . . . . . . . . . . . . 57
           Chapter 15. BLOCK  . . . . . . . . . . . . . . . . . . . . . . 57
           Chapter 15. BLOCK  . . . . . . . . . . . . . . . . . . . . . . 57
           BLOCK TYPE=ERREXIT   . . . . . . . . . . . . . . . . . . . . . 59
           BLOCK TYPE=INLINE  . . . . . . . . . . . . . . . . . . . . . . 60
           BLOCK TYPE=PROGRAM,ENVIRON=DC  . . . . . . . . . . . . . . . . 61
           BLOCK TYPE=PROGRAM,ENVIRON=OS  . . . . . . . . . . . . . . . . 66
           BLOCK TYPE=PROGRAM,ENVIRON=PLI   . . . . . . . . . . . . . . . 73
 
           vi    Clemson Structured Macros
 
 
           BLOCK TYPE=SUBROUTINE  . . . . . . . . . . . . . . . . . . . . 76
 
           Chapter 16. CALLSUB  . . . . . . . . . . . . . . . . . . . . . 79
           Chapter 16. CALLSUB  . . . . . . . . . . . . . . . . . . . . . 79
           Chapter 16. CALLSUB  . . . . . . . . . . . . . . . . . . . . . 79
           Chapter 16. CALLSUB  . . . . . . . . . . . . . . . . . . . . . 79
 
           Chapter 17. CALLX  . . . . . . . . . . . . . . . . . . . . . . 81
           Chapter 17. CALLX  . . . . . . . . . . . . . . . . . . . . . . 81
           Chapter 17. CALLX  . . . . . . . . . . . . . . . . . . . . . . 81
           Chapter 17. CALLX  . . . . . . . . . . . . . . . . . . . . . . 81
 
           Chapter 18. CASE   . . . . . . . . . . . . . . . . . . . . . . 83
           Chapter 18. CASE   . . . . . . . . . . . . . . . . . . . . . . 83
           Chapter 18. CASE   . . . . . . . . . . . . . . . . . . . . . . 83
           Chapter 18. CASE   . . . . . . . . . . . . . . . . . . . . . . 83
 
           Chapter 19. CASEBLK  . . . . . . . . . . . . . . . . . . . . . 84
           Chapter 19. CASEBLK  . . . . . . . . . . . . . . . . . . . . . 84
           Chapter 19. CASEBLK  . . . . . . . . . . . . . . . . . . . . . 84
           Chapter 19. CASEBLK  . . . . . . . . . . . . . . . . . . . . . 84
 
         | Chapter 20. DEFUCOND   . . . . . . . . . . . . . . . . . . . . 85
           Chapter 20. DEFUCOND   . . . . . . . . . . . . . . . . . . . . 85
           Chapter 20. DEFUCOND   . . . . . . . . . . . . . . . . . . . . 85
           Chapter 20. DEFUCOND   . . . . . . . . . . . . . . . . . . . . 85
 
           Chapter 21. ELSE   . . . . . . . . . . . . . . . . . . . . . . 86
           Chapter 21. ELSE   . . . . . . . . . . . . . . . . . . . . . . 86
           Chapter 21. ELSE   . . . . . . . . . . . . . . . . . . . . . . 86
           Chapter 21. ELSE   . . . . . . . . . . . . . . . . . . . . . . 86
 
           Chapter 22. ELSEIF   . . . . . . . . . . . . . . . . . . . . . 87
           Chapter 22. ELSEIF   . . . . . . . . . . . . . . . . . . . . . 87
           Chapter 22. ELSEIF   . . . . . . . . . . . . . . . . . . . . . 87
           Chapter 22. ELSEIF   . . . . . . . . . . . . . . . . . . . . . 87
 
           Chapter 23. ENDBLK   . . . . . . . . . . . . . . . . . . . . . 88
           Chapter 23. ENDBLK   . . . . . . . . . . . . . . . . . . . . . 88
           Chapter 23. ENDBLK   . . . . . . . . . . . . . . . . . . . . . 88
           Chapter 23. ENDBLK   . . . . . . . . . . . . . . . . . . . . . 88
 
           Chapter 24. ENDCASE  . . . . . . . . . . . . . . . . . . . . . 89
           Chapter 24. ENDCASE  . . . . . . . . . . . . . . . . . . . . . 89
           Chapter 24. ENDCASE  . . . . . . . . . . . . . . . . . . . . . 89
           Chapter 24. ENDCASE  . . . . . . . . . . . . . . . . . . . . . 89
 
           Chapter 25. ENDIF  . . . . . . . . . . . . . . . . . . . . . . 90
           Chapter 25. ENDIF  . . . . . . . . . . . . . . . . . . . . . . 90
           Chapter 25. ENDIF  . . . . . . . . . . . . . . . . . . . . . . 90
           Chapter 25. ENDIF  . . . . . . . . . . . . . . . . . . . . . . 90
 
           Chapter 26. ENDLOOP  . . . . . . . . . . . . . . . . . . . . . 91
           Chapter 26. ENDLOOP  . . . . . . . . . . . . . . . . . . . . . 91
           Chapter 26. ENDLOOP  . . . . . . . . . . . . . . . . . . . . . 91
           Chapter 26. ENDLOOP  . . . . . . . . . . . . . . . . . . . . . 91
 
           Chapter 27. ENDPSD   . . . . . . . . . . . . . . . . . . . . . 92
           Chapter 27. ENDPSD   . . . . . . . . . . . . . . . . . . . . . 92
           Chapter 27. ENDPSD   . . . . . . . . . . . . . . . . . . . . . 92
           Chapter 27. ENDPSD   . . . . . . . . . . . . . . . . . . . . . 92
 
           Chapter 28. ENDPWA   . . . . . . . . . . . . . . . . . . . . . 93
           Chapter 28. ENDPWA   . . . . . . . . . . . . . . . . . . . . . 93
           Chapter 28. ENDPWA   . . . . . . . . . . . . . . . . . . . . . 93
           Chapter 28. ENDPWA   . . . . . . . . . . . . . . . . . . . . . 93
 
           Chapter 29. ENDSSD   . . . . . . . . . . . . . . . . . . . . . 94
           Chapter 29. ENDSSD   . . . . . . . . . . . . . . . . . . . . . 94
           Chapter 29. ENDSSD   . . . . . . . . . . . . . . . . . . . . . 94
           Chapter 29. ENDSSD   . . . . . . . . . . . . . . . . . . . . . 94
 
           Chapter 30. ENDSWA   . . . . . . . . . . . . . . . . . . . . . 95
           Chapter 30. ENDSWA   . . . . . . . . . . . . . . . . . . . . . 95
           Chapter 30. ENDSWA   . . . . . . . . . . . . . . . . . . . . . 95
           Chapter 30. ENDSWA   . . . . . . . . . . . . . . . . . . . . . 95
 
           Chapter 31. ERREXIT  . . . . . . . . . . . . . . . . . . . . . 96
           Chapter 31. ERREXIT  . . . . . . . . . . . . . . . . . . . . . 96
           Chapter 31. ERREXIT  . . . . . . . . . . . . . . . . . . . . . 96
           Chapter 31. ERREXIT  . . . . . . . . . . . . . . . . . . . . . 96
 
           Chapter 32. EXI  . . . . . . . . . . . . . . . . . . . . . . . 97
           Chapter 32. EXI  . . . . . . . . . . . . . . . . . . . . . . . 97
           Chapter 32. EXI  . . . . . . . . . . . . . . . . . . . . . . . 97
           Chapter 32. EXI  . . . . . . . . . . . . . . . . . . . . . . . 97
 
           Chapter 33. FILL   . . . . . . . . . . . . . . . . . . . . . . 98
           Chapter 33. FILL   . . . . . . . . . . . . . . . . . . . . . . 98
           Chapter 33. FILL   . . . . . . . . . . . . . . . . . . . . . . 98
           Chapter 33. FILL   . . . . . . . . . . . . . . . . . . . . . . 98
 
           Chapter 34. IBIT   . . . . . . . . . . . . . . . . . . . . . . 99
           Chapter 34. IBIT   . . . . . . . . . . . . . . . . . . . . . . 99
           Chapter 34. IBIT   . . . . . . . . . . . . . . . . . . . . . . 99
           Chapter 34. IBIT   . . . . . . . . . . . . . . . . . . . . . . 99
 
           Chapter 35. IF   . . . . . . . . . . . . . . . . . . . . . .  100
           Chapter 35. IF   . . . . . . . . . . . . . . . . . . . . . .  100
           Chapter 35. IF   . . . . . . . . . . . . . . . . . . . . . .  100
           Chapter 35. IF   . . . . . . . . . . . . . . . . . . . . . .  100
 
           Chapter 36. LCBA   . . . . . . . . . . . . . . . . . . . . .  101
           Chapter 36. LCBA   . . . . . . . . . . . . . . . . . . . . .  101
           Chapter 36. LCBA   . . . . . . . . . . . . . . . . . . . . .  101
           Chapter 36. LCBA   . . . . . . . . . . . . . . . . . . . . .  101
 
           Chapter 37. LEAVE  . . . . . . . . . . . . . . . . . . . . .  103
           Chapter 37. LEAVE  . . . . . . . . . . . . . . . . . . . . .  103
           Chapter 37. LEAVE  . . . . . . . . . . . . . . . . . . . . .  103
           Chapter 37. LEAVE  . . . . . . . . . . . . . . . . . . . . .  103
 
           Chapter 38. LOOP   . . . . . . . . . . . . . . . . . . . . .  104
           Chapter 38. LOOP   . . . . . . . . . . . . . . . . . . . . .  104
           Chapter 38. LOOP   . . . . . . . . . . . . . . . . . . . . .  104
           Chapter 38. LOOP   . . . . . . . . . . . . . . . . . . . . .  104
 
           Chapter 39. L8, L16, L24, L32  . . . . . . . . . . . . . . .  105
           Chapter 39. L8, L16, L24, L32  . . . . . . . . . . . . . . .  105
           Chapter 39. L8, L16, L24, L32  . . . . . . . . . . . . . . .  105
           Chapter 39. L8, L16, L24, L32  . . . . . . . . . . . . . . .  105
 
           Chapter 40. PLIST  . . . . . . . . . . . . . . . . . . . . .  106
           Chapter 40. PLIST  . . . . . . . . . . . . . . . . . . . . .  106
           Chapter 40. PLIST  . . . . . . . . . . . . . . . . . . . . .  106
           Chapter 40. PLIST  . . . . . . . . . . . . . . . . . . . . .  106
 
           Chapter 41. PSD  . . . . . . . . . . . . . . . . . . . . . .  108
           Chapter 41. PSD  . . . . . . . . . . . . . . . . . . . . . .  108
           Chapter 41. PSD  . . . . . . . . . . . . . . . . . . . . . .  108
           Chapter 41. PSD  . . . . . . . . . . . . . . . . . . . . . .  108
 
                                                    Table of Contents    vii
 
 
           Chapter 42. PWA  . . . . . . . . . . . . . . . . . . . . . .  109
           Chapter 42. PWA  . . . . . . . . . . . . . . . . . . . . . .  109
           Chapter 42. PWA  . . . . . . . . . . . . . . . . . . . . . .  109
           Chapter 42. PWA  . . . . . . . . . . . . . . . . . . . . . .  109
 
           Chapter 43. RBIT   . . . . . . . . . . . . . . . . . . . . .  110
           Chapter 43. RBIT   . . . . . . . . . . . . . . . . . . . . .  110
           Chapter 43. RBIT   . . . . . . . . . . . . . . . . . . . . .  110
           Chapter 43. RBIT   . . . . . . . . . . . . . . . . . . . . .  110
 
           Chapter 44. SBIT   . . . . . . . . . . . . . . . . . . . . .  111
           Chapter 44. SBIT   . . . . . . . . . . . . . . . . . . . . .  111
           Chapter 44. SBIT   . . . . . . . . . . . . . . . . . . . . .  111
           Chapter 44. SBIT   . . . . . . . . . . . . . . . . . . . . .  111
 
           Chapter 45. SMCTRL   . . . . . . . . . . . . . . . . . . . .  112
           Chapter 45. SMCTRL   . . . . . . . . . . . . . . . . . . . .  112
           Chapter 45. SMCTRL   . . . . . . . . . . . . . . . . . . . .  112
           Chapter 45. SMCTRL   . . . . . . . . . . . . . . . . . . . .  112
 
         | Chapter 46. SMLIST   . . . . . . . . . . . . . . . . . . . .  113
           Chapter 46. SMLIST   . . . . . . . . . . . . . . . . . . . .  113
           Chapter 46. SMLIST   . . . . . . . . . . . . . . . . . . . .  113
           Chapter 46. SMLIST   . . . . . . . . . . . . . . . . . . . .  113
 
         | Chapter 47. SMSYMS   . . . . . . . . . . . . . . . . . . . .  114
           Chapter 47. SMSYMS   . . . . . . . . . . . . . . . . . . . .  114
           Chapter 47. SMSYMS   . . . . . . . . . . . . . . . . . . . .  114
           Chapter 47. SMSYMS   . . . . . . . . . . . . . . . . . . . .  114
 
           Chapter 48. SSD  . . . . . . . . . . . . . . . . . . . . . .  115
           Chapter 48. SSD  . . . . . . . . . . . . . . . . . . . . . .  115
           Chapter 48. SSD  . . . . . . . . . . . . . . . . . . . . . .  115
           Chapter 48. SSD  . . . . . . . . . . . . . . . . . . . . . .  115
 
           Chapter 49. STRSA  . . . . . . . . . . . . . . . . . . . . .  116
           Chapter 49. STRSA  . . . . . . . . . . . . . . . . . . . . .  116
           Chapter 49. STRSA  . . . . . . . . . . . . . . . . . . . . .  116
           Chapter 49. STRSA  . . . . . . . . . . . . . . . . . . . . .  116
 
           Chapter 50. SWA  . . . . . . . . . . . . . . . . . . . . . .  117
           Chapter 50. SWA  . . . . . . . . . . . . . . . . . . . . . .  117
           Chapter 50. SWA  . . . . . . . . . . . . . . . . . . . . . .  117
           Chapter 50. SWA  . . . . . . . . . . . . . . . . . . . . . .  117
 
           Chapter 51. TBIT   . . . . . . . . . . . . . . . . . . . . .  118
           Chapter 51. TBIT   . . . . . . . . . . . . . . . . . . . . .  118
           Chapter 51. TBIT   . . . . . . . . . . . . . . . . . . . . .  118
           Chapter 51. TBIT   . . . . . . . . . . . . . . . . . . . . .  118
 
           Chapter 52. TREG   . . . . . . . . . . . . . . . . . . . . .  119
           Chapter 52. TREG   . . . . . . . . . . . . . . . . . . . . .  119
           Chapter 52. TREG   . . . . . . . . . . . . . . . . . . . . .  119
           Chapter 52. TREG   . . . . . . . . . . . . . . . . . . . . .  119
 
         | Chapter 53. ##COND   . . . . . . . . . . . . . . . . . . . .  120
           Chapter 53. ##COND   . . . . . . . . . . . . . . . . . . . .  120
           Chapter 53. ##COND   . . . . . . . . . . . . . . . . . . . .  120
           Chapter 53. ##COND   . . . . . . . . . . . . . . . . . . . .  120
 
           Appendix A. Catalogued ASM Procedures At Clemson   . . . . .  121
           Appendix A. Catalogued ASM Procedures At Clemson   . . . . .  121
           Appendix A. Catalogued ASM Procedures At Clemson   . . . . .  121
           Appendix A. Catalogued ASM Procedures At Clemson   . . . . .  121
 
           Appendix B. Internal Macros Error Messages   . . . . . . . .  123
           Appendix B. Internal Macros Error Messages   . . . . . . . .  123
           Appendix B. Internal Macros Error Messages   . . . . . . . .  123
           Appendix B. Internal Macros Error Messages   . . . . . . . .  123
 
           Appendix C. Work Area Storage Layout   . . . . . . . . . . .  129
           Appendix C. Work Area Storage Layout   . . . . . . . . . . .  129
           Appendix C. Work Area Storage Layout   . . . . . . . . . . .  129
           Appendix C. Work Area Storage Layout   . . . . . . . . . . .  129
           Work Area Layout with the DYN Option   . . . . . . . . . . .  129
           Work Area Layout with NODYN and ENVIRON=DC   . . . . . . . .  132
           Work Area Layout with NODYN and ENVIRON=OS   . . . . . . . .  132
           Work Area Layout with NODYN and ENVIRON=PLI  . . . . . . . .  133
 
           Appendix D. Program Code and Static Data Layout  . . . . . .  135
           Appendix D. Program Code and Static Data Layout  . . . . . .  135
           Appendix D. Program Code and Static Data Layout  . . . . . .  135
           Appendix D. Program Code and Static Data Layout  . . . . . .  135
 
           Appendix E. Register Usage   . . . . . . . . . . . . . . . .  137
           Appendix E. Register Usage   . . . . . . . . . . . . . . . .  137
           Appendix E. Register Usage   . . . . . . . . . . . . . . . .  137
           Appendix E. Register Usage   . . . . . . . . . . . . . . . .  137
           Register Usage for ENVIRON=DC  . . . . . . . . . . . . . . .  137
             IDMS/DC User Mode Registers And Linkage  . . . . . . . . .  137
             IDMS/DC System Mode Registers And Linkage  . . . . . . . .  138
           Register Usage for ENVIRON=OS  . . . . . . . . . . . . . . .  139
           Register Usage for ENVIRON=PLI   . . . . . . . . . . . . . .  140
 
 
 
 
 
           viii    Clemson Structured Macros
 
 
                                                       SUMMARY OF AMENDMENTS
                                                       SUMMARY OF AMENDMENTS
                                                       SUMMARY OF AMENDMENTS
                                                       SUMMARY OF AMENDMENTS
                                                       _____________________
 
         | Update November 6, 1989
           Update November 6, 1989
           Update November 6, 1989
           Update November 6, 1989
           _______________________
 
         | 1.   Two  new  macros (DEFUCOND and ##COND) are provided to allow
         |      the programmer to define new conditional tests that  can  be
         |      inserted into any conditional expression.
 
         | 2.   The  COPYERROR  and  COUNT suboptions have been added to the
         |      PARMS option.
 
         | Update April 19, 1989
           Update April 19, 1989
           Update April 19, 1989
           Update April 19, 1989
           _____________________
 
         | 1.   The Structured Macros now require the Level H Assembler  for
         |      correct  operation.  Do not use them with the Level F Assem-
         |      bler.
 
         | 2.   Changes were made in the PLIST macro to allow more  flexible
         |      specification  of parameters.  Most notably, indirect refer-
         |      encing is now supported.
 
         | 3.   Symbols have been provided to allow the  program  to  locate
         |      the start of major structures such as the PWA, PSD, SWA, and
         |      SSD.
 
         | 4.   An automatic prefixing facility has been added to allow pro-
         |      grammers to name storage tags in a subroutine without having
         |      to  worry  about  what  tags  in other subroutines have been
         |      named.
 
         | 5.   A SMLIST macro has been added to control the output  of  the
         |      Structured  Macros listing program.  Currently, the only op-
         |      tion is to provide for automatic conversion of  the  program
         |      to uppercase before assembly.
 
           Update October 1, 1987
           Update October 1, 1987
           Update October 1, 1987
           Update October 1, 1987
           ______________________
 
           1.   Support  was  added  for writing Service Processors with the
                Structured Macros.  Service Processors are programs that are
                called repeatedly to process one of a variety of  functions,
                and that retain their workarea between calls.  To learn more
                about  Service  Processors,  see Clemson University Computer
                                                 ___________________________
                Center Service Processor User's Guide and  Reference.    The
                ____________________________________________________
                Service  Processor support includes new options and keywords
                on the BLOCK macro and a new super option.
 
                                                 Summary of Amendments    ix
 
 
           2.   The SMCTRL macro was added to set internal flags that affect
                the operation of the Structured Macros.  Currently, this  is
                only used for Service Processor support.
 
           Update March 11, 1987
           Update March 11, 1987
           Update March 11, 1987
           Update March 11, 1987
           _____________________
 
           1.   An ENVIRON keyword was added to the BLOCK TYPE=PROGRAM macro
                to  allow for the different linkage conventions in different
                program environments.  Currently, the supported environments
                are:  OS, DC, and PLI.
 
           2.   Support was added for PWAs in non-reentrant programs.
 
           3.   R0 and R1 keywords were added to the ENDBLK macro  for  pro-
                grams  to enable a program to pass back registers 0 and 1 to
                its caller.
 
           4.   The error messages issued by internal macros have been moved
                to their own section.
 
           5.   Minor editorial changes have been made.
 
 
 
 
 
 
 
 
 
 
 
           x    Clemson Structured Macros
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                           I. STRUCTURED MACROS USER'S GUIDE
                                           I. STRUCTURED MACROS USER'S GUIDE
                                           I. STRUCTURED MACROS USER'S GUIDE
                                           I. STRUCTURED MACROS USER'S GUIDE
                                           _________________________________
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           2    Structured Macros Users's Guide
 
 
                                                   CHAPTER 1. NESTING LEVELS
                                                   CHAPTER 1. NESTING LEVELS
                                                   CHAPTER 1. NESTING LEVELS
                                                   CHAPTER 1. NESTING LEVELS
                                                   _________________________
 
           There  are  4 major building blocks that can be nested. These are
           the block, the if/elseif, the loop, and  the  case  block.    The
               ______     __________     _____           ____________
           Structured  Programming  Macros  support nesting to a depth of 20
           for each structure. The structures may be intermixed:  for  exam-
           ple,  a BLOCK can contain IF structures, and a LOOP may contain a
           CASE block, which may in turn contain  more  LOOPs.    Levels  of
           nesting are opened and closed by the use of complementary macros,
           like BLOCK/ENDBLK, LOOP/ENDLOOP, IF/ENDIF and CASEBLK/ENDCASE.
 
           The user of these macros might find it helpful to start indenting
           source  statements  as  nesting levels vary.  Since no labels are
           required in the program code, the user can code statement  start-
           ing  in  column  two and indent while still leaving room for com-
           ments.  Consider the following examples: in the  first,  operands
           are coded in fixed columns, as is common practice.
 
 
 
                    BLOCK   NAME=TEST
                    IF  (condition1),THEN
                    LOOP      WHILE,(condition2)
                    LEAVE     (condition3,),IF=*
                    ENDLOOP  WHILE
                    ENDIF
                    ENDBLK
 
             Figure 1.  Unindented Assembler Source
 
 
           In  Figure 2  on  page  2, however, the same instructions are in-
           dented based on the nesting level of each.  While the second  ex-
           ample may look unusual to the hardened Assembler programmer, it's
           easier  to follow the nesting levels, and thus the logical struc-
           ture, by sight alone.
 
 
 
              BLOCK NAME=TEST
               IF   (condition1),THEN
                LOOP      WHILE,(condition2)
                 LEAVE    LOOP=*,(condition3)
                ENDLOOP   WHILE
               ENDIF
              ENDBLK
 
             Figure 2.  Indented Assembler Source
 
 
 
                                              Chapter 1. Nesting Levels    3
 
 
           Since the macros require proper nesting of structures to generate
           tags  for branches and the like, correct pairing of complementary
           macros is important.  The structured assembler  cataloged  proce-
           dures  in  use  at  Clemson include a pre-step that examines your
           source for  nesting  problems  and  lists  your  program  with  a
           nesting-level  report.  This  pre-processor is described later in
           "Appendix A. Catalogued ASM Procedures At Clemson" on page 121.
 
           The nesting of structures provides a very specific path  for  the
           program  to  follow.   This can be interrupted where necessary by
           the use of the LEAVE macro.   This macro allows  the  program  to
           leave  a  structure  prematurely either conditionally or uncondi-
           tionally.  By default, the LEAVE macro will leave  the  innermost
           structure of the type specified.  However, it can be used to exit
           a  structure  from  any depth.   If you are leaving from a deeply
           nested series of inline blocks, restoring  registers  and  AMODEs
           properly  is a complicated task.  The LEAVE macro can handle this
           task nicely.  The programmer should not have to worry about this.
           You can leave an arbitrarily complex  structure  and  LEAVE  will
           handle the details.
 
 
 
 
 
 
 
 
 
 
 
 
           4    Structured Macros Users's Guide
 
 
                                           CHAPTER 2. CONDITIONAL STATEMENTS
                                           CHAPTER 2. CONDITIONAL STATEMENTS
                                           CHAPTER 2. CONDITIONAL STATEMENTS
                                           CHAPTER 2. CONDITIONAL STATEMENTS
                                           _________________________________
 
           Using  the Structured Macros, conditional expressions are defined
           in terms of the instruction(s) that  will  make  the  comparison.
           Conditional expressions are mandatory on some macros (IF, ELSEIF,
           and  some  forms  of  LOOP)  and  optional  on  others (LEAVE and
           ERREXIT).   The syntax of a conditional  expression  on  each  of
           these macros is identical.
 
 
           STANDARD CONDITIONS
           STANDARD CONDITIONS
           STANDARD CONDITIONS
           STANDARD CONDITIONS
           ___________________
 
           The format of a single condition can be any of the following:
 
               (CLC,operand1,condition,operand2)
                CLC,
                CLC,
                CLC,
 
               (CR,operand1,condition,operand2)
                CR,
                CR,
                CR,
 
               (C,operand1,condition,operand2)
                C,
                C,
                C,
 
               (CP,operand1,condition,operand2)
                CP,
                CP,
                CP,
 
               (CH,operand1,condition,operand2)
                CH,
                CH,
                CH,
 
               (CLR,operand1,condition,operand2)
                CLR,
                CLR,
                CLR,
 
               (CL,operand1,condition,operand2)
                CL,
                CL,
                CL,
 
               (CLI,operand1,condition,operand2)
                CLI,
                CLI,
                CLI,
 
               (CLCL,operand1,condition,operand2)
                CLCL,
                CLCL,
                CLCL,
 
               (TM,operand1,condition,operand2)
                TM,
                TM,
                TM,
 
               (CLM,operand1,mask,condition,operand2)
                CLM,
                CLM,
                CLM,
 
               (TREG,operand1,condition)
                TREG,
                TREG,
                TREG,
 
               (TBIT,[operand1,]operand2[,ON|OFF|ANY|MIXED ])  default ON
                TBIT,                    ,ON|OFF|ANY|MIXED
                TBIT,                    ,ON|OFF|ANY|MIXED
                TBIT,                    ,ON|OFF|ANY|MIXED
 
               (#TEST,operand1[,ON|OFF|ANY ])  default ON
                #TEST,         ,ON|OFF|ANY
                #TEST,         ,ON|OFF|ANY
                #TEST,         ,ON|OFF|ANY
 
           where:
 
               The  first parameter is the machine or macro instruction that
               is to be used to perform the comparison.  CLC, CR, C, CP, CH,
               CLR, CL, CLI, CLCL, TM and CLM  are  all  S/370  machine  in-
               structions.   TREG is a macro that tests a register for zero,
               positive, or negative.  TBIT is another macro  that  is  used
 
                                      Chapter 2. Conditional Statements    5
 
 
               for testing bits.  As signified, the only conditions that can
               be specified for TBIT are ON, OFF, ANY and MIXED.  #TEST sup-
               ports the IDMS/DC #TEST macro.  #TEST supports the conditions
               ON, OFF and ANY.
 
               operand1 is the first operand of the specified instruction or
               operand1
               operand1
               operand1
               macro.   Any valid form of the operand for the comparison be-
               ing performed is allowed.
 
               operand2 is the second operand of the  specified  instruction
               operand2
               operand2
               operand2
               or  macro.   Any valid form of the operand for the comparison
               being performed is allowed.
 
               mask is the mask operand of the CLM instruction  and  can  be
               mask
               mask
               mask
               any form that is valid in the instruction itself.
 
               condition may be coded as one of the following:
               condition
               condition
               condition
 
               EQ      Equal
               EQ
               EQ
               EQ
               E       Equal
               E
               E
               E
               NE      Not equal
               NE
               NE
               NE
               LT      Less than
               LT
               LT
               LT
               GT      Greater than
               GT
               GT
               GT
               LE      Less than or equal
               LE
               LE
               LE
               GE      Greater than or equal
               GE
               GE
               GE
               Z       Zero
               Z
               Z
               Z
               NZ      Not zero
               NZ
               NZ
               NZ
               M       Minus or mixed
               M
               M
               M
               NM      Not minus or not mixed
               NM
               NM
               NM
               P       Positive
               P
               P
               P
               NP      Not positive
               NP
               NP
               NP
               O       Ones or overflow
               O
               O
               O
               NO      Not ones or not overflow
               NO
               NO
               NO
               ON      All flags on
               ON
               ON
               ON
               OFF     All flags off
               OFF
               OFF
               OFF
               ANY     Any flags on
               ANY
               ANY
               ANY
               MIXED   Mixed
               MIXED
               MIXED
               MIXED
               CCnn    Condition code, CC1 through CC14
               CCnn
               CCnn
               CCnn
 
           The conditional expression coded will expand using the comparison
           instruction(s)  provided  and  appropriate  conditional branches.
           For example, instead of the expression "IF A=B,THEN",  one  would
           code "IF (CLC,A,EQ,B),THEN", which would generate a "CLC A,B" and
           a BNE instruction to the appropriate ELSE, ELSEIF or ENDIF macro.
 
           CODING CONDITIONAL EXPRESSIONS
           CODING CONDITIONAL EXPRESSIONS
           CODING CONDITIONAL EXPRESSIONS
           CODING CONDITIONAL EXPRESSIONS
           ______________________________
 
           Boolean  expressions and nested conditions are available when us-
           ing the Structured Macros.  Using the Boolean operators  AND,  OR
           and  NOT,  conditional  expressions  may be nested and/or concat-
           enated on a single macro.  Under Assembler H (IEV90),  the  depth
 
           6    Structured Macros Users's Guide
 
 
           of  nesting  is limited to 255 characters within the outer paren-
           theses.  Multiple conditions are evaluated following  the  normal
           precedence  rules  with expressions in parentheses taking preced-
           ence and NOT being done before AND, and AND being done before OR.
 
           For example, one may code:
 
              IF   NOT,(CLC,A,EQ,B)
 
           which is equivalent to:
 
              IF   (CLC,A,NE,B)
 
           Multiple conditions may be coded together, as in this example:
 
              IF   ((CLC,A,EQ,B),OR,(CLC,C,EQ,D),AND,(CLC,E,EQ,D))
 
           which is equivalent to:
 
              IF   ((CLC,A,EQ,B),OR,((CLC,C,EQ,D),AND,(CLC,E,EQ,D)))
 
           The  rules  of  Boolean  algebra  are  followed by the Structured
           Macros.  For example, the Boolean expression "NOT (x AND  y)"  is
           equivalent to "NOT (x) OR NOT (y)".  Similarly, the IF statement
 
              IF   (NOT,((CLC,A,EQ,B),AND,(CLC,C,EQ,D))),THEN
 
           and the IF statement
 
              IF   (NOT,(CLC,A,EQ,B),OR,NOT,(CLC,C,EQ,D)),THEN
 
           and the IF statement
 
              IF   ((CLC,A,NE,B),OR,(CLC,C,NE,D)),THEN
 
           will all generate identical code.
 
           Although  parentheses and the precedence rules affect the meaning
           of the expressions, the comparisons are always generated  in  the
           order  that  they  are coded.   There are two cases where this is
           significant.  Consider the following example:
 
              IF   ((CLI,A,EQ,C'Y'),AND,(C,R3,EQ,B))
 
           The second comparison will only be done if  the  first  one  suc-
           ceeds.    This can be very useful if you only have addressability
           for the second comparison if the first one is true.  Another case
           where coding order is important can be illustrated by the follow-
           ing two IF statements:
 
              IF   ((Z),OR,(CLC,A,EQ,B))
              IF   ((CLC,A,EQ,B),OR,(Z))
 
 
                                      Chapter 2. Conditional Statements    7
 
 
           In the first example, the zero conditional  test  refers  to  the
           condition code that exists from a previous instruction before the
           IF  is encountered.   In the second example, the zero conditional
           test refers to the result of the compare that precedes it.    Be-
           cause  it  is  sometimes difficult to determine which comparisons
           will actually be performed in a particular multiple condition  IF
           statement,  it is usually a good practice to put a condition test
           with no comparison only at the beginning of an IF.
 
         | USER-DEFINED CONDITIONS
           USER-DEFINED CONDITIONS
           USER-DEFINED CONDITIONS
           USER-DEFINED CONDITIONS
           _______________________
 
         | Although the conditions supported by the Structured Macros  cover
         | most  of  the  standard  types  of  comparisions, there are occa-
         | sionally instances where they are not sufficient.   To avoid  un-
         | pleasant  side-effects,  we have decided that our conditions will
         | never modify storage locations or registers.   Therefore,  we  do
         | not  have  conditions  for  things  like TRT (Translate and Test)
         | which modifies registers one and two.  In addition, many programs
         | will have tests involving more than a simple compare that they do
         | repeatedly.  It would be helpful to be able to code  these  tests
         | within a Structured Macros conditional expression.
 
         | Fortunately, there is a very easy way to get around both of these
         | situations.    The  Structured Macros provide a facility to allow
         | you to define your own  conditional  tests  that  can  be  placed
         | within  any  conditional expression.  User-defined conditions are
         | identified by a percent sign (%) and may have any number of oper-
         | ands following them.  For example, suppose you wanted to be  able
         | to code something like this:
 
         |   IF    ((TREG,R4,NZ),AND,(%TRT,0(8,R4),NE,PSDVALID))
         |   &invellip.
         |   ENDIF
 
         | Before you can use the %TRT condition, you need to do two things.
         | First, you must define the condition name itself and identify the
         | macro  that  will  process  it.    This is done with the DEFUCOND
         | macro.  Second, you must code the macro itself.  For our %TRT ex-
         | ample, these two steps would look like this:
 
         |      DEFUCOND NAME=TRT,MACRO=TRT_UCOND   | Define the condition name.
         |             MACRO
         |    &NAME    TRT_UCOND &EXPR,&S=,&F=,&L=  | Our TRT macro.
         |             AIF (N'&EXPR NE 4).ERR0001   | Were we called wrong?
         |    &NAME    TRT   &EXPR(2),&EXPR(4)      | Do TRT instruction.
         |             ##COND &EXPR(3),             | Test result and branch
         |                   S=&S,F=&F,L=&L         |   as appropriate.
         |             MEXIT
         |    .ERR0001 MNOTE 8,'Too many parameters in %TRT expr'
         |             MEND
 
           8    Structured Macros Users's Guide
 
 
         | There are several important requirements that all  user-condition
         | macros  must  meet.    Once  those  are understood, writing these
         | macros becomes quite simple.  First, the &NAME label is  required
         | and  must  identify  the  first executable statement generated by
         | your  macro.   The Structured Macros will generate a unique label
         | for &NAME so that they can branch to your condition  when  it  is
         | part of a compound conditional expression.
 
         | Next  come  the  parameters  that your macro will be called with.
         | The first parameter is positional and will be the  entire  condi-
         | tion  that  invoked this macro including the condition name.  For
         | our previous example, this would  be  (%TRT,0(8,R4),NE,PSDVALID).
                                                 (%TRT,0(8,R4),NE,PSDVALID)
                                                 (%TRT,0(8,R4),NE,PSDVALID)
                                                 (%TRT,0(8,R4),NE,PSDVALID)
         | The  individual  fields  within the condition can be extracted by
         | subscripting the expression.  For example &EXPR(3) for the  third
         | item  in  the expression (NE).  The next three keyword parameters
         | (S=, F=, and L=) define the  tag  names  that  the  macro  should
         | branch  to  on success and failure and indicate the logic of this
         | conditional (P for positive and N for negative).
 
         | The Logic keyword (L=) needs a little explaining.  Positive logic
         | says that the macro should branch to the success tag if the  con-
         | dition is true and fall through to the following code if the con-
         | dition  is false.  Positive logic is used for things like ERREXIT
         | and LEAVE.  Negative logic says to branch to the failure  tag  if
         | the  condition  is false and fall through if it is true.  This is
         | used in standard IF statements.
 
         | The ##COND macro is an internal macro that should  only  be  used
         | within  other  macros.   Its purpose is to evaluate a conditional
         | expression and properly process the S=, F=, and L= keywords.  The
         | expression passed to ##COND can  be  any  valid  conditional  ex-
         | pression  including  boolean  expressions, nested conditions, and
         | other  user-defined  conditions.    Most  user-defined  condition
         | macros will include a ##COND macro to perform the actual test and
         | process the S=, F=, and L= keywords.  This greatly simplifies the
         | macro.
 
         | For  another  example, what if you wanted to be able to check the
         | status of ISPF like this?
 
         |   IF    (%ISPFACT)
         |   &invellip.
         |   ELSE
         |   &invellip.
         |   ENDIF
 
         | You would need to define the %ISPFACT condition like this:
 
 
 
                                      Chapter 2. Conditional Statements    9
 
 
         |     DEFUCOND NAME=ISPFACT,MACRO=ISPF_UCOND
         |             MACRO
         |    &NAME    ISPF_UCOND &EXPR,&S=,&F=,&L=
         |             AIF (N'&EXPR NE 1).ERR0001   | Check number of parms.
         |    &NAME    LINK  EP=ISPQRY              | Call ISPF status routine.
         |             ##COND (TREG,R15,Z),         | Check condition code.
         |                   S=&S,F=&F,L=&L
         |             MEXIT
         |    .ERR0001 MNOTE 8,'Too many parameters in %ISPFACT expr'
         |             MEND
 
         | There are several user-defined conditions provided in a copy mem-
         | ber  called SMPUCOND.   These should provide good examples of how
         | to code user conditions and may also be useful in programs.   You
         | can  include  them  in  your  programs by placing a COPY SMPUCOND
                                                               COPY SMPUCOND
                                                               COPY SMPUCOND
                                                               COPY SMPUCOND
         | statement at the start of your program.
 
         | Note: Be careful when using conditions that modifiy registers  or
           Note:
           Note:
           Note:
         | storage  locations.   When these conditions are used as part of a
         | compound conditional expression, they can effect the other condi-
         | tions in the expression.  Be careful of your  register  usage  in
         | these  cases and remember that although some conditions in an ex-
         | pression may be skipped because of the logic, conditions are  al-
         | ways evaluated in the order they are coded.
 
 
 
 
 
 
 
 
 
 
 
           10    Structured Macros Users's Guide
 
 
                                                           CHAPTER 3. BLOCKS
                                                           CHAPTER 3. BLOCKS
                                                           CHAPTER 3. BLOCKS
                                                           CHAPTER 3. BLOCKS
                                                           _________________
 
           There  are  4  types of blocks available with the Structured Pro-
                                   ______
           gramming Macros. These are:  the program block, the inline block,
                                            _______            ______
           the subroutine, block, and the errexit block.  Each type of block
               ___________                _______
           may be named, and this name may be used as a reference on the as-
           sociated ENDBLK macro, and also on the LEAVE macro.
 
           THE PROGRAM BLOCK
           THE PROGRAM BLOCK
           THE PROGRAM BLOCK
           THE PROGRAM BLOCK
           _________________
 
           The program block encloses the main body of a program and  corre-
               _____________
           sponds  roughly  to  a  "mainline". Program blocks may not be en-
           closed by any other structure:  e.g. they must be used  at  block
                                                                       _____
           level  zero.    The program block should be the first block coded
           ____________
           for a program.   Options and the ENVIRON  keyword  on  the  BLOCK
           TYPE=PROGRAM  macro determine the type of linkage, initialization
           and other program attributes to be  established.  The  associated
           ENDBLK  macro  will  reverse  the linkage when it is executed.  A
           LEAVE macro which either names the program block or is  coded  as
           "BLOCK=*"  at the program block's block level will cause a branch
           to the ENDBLK macro, thus terminating the program.
 
           When writing a program that uses both 24-bit and 31-bit  address-
           ing under MVS/XA, a Structured Macro Workarea (SMWA) must be pro-
           vided for the macros' use.  This is automatically provided by the
           SWA  and  PWA services, or can be specified with a keyword on the
           block macro.  The SMWA is a doubleword of storage which  is  used
           to  save  work  registers  and addressing modes, thus allowing an
           AMODE change without disturbing the registers.
 
           THE INLINE BLOCK
           THE INLINE BLOCK
           THE INLINE BLOCK
           THE INLINE BLOCK
           ________________
 
           Inline blocks are generally used to  set  off  a  procedure  from
           neighboring code.  Inline blocks provide a structure which may be
           exited  with  the  LEAVE BLOCK=* macro.  Inline blocks are placed
           within the other types of blocks and may be nested  within  them-
           selves.  If desired, registers may be saved and restored when en-
           tering  and leaving an inline block by use of the SAVE operand on
           the BLOCK macro.
 
           When writing programs that will be  run  on  MVS/XA,  the  inline
           block  may  be  used to switch addressing modes "on the fly". For
           example, the program section in Figure 3 is running AMODE 31  and
           RMODE  24,  but  needs  to  issue a PUT, which requires AMODE 24.
           These instructions will generate  the  correct  sequence  of  in-
           structions  to  save the current addressing mode, switch to AMODE
 
                                                     Chapter 3. Blocks    11
 
 
           24, and then restore the saved addressing mode at the end of  the
           block.
 
 
 
             -- AMODE 31 code --
                :
             BLOCK  AMODE=24
              PUT   SYSPRINT,RECORD
             ENDBLK
                :
             -- AMODE 31 code --
 
             Figure 3.  Switching AMODE
 
 
           THE SUBROUTINE BLOCK
           THE SUBROUTINE BLOCK
           THE SUBROUTINE BLOCK
           THE SUBROUTINE BLOCK
           ____________________
 
           Subroutine  blocks  contain  code that is reached via the CALLSUB
           macro.  Subroutines coded in this manner must be at  block  level
           zero  (i.e. cannot be contained within any other block).  Subrou-
           tine blocks should be coded after the program block to which they
           belong.  Subroutine blocks are meant for "internal"  subroutines,
           not  for  a  called program that follows standard OS linkage con-
           ventions.
 
           A subroutine block is called by CALLSUB using "BAL   R14,routine"
                                                         ___________________
           or an equivalent sequence.  By using the SAVE operand,  the  sub-
           routine may have some or all of its registers saved and restored,
           although  its  use is optional.   If Subroutine Work Areas (SWAs)
           are used, registers R0-R14 are automatically saved in the SWA and
           restored when the subroutine is exited.  In this case,  the  SAVE
           operand is invalid.  The user can also specify that the USING en-
           vironment  should  be  saved  and restored around the subroutine.
           This prevents any USINGs within the subroutine from affecting the
           rest of the program.  Furthermore, a subroutine may request  that
           its AMODE be switched and restored on entry and exit by using the
           AMODE operand.
 
           The CALLSUB macro uses register 14 to link to the subroutine, but
           all other registers will have the same value on entry to the sub-
           routine  that  they  had in the calling program.  However, if Dy-
           namic Storage Management or the  LONG  program  option  is  used,
           register  15  will also be destroyed by the CALLSUB linkage.  See
           "Chapter 6. Large Program Management" on page 24 for more  infor-
           mation on dynamic storage.
 
 
 
           12    Structured Macros Users's Guide
 
 
           THE ERREXIT BLOCK
           THE ERREXIT BLOCK
           THE ERREXIT BLOCK
           THE ERREXIT BLOCK
           _________________
 
           The  errexit block is executed whenever an ERREXIT macro that re-
           fers to it is executed. Like the subroutine  block,  the  errexit
           block  must  be coded at block level zero.  Errexit blocks should
           be coded with the subroutine blocks after the  program  block  to
           which  they belong.   The ENDBLK macro associated with an errexit
           block generates a branch to the program block's ENDBLK expansion,
           and also allows you to specify a return code with which the  pro-
           gram  will terminate.  This return code overrides any return code
           that may appear on the program block's ENDBLK macro.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                     Chapter 3. Blocks    13
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           14    Structured Macros Users's Guide
 
 
                                             CHAPTER 4. PROGRAM ENVIRONMENTS
                                             CHAPTER 4. PROGRAM ENVIRONMENTS
                                             CHAPTER 4. PROGRAM ENVIRONMENTS
                                             CHAPTER 4. PROGRAM ENVIRONMENTS
                                             _______________________________
 
           There  are several types of environments for which the Structured
           Macros contain explicit support.  These environments are selected
           with the ENVIRON keyword of the program block macro.   The  envi-
           ronments  are: the "OS" program environment which supports stand-
           ard OS linkages; the  "DC"  program  environment  which  supports
           Cullinet  IDMS/DC  linkage;  and the "PLI" environment which sup-
           ports the execution time environment of release 5 of the OS Opti-
           mizing Compiler.  Other types of environments can be accommodated
           by coding your own linkage.
 
           The options and keywords on  the  program  and  subroutine  block
           macros  allow  you to control virtually all phases of the program
           linkage as well as the Structured Macros options.  All of the ma-
           jor initialization and termination functions are  represented  by
           their  individual  keywords.   However, there are certain program
           types that occur frequently.   To  cut  down  on  the  number  of
           options  that  need to be coded to represent these program types,
           the super options can be used.  They contain the correct combina-
           tion of options for the most common program  types.    The  super
           options for each environment are discussed in their corresponding
           sections below.
 
           DC ENVIRONMENT
           DC ENVIRONMENT
           DC ENVIRONMENT
           DC ENVIRONMENT
           ______________
 
           Specifying  ENVIRON=DC  generates support for programs to execute
           in the IDMS/DC run-time environment.  This support is  relatively
           new and perhaps does not support all of the functions required by
           its  users:  however,  a  basic  set of options and super options
           should satisfy most IDMS/DC programmers' needs.
 
           System Mode And User Mode
           System Mode And User Mode
           System Mode And User Mode
           System Mode And User Mode
           _________________________
 
           IDMS/DC programs generally are called in either  system  mode  or
                                                            ____________
           user mode. As a rule, user-mode programs are called by a #LINK or
           _________
           #XCTL  and  use  #RETURN to return to their caller, while system-
           mode programs are called by #CALL and return with #RTN, and  also
           have  a  slightly  different  set  of  register  and linkage con-
           ventions.  IDMS/DC applications whose program names  are  invoked
           by  a  task  code  or  called by #LINK or #XCTL are almost always
           user-mode programs, while DC numbered exits and map edit routines
           are usually system-mode programs.   Both types are  supported  by
           ENVIRON=DC.
 
 
                                       Chapter 4. Program Environments    15
 
 
           Reentrancy Under IDMS/DC
           Reentrancy Under IDMS/DC
           Reentrancy Under IDMS/DC
           Reentrancy Under IDMS/DC
           ________________________
 
           Since  any  IDMS/DC program may be in use by several users at any
           given time, reentrancy in application programs and DC system rou-
           tines is much more valuable than under the standard MVS  environ-
           ment.  The  savings  in  execution  time  gained  by  avoiding  a
           #GETSTG/#FREESTG  and  management of a reentrant program workarea
           are usually far outweighed by the program pool savings and avoid-
           ance of program management overhead gained by  making  a  program
           truly reentrant. System-mode programs, where speed and efficiency
           are prime considerations, can take advantage of IDMS/DC's #GETSTK
           service  for "fast storage" if their PWA storage requirements are
           small.
 
           *NORENT
           *NORENT
           *NORENT
           *NORENT
           _______
 
           A non-reentrant user-mode program in  IDMS/DC  terms  means  bas-
           ically  the same as a non-reentrant program under the OS environ-
           ment: IDMS/DC does not  allow  users  to  share  a  copy  of  the
           program,  but loads a new copy each time a new user requests one.
           As a result, the program can contain  its  variables  within  its
           CSECT without having to acquire storage from IDMS/DC for them.
 
           *NORENTSYS
           *NORENTSYS
           *NORENTSYS
           *NORENTSYS
           __________
 
           This super option defines a non-reentrant system mode program for
           IDMS/DC.  This option is provided for consistency: however, it is
           recommended that any system mode program be  assembled  as  reen-
           trant, using either the *RENTSYS or *PWASYS super option.
 
           *RENT
           *RENT
           *RENT
           *RENT
           _____
 
           Reentrancy  in  an  IDMS/DC  user  mode program allows IDMS/DC to
           share a single copy of the program among multiple users, and also
           allows the program to be loaded into the IDMS/DC  reentrant  pro-
           gram  pool.    The *RENT super option causes reentrant linkage to
           occur, but does not acquire any variable storage for the program.
 
 
 
           16    Structured Macros Users's Guide
 
 
           *RENTSYS
           *RENTSYS
           *RENTSYS
           *RENTSYS
           ________
 
           The *RENTSYS super option causes reentrant linkage to  occur  for
           an IDMS/DC system mode routine. Like *RENT, *RENTSYS does not ac-
           quire  any variable storage for the program: thus, if local vari-
           able storage is not needed, the overhead of #GETSTG/#FREESTG  can
           be avoided.
 
           *PWA
           *PWA
           *PWA
           *PWA
           ____
 
           The  *PWA  super  option  causes a #GETSTG and #FREESTG to be in-
           cluded in the linkage and delinkage for the program, thus  allow-
           ing  reentrancy and providing storage for variables. This process
           (except for actually acquiring the storage) is basically the same
           as described in the *PWA section under "*PWA" on page 16.
 
           *PWASYS
           *PWASYS
           *PWASYS
           *PWASYS
           _______
 
           This is generally the option that system-mode programs would  use
           if  they  have  any need for variable storage. If a small PWA (10
           fullwords or less) is all that's needed, the option GETSTK can be
           coded among the program block's OPTIONS: this causes  #GETSTK  to
           be  used  to  acquire variable storage from the task's TCE stack,
           which is much faster than calling #GETSTG and #FREESTG.
 
           OS ENVIRONMENT
           OS ENVIRONMENT
           OS ENVIRONMENT
           OS ENVIRONMENT
           ______________
 
           The OS environment is the default environment and supports stand-
           ard OS linkage.  By specifying different options,  you  can  have
           the  Structured  Macros do as little or as much of the linkage as
           desired.  For most situations, there are super options that  will
           pick the correct set of options for you.
 
           *NORENT
           *NORENT
           *NORENT
           *NORENT
           _______
 
           If  a program is non-reentrant, the system will load a fresh copy
           of it every time the program is invoked.   Because of  this,  the
           program  is allowed to modify itself.  Data and work areas can be
           stored in the load module itself.  Most user programs can be non-
           reentrant.  The *NORENT super option will automatically define  a
 
                                       Chapter 4. Program Environments    17
 
 
           save  area  in  the  program ID section and perform non-reentrant
           linkage.
 
           *RENT
           *RENT
           *RENT
           *RENT
           _____
 
           Since reentrant programs are not reloaded every time they are in-
           voked,  they  are  not  allowed to modify any fields within them-
           selves.  Any data that might be  modified  must  be  copied  into
           working  storage  that  has  been  GETMAINed, and modified there.
           This preserves the integrity of the load module for other  users.
           The  *RENT  super  option provides the reentrant linkage and will
           automatically GETMAIN storage for a save area.   No provision  is
           made  for a Program Work Area (PWA).  Any storage (other than the
           save area) needed by the program must be acquired  by  the  user.
           Because  of  this,  the *RENT super option is not very useful for
           new programs.  *PWA provides much better  support  for  reentrant
           programs.  (see below)  *RENT was included to provide support for
           those programs that already acquire their own storage or that for
           some reason could not use the storage provided by *PWA.
 
           *PWA
           *PWA
           *PWA
           *PWA
           ____
 
           *PWA provides all the functions of *RENT, plus it  will  automat-
           ically  GETMAIN  and FREE a Program Work Area (PWA) for the user.
           The best way to illustrate this is with an example:
 
              BLOCK NAME=MAINPROG,TYPE=PROGRAM,OPTIONS=(*PWA)
                     :
                     :
              ENDBLK BLOCK=MAINPROG
              PSD
                     :
                Static Data
                     :
              ENDPSD
              PWA
                     :
                Work Area
                     :
              ENDPWA
 
           In the example above, the static data (constants and  other  data
           that are not modified by the program) is placed at the end of the
         | program  in  an  area called the PSD (Program Static Data) and is
           included in the load module.  The PWA and ENDPWA macros define  a
           DSECT  for  a block of storage that will be acquired for the user
           by the BLOCK macro and freed at the end of the  program.    Space
           for  the  save  area is automatically reserved in the PWA, so the
 
           18    Structured Macros Users's Guide
 
 
           user does not need to worry about this.  The user simply needs to
           define any work area fields that the program  needs  between  the
           PWA  and  ENDPWA  macros.   After this storage is acquired by the
           BLOCK macro, it is cleared for the user and addressability is set
           up  using register 13.  This super option makes writing reentrant
           programs almost as easy  as  writing  non-reentrant  ones.    The
           bothersome  details of computing storage requirements, GETMAINing
           storage, keeping up with addresses, and FREEMAINing the  acquired
           storage are handled by the Structured Programming Macros.
 
           The *PWA option and the PWA macro also provide a variety of other
           features that are described in more detail in "Chapter 5. Program
           and Subroutine Work Areas" on page 20.
 
           *MAIN
           *MAIN
           *MAIN
           *MAIN
           _____
 
           The  *MAIN  super option provides all of the features of *PWA and
           adds the options DYN and MAIN.  This allows SWAs to be  allocated
           from  dynamic  storage instead of being statically defined in the
           PWA.  See "Chapter 6. Large Program Management" on  page  24  for
           more  information  on  dynamic  storage.   The *MAIN super option
           should be used on the program block for  any  main  program  that
           uses dynamic storage.
 
           *NOMAIN
           *NOMAIN
           *NOMAIN
           *NOMAIN
           _______
 
           The  *NOMAIN  super  option provides all of the features of *MAIN
           except that it specifies option NOMAIN instead of MAIN.  This su-
           per option should be used on a program block that  represents  an
           external subroutine that will be called from another program that
           uses dynamic storage.
 
           *SRVPRC
           *SRVPRC
           *SRVPRC
           *SRVPRC
           _______
 
           The *SRVPRC super option is used by service processors.  Refer to
           Clemson University Computer Center Service Processor User's Guide
           _________________________________________________________________
           and Reference for more information on this super option.
           _____________
 
           PL/I ENVIRONMENT
           PL/I ENVIRONMENT
           PL/I ENVIRONMENT
           PL/I ENVIRONMENT
           ________________
 
           ENVIRON=PLI  supports the execution time environment of release 5
           of the OS PL/I Optimizing Compiler.   At the  current  time  this
 
                                       Chapter 4. Program Environments    19
 
 
           support  is  minimal, but it should satisfy the needs of most as-
           sembler programs that run as subroutines to PL/I programs and use
           the PL/I environment.
 
           *STDPLI
           *STDPLI
           *STDPLI
           *STDPLI
           _______
 
           This  is the only PL/I environment super option and should always
           be specified.  The Structured Macros' support of PL/I is  not  as
           fully  developed as it is for the OS and DC environments.  Speci-
           fying this option will help insure future compatibility.
 
           This super option will provide the proper reentrant linkage for a
           majority of assembler programs that run in an OS PL/I  Optimizing
           Compiler  execution  time environment.  Storage is obtained for a
           PWA in the same manner as a PL/I program obtains storage for  its
           DSA.  A DSA in PL/I contains an OS save area, control information
           and program variables.
 
           OTHER ENVIRONMENTS
           OTHER ENVIRONMENTS
           OTHER ENVIRONMENTS
           OTHER ENVIRONMENTS
           __________________
 
           If you want to use the Structured Macros in other than one of the
           explicitly  supported environments, you can code your own linkage
           or add support for the environment with prolog and epilog macros.
 
           If you want to code your own linkage, let the environment default
           to OS and do not code any linkage-related options.  Put your  own
           linkage before or after the program block macro and after the end
           block macro for the program.  If you do your own linkage you will
           not be able to use PWAs, SWAs, PSDs, SSDs or anything related.
 
           If  the  Structured Macros will be used often in this environment
           or if you need to use PWAs, etc., it may be worth the time to add
           support for the environment.  Refer to the internals  manual  for
           the  Structured  Macros  for  information  on  writing prolog and
           epilog macros if you would like to take this approach.
 
           To add support for an environment requires a thorough understand-
           ing of the internals of the Structured Macros and the support may
           have to be updated each time the Structured Macros themselves are
           updated.  If the environment needed is of general  interest,  you
           may  want  to  request that it be added as a standard part of the
           Structured Macros and supported as such.
 
 
 
           20    Structured Macros Users's Guide
 
 
           SUBROUTINE BLOCK SUPER OPTIONS
           SUBROUTINE BLOCK SUPER OPTIONS
           SUBROUTINE BLOCK SUPER OPTIONS
           SUBROUTINE BLOCK SUPER OPTIONS
           ______________________________
 
           Currently, all environments use the same subroutine block options
           and super options.
 
           *SWA
           *SWA
           *SWA
           *SWA
           ____
 
           In any program that uses the PWA option, the internal subroutines
           for that program can each have an individual Subroutine Work Area
           (SWA).    The  *SWA  super  option is specified on the subroutine
           block (or the SUBOPTS= on the program block) to  provide  an  SWA
           for a subroutine.  There are SWA and ENDSWA macros to delimit the
           SWA  just  as the PWA was delimited.  The details about the func-
           tions of an SWA and its relation to a PWA are described in "Chap-
           ter 5. Program and Subroutine Work Areas" on page 20.
 
           *NOSUBOPTS
           *NOSUBOPTS
           *NOSUBOPTS
           *NOSUBOPTS
           __________
 
           This super option clears all the subroutine options to their "no"
           state.  If the program block has specified a default set of  sub-
           routine  options with the SUBOPTS= keyword, this super option can
           be used on a subroutine block  to  create  a  subroutine  without
           those default options.  For example, a *NOSUBOPTS,CUSTOM might be
           coded to create a subroutine with just the CUSTOM option.
 
           CONCLUSION
           CONCLUSION
           CONCLUSION
           CONCLUSION
           __________
 
           The  environment  support and super options make programming much
           easier, since all of the tedious initialization  and  termination
           details  are taken care of with a minimum of effort.  This allows
           you to worry about program logic, and not the linkage.  They also
           do not lock you into only these combinations of options.  If  you
           wish  to  override  any  of the options in a super option, simply
           code them after the super option on the OPTIONS=  keyword.    For
           example:
 
              BLOCK  TYPE=PROGRAM,NAME=PROG,OPTIONS=(*PWA,XA,NOREGEQU),ENVIRON=O
 
 
 
                                       Chapter 4. Program Environments    21
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           22    Structured Macros Users's Guide
 
 
                                CHAPTER 5. PROGRAM AND SUBROUTINE WORK AREAS
                                CHAPTER 5. PROGRAM AND SUBROUTINE WORK AREAS
                                CHAPTER 5. PROGRAM AND SUBROUTINE WORK AREAS
                                CHAPTER 5. PROGRAM AND SUBROUTINE WORK AREAS
                                ____________________________________________
 
           The  Program and Subroutine Work Area (PWA and SWA) support built
           into the Structured Programming Macros is a  powerful  tool  that
           can  be invaluable to someone writing a complex program, and also
           provides services that can be useful in even a  relatively  small
           program.    Although PWAs and SWAs are normally used in reentrant
           programs, even non-reentrant programs can take advantage  of  the
           services  they provide.  If option NORENT is in effect, the stor-
           age for the work areas will be defined in the load module instead
           of being dynamically obtained at execution time.
 
           PROGRAM WORK AREAS
           PROGRAM WORK AREAS
           PROGRAM WORK AREAS
           PROGRAM WORK AREAS
           __________________
 
           The PWA option and PWA macro provide many services  besides  just
           defining  a  block  of  storage  to be obtained for the user.  By
           specifying that the program will  have  a  PWA,  you  allows  the
           Structured  Macros  to automatically perform many functions.  For
           example, space for a SMWA for the main program and one  for  each
           of  the  subroutines  will  be reserved in the PWA preventing you
           from having to code the SMWA= keyword on the program block.    If
           you  wish  to  override this and force the SMWA to a specific lo-
           cation, the SMWA= keyword can still be used.
 
           Also, you can have parameter lists placed in the PWA without hav-
           ing to explicitly define storage for them.  The Structured Macros
           can compute the largest parameter list in the program and reserve
           enough space in the PWA.  A separate parameter list area  is  re-
           served for the program and each subroutine.  This is required be-
           cause  the  program  parameter  storage  may  be  in  use  when a
           subroutine is called.  For more information on  parameter  lists,
           see  "Chapter  10.  Parameter Lists and Standard Linkage" on page
           34.
 
           Option PWA allows you to define a Subroutine Work Area (SWA)  for
           each  subroutine  that  contains  any  work  area fields that are
           needed only while the subroutine is executing.  This SWA is anal-
           ogous to the PWA for the program.
 
         | REUSABLE PROGRAM WORK AREAS
           REUSABLE PROGRAM WORK AREAS
           REUSABLE PROGRAM WORK AREAS
           REUSABLE PROGRAM WORK AREAS
           ___________________________
 
         | Under normal circumstances, the PWA for a program will  be  allo-
         | cated  whenever  the program is called, and freed before the pro-
         | gram terminates.   However, there are cases  when  a  program  is
         | loaded  into memory once, and called repeatedly to perform a par-
         | ticular function.  Not only would it be inefficient to repeatedly
 
                          Chapter 5. Program and Subroutine Work Areas    23
 
 
         | acquire and free storage for this program, it may cause  problems
         | if the program is required to retain information between calls.
 
         | This  problem  is  solved  by a mechanism known as Reusable PWAs.
                                                              _____________
         | Using this capabilility, the Structured Macros will only allocate
         | a new PWA when given a start-up call and will not free the  stor-
         | age  when  the program terminates.  When the program detects that
         | it is being called for the final time, it can issue  a  macro  to
         | instruct  the  Structured  Macros  to free the PWA storage at the
         | termination of the current invocation.
 
         | When reusable PWAs are being used, the caller of the program must
         | keep track of the PWA address and pass it in the  parameter  list
         | on  every call.  The position of the PWA address in the parameter
         | list is customizable.   If this  address  is  binary  zeros,  the
         | Structured  Macros  will allocate storage for a new PWA and store
         | its address back into the parameter list.   Otherwise, they  will
         | use the passed value.
 
         | Alternatively,  you  can specify a parameter position for a func-
         | tion code that will be provided on every call and  a  value  that
         | means  "Start".  With this form, the Structured Macros will allo-
         | cate a new PWA on the Start call, and use the passed PWA value in
         | other cases.
 
         | When the program is in its final invocation (either because of an
         | error or when called to terminate), the SMCTRL macro is  used  to
         | force  the  Structured  Macros  to free the PWA at program termi-
         | nation.
 
         | This concept is used heavily at Clemson by what we  call  Service
                                                                     _______
         | Processors.    These  are programs that are started once and then
           __________
         | called repeatedly to perform a particular  type  of  service  for
         | their  invoker.    File handling, string manipulation, and symbol
         | management are all examples of functions that may be  handled  by
         | service  processors.   For more information about the workings of
         | Service Processors, see Clemson University Computer  Center  Ser-
                                   _________________________________________
         | vice Processor User's Guide and Reference.
           _________________________________________
 
           SUBROUTINE WORK AREAS
           SUBROUTINE WORK AREAS
           SUBROUTINE WORK AREAS
           SUBROUTINE WORK AREAS
           _____________________
 
           Any  subroutine  that will be using an SWA should use the SWA and
           ENDSWA macros to define its  boundaries,  just  as  the  PWA  and
           ENDPWA  macros are used for the program's PWA.  There are options
           on the subroutine block to control SWA usage, and a super  option
           (*SWA)  that  provides the correct combination of options for SWA
           usage.
 
           SWAs provide useful functions for subroutines just as PWAs do for
           programs.  SMWAs and parameter lists for the subroutines are cre-
           ated as part of the SWA instead of as PWA fields.  R0-R14 are au-
 
           24    Structured Macros Users's Guide
 
 
           tomatically saved and restored for any  subroutine  that  has  an
           SWA.   Space for this is reserved by the SWA macro, so you do not
           have to code the SAVE keyword, or explicitly reserve  the  space.
           The  registers  are  saved  as R0-R14 so that R15 will not be re-
           stored and the subroutine can pass a return  code  back  in  this
           register.
 
           You  should  be aware of the implications of saving and restoring
           registers.  Because of this, a subroutine can not pass  back  any
           values  to  its caller by way of the registers.  It would have to
           use the PWA to pass back any information.   To  get  around  this
           problem, the STRSA macro was created.  This macro stores the cur-
           rent  value  of  a  register in the SWA save area for the current
           subroutine.  Then when the subroutine ends, the register will  be
           restored to the value it had when the STRSA macro was issued, in-
           stead  of  the  value it had when the subroutine was called.  You
           can use the STRSA macro to pass back any registers that the call-
           ing routine needs, while allowing the other registers to  be  re-
           stored to their original values.
 
           There  is  a CLEARPWA option on program blocks that instructs the
           macros to clear the PWA after it has been obtained.  This  option
           is included in all of the super options that use PWAs so that you
           can count on the PWA being all zeros on entry.  However, there is
           not  a  similar  option on the subroutine block to clear the SWA.
           You should never count on the SWA contents anytime  a  subroutine
           is  entered.    If  the fields within the SWA need to be set to a
           specific value, the subroutine must include  code  to  initialize
           these fields.
 
           These  functions of SWA usage can be a great help to the program-
           mer, even the subroutine does not need to have  any  of  its  own
           fields  defined  in  the SWA.   If you select the SWA option, the
           Structured Macros will generate an SWA for internal use in saving
           registers, etc. even if you do not code the SWA and ENDSWA macros
           at the end of your subroutine.
 
           SWA PLACEMENT
           SWA PLACEMENT
           SWA PLACEMENT
           SWA PLACEMENT
           _____________
 
           With the *PWA option, these SWAs will be included as part of  the
           PWA for the program to which they belong.  They will be placed in
           the  PWA's partial area and addressability will be off of the PWA
         | register (R13).  This configuration of PWAs and SWAs  is  changed
         | in  programs that use the Structured Macros' dynamic storage man-
         | agement support.  For more information on  this,  see  "PWAs  and
         | SWAs with Dynamic Storage Management" on page 24.
 
 
 
                          Chapter 5. Program and Subroutine Work Areas    25
 
 
           PSDS AND SSDS
           PSDS AND SSDS
           PSDS AND SSDS
           PSDS AND SSDS
           _____________
 
           The PSD and SSD macros (and their respective end macros) are used
           to  define  the Program and Subroutine Static Data areas, just as
           PWA and SWA are used to define the work areas.  These macros  are
           used in conjunction with the LOCTR option on the program block to
           insure  proper  placement  of  the  program code and static data.
           They also allow fields to be defined from within the program code
           that will be placed with the static data when the program is  as-
           sembled.    This  facility  is used by the EXI macro.  These data
         | areas are addressed off of the same base registers as the program
         | and subroutine code.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           26    Structured Macros Users's Guide
 
 
                                         CHAPTER 6. LARGE PROGRAM MANAGEMENT
                                         CHAPTER 6. LARGE PROGRAM MANAGEMENT
                                         CHAPTER 6. LARGE PROGRAM MANAGEMENT
                                         CHAPTER 6. LARGE PROGRAM MANAGEMENT
                                         ___________________________________
 
           As  a  program becomes larger and contains more subroutines, cer-
           tain problems arise.  The PWA (which contains  an  SWA  for  each
           subroutine)  can grow to an unmanageable size.  Also, the program
           code along with the subroutine code can become so  long  that  it
           would  take  several  base  registers to maintain addressability.
           The Structured Macros provide two tools to help manage such large
           programs.  They are Dynamic Storage Management and the  LONG  and
           LOADBASE  options.   Dynamic Storage Management is only available
           for program blocks which are using ENVIRON=OS.
 
           PWAS AND SWAS WITH DYNAMIC STORAGE MANAGEMENT
           PWAS AND SWAS WITH DYNAMIC STORAGE MANAGEMENT
           PWAS AND SWAS WITH DYNAMIC STORAGE MANAGEMENT
           PWAS AND SWAS WITH DYNAMIC STORAGE MANAGEMENT
           _____________________________________________
 
           If your program has a large number of internal  subroutines  that
           heavily  use  SWA storage, the size of the PWA can easily grow to
           an unmanageable size.  If the fields defined in the SWA  are  re-
           ally only necessary when the subroutine is active, it is not nec-
           essary to allocate enough space for all of the SWAs.  Only enough
           storage to contain the PWA itself, and the largest combination of
           active  SWAs  is required.  If there were some way to dynamically
           allocate and free SWA storage as subroutines were entered and ex-
           ited, a great savings in storage could be realized.
 
           To solve this problem, the storage for an SWA could be  GETMAINed
           as the subroutine is entered and FREEd at the end, but this would
           slow down the operation of the program greatly.
 
           A  much more efficient system is to obtain a large block of stor-
           age at the beginning of the program, allocate the first  part  to
           the  PWA,  and  allocate  the rest to SWAs as it is needed.  This
           block of storage can be much smaller than the  size  of  the  PWA
           plus  all  of  the SWAs, since not all of the subroutines will be
           active at once.  Also, since new SWA storage is allocated  for  a
           subroutine  each  time  it  is entered, subroutines can be called
           recursively.  With this system, a GETMAIN is never done more than
           once for a single program.  Enough storage is allocated  for  all
           the  program and subroutines' needs at the beginning, and storage
           is assigned and taken back as subroutines are entered and exited.
 
           This is just what the Structured Macros' Dynamic Storage  Manage-
           ment does. The DYN option on the program block is used to turn on
           Dynamic  Storage Management.  Dynamic Storage also allows subrou-
           tines to call themselves, which  adds  more  complexity.    Also,
           there  is  hidden recursion, such as when subroutine A calls sub-
           routine B, and subroutine B in turn calls subroutine A.
 
 
                                   Chapter 6. Large Program Management    27
 
 
           Recursive Subroutines with the DYN Option
           Recursive Subroutines with the DYN Option
           Recursive Subroutines with the DYN Option
           Recursive Subroutines with the DYN Option
           _________________________________________
 
           Recursive subroutines cause another  problem.    Since  they  are
           called  again without the previous invocation being ended, multi-
           ple copies of the subroutine's SWA need to be allocated from  dy-
           namic  storage.    Since  the  Structured  Macros  have no way of
           knowing  how deep the recursion might go, you need to supply this
           information.  On any subroutine that will be  called  recursively
           (this  includes  all the programs in a recursive loop such as the
           one described above), you need to use the RECUR keyword  to  tell
           the  macros  the  maximum  number of times the subroutine will be
           called recursively.   This keyword  tells  the  macros  how  many
           copies  of  that  subroutines  SWA  could  be active at once, and
           therefore how much room to allocate.  If you miscalculate on  the
           RECUR  keyword,  the  Structured  Macros will miscalculate on the
           space required.  If you use too big a number, the macros will al-
           locate more space than is needed.  If you use too small a number,
           the macros will allocate too little space, and a dynamic  storage
           error  will  result.   By default, the macros will force an ABEND
           0C1 when your program runs out of dynamic storage.  However,  you
           can specify an error exit that will get control when this happens
           with the DYNERR keyword on the program block.
 
           Storage Calculations with the DYN Option
           Storage Calculations with the DYN Option
           Storage Calculations with the DYN Option
           Storage Calculations with the DYN Option
           ________________________________________
 
           The  Structured  Macros' algorithm is very comprehensive and will
           allocate enough space for all known cases.  It uses  an  internal
           macro called ##ORGS to trace the subroutine call structure of the
                        ______
           program.    From this, it determines the subroutines that will be
           active together, and how big their SWAs are.  Using this informa-
           tion and the size of the PWA, the macros determine how much space
           they will need to GETMAIN to  accommodate  your  program.    This
           tracing of the subroutine structure is more difficult than it may
           seem,  since  the  main program and each subroutine may call many
           other subroutines forming a very complex tree.    However,  there
           are certain very complicated and unlikely combinations of subrou-
           tines  that  will trick them into allocating more space than they
           need.  If this ever becomes a problem, it can  be  adjusted  with
           the DYNSIZE keyword on the program block.  The DYNSIZE keyword is
           used  to  replace  or  adjust the value for the amount of dynamic
           storage calculated by the macros.   It can  be  used  in  certain
           cases to fine-tune the dynamic storage requirements.  However, in
           most  cases  the  macros  themselves should calculate the correct
           amount, and the DYNSIZE keyword should not be needed.
 
 
 
           28    Structured Macros Users's Guide
 
 
           SWA Addressability with the DYN Option
           SWA Addressability with the DYN Option
           SWA Addressability with the DYN Option
           SWA Addressability with the DYN Option
           ______________________________________
 
           These SWAs will be based off of register 11, while the subroutine
           itself will be addressed off of the program  base,  and  the  PWA
           base  will remain with register 13.  It should be noted that reg-
           ister 11 will be in use in DYN programs even  when  a  subroutine
           has not been invoked.
 
           Super Options Used with the DYN Option
           Super Options Used with the DYN Option
           Super Options Used with the DYN Option
           Super Options Used with the DYN Option
           ______________________________________
 
           There  are  two  program block super options for use with Dynamic
           Storage Management.  They are *MAIN and *NOMAIN.  *MAIN  contains
           all  of  the  options in *PWA plus the options DYN and MAIN.  The
           MAIN option tells DYN that this is a main program  and  that  dy-
           namic  storage should always be obtained when this program is en-
           tered.   By contrast,  *NOMAIN  says  that  this  program  is  an
           external  subroutine that will be called from a main program that
           uses DYN.   In a *NOMAIN program,  the  dynamic  storage  of  its
           caller  will  be  used if there is enough of it.  Otherwise, more
           storage will be GETMAINed to accommodate the program and its sub-
           routines.  It should be emphasized that a program  compiled  with
           option *NOMAIN should only be called from a program that uses Dy-
                                 only
                                 only
                                 only
           namic  Storage Management.   Even if the *NOMAIN program GETMAINs
           its own storage, it requires that registers and storage areas  be
           set up by the calling program.
 
           Any  *MAIN program that will be calling external subroutines with
           *NOMAIN might need to use the DYNSIZE keyword to adjust  its  dy-
           namic  storage  to  allow  for what the *NOMAIN program will use.
           Since the *NOMAIN program will  most  likely  be  compiled  sepa-
           rately,  there  is  no way for the Structured Macros to calculate
           its requirements.  However, since the *NOMAIN will get more stor-
           age if it needs it, adjusting the storage on  the  *MAIN  program
           will only affect performance by preventing an extra GETMAIN.
 
           Storage Optimization with the DYN Option
           Storage Optimization with the DYN Option
           Storage Optimization with the DYN Option
           Storage Optimization with the DYN Option
           ________________________________________
 
           When  using the DYN option, there is a short routine added to the
           beginning of each internal subroutine  to  obtain  the  new  SWA.
           This is not a real problem, but if the program has a large number
           of  small  subroutines,  this can significantly lengthen the load
           module.  If the size of the load module is critical, the  OPTSTOR
           option can be used on the program block to help remedy this.  The
           OPTSTOR  option will create a single copy of the subroutine link-
           age code and have each subroutine branch to it.  This makes  sub-
           routine  calls  slower,  but  will  reduce  the  size of the load
 
                                   Chapter 6. Large Program Management    29
 
 
           module.  However, space is rarely this critical, so  the  OPTSTOR
           option should not be needed in most cases.
 
           LONG AND LOADBASE
           LONG AND LOADBASE
           LONG AND LOADBASE
           LONG AND LOADBASE
           _________________
 
           When  a  program  gets  to be very long with a lot of subroutines
           (such as a server routine or a command processor), the CSECT  can
           become  so large that it takes two, three, or even more base reg-
           isters to maintain addressability.  It would be nice if there was
           some way to allow a subroutine to have its own base register sep-
           arate from the program's base register.  The LOADBASE  option  on
           subroutine  blocks  and the LONG option on the program block pro-
           vide this support.
 
           The LOADBASE option on the subroutine block instructs the subrou-
           tine linkage routines to establish a separate  addressability  to
           that  subroutine using the subroutine base register.  This regis-
           ter defaults to R10, but another register can  be  selected  with
           the  BASEREG= keyword.  Any subroutines coded in this manner will
           be located at the end of the CSECT, so that they will not  inter-
           fere with the program's addressability.
 
           If  a  program  has any subroutines that use the LOADBASE option,
           the program block must have the LONG option coded.   This  option
           causes  CALLSUB to generate the correct linkage for LOADBASE sub-
           routines.  Since both of these options make use of partial  PSDs,
           the  LOCTR  option  is  also required when using these.  However,
           LOCTR is included in all of the super  options,  so  usually  you
           will not have to code it.
 
           With  this  scheme,  the macros always keep a base to the program
           and to the current subroutine.   Therefore, the program  will  be
           able  to  address  anything in the program and its PSD as well as
           the current subroutine and its SSD.  However, one subroutine can-
           not address anything in another subroutine's SSD.   If  you  have
           any  static data that will be shared among subroutines, it should
           be placed in the PSD.
 
           Since a separate base register is kept for the  program  and  the
           current subroutine, this facility is only useful in programs that
           already  need  two  or more base registers.   However, with these
           options the program base register only needs to address the  main
           program  code  and its static data.  If even this can not be done
           with a single base register, the main program code can  be  moved
           to  an internal subroutine with only a single CALLSUB in the pro-
           gram block.
 
 
 
           30    Structured Macros Users's Guide
 
 
           SIZE LIMITATIONS
           SIZE LIMITATIONS
           SIZE LIMITATIONS
           SIZE LIMITATIONS
           ________________
 
           With the techniques described here, a very large program  can  be
           created  quite easily.   Although most programmers will never ex-
           ceed the Structured Macros' limits, it may be useful to know just
           how large a program can become.  The only limitation  on  program
           length (and it's static data) is the number of base registers you
           are willing to use to address it.  But with the LONG and LOADBASE
           options,  this  is  not necessarily a problem.  PWAs can be up to
           16M in size, but again you must maintain  addressibility  on  it.
           SWAs  can  be up to a maximum of 32K in size if DYN is in effect.
           If the majority of one of your data or work  areas  is  a  single
           very  large data area that you only need to address the start of,
           you can place it at the end of the data area.   The  user  fields
           always go after the fields generated by the Structured Macros.
 
           CONCLUSION
           CONCLUSION
           CONCLUSION
           CONCLUSION
           __________
 
           The  long program management routines provide very useful support
           for large or memory intensive  programs.    A  great  savings  in
           GETMAINed  storage can be achieved in programs with large numbers
           of subroutines, and many of the  tedious  details  of  subroutine
           linkage  and program storage can be automated.  A savings in base
           registers can also be achieved in extremely long programs.    For
           more  information  on  the  actual layout of dynamic storage, see
           "Appendix C. Work Area Storage Layout" on page 129, while  a  de-
           scription  of program code and static data layout can be found in
           "Appendix D. Program Code and Static Data  Layout"  on  page  135
           along with an example of how these options should be coded.
 
 
 
 
 
 
 
 
                                   Chapter 6. Large Program Management    31
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           32    Structured Macros Users's Guide
 
 
                                                 CHAPTER 7. THE IF STRUCTURE
                                                 CHAPTER 7. THE IF STRUCTURE
                                                 CHAPTER 7. THE IF STRUCTURE
                                                 CHAPTER 7. THE IF STRUCTURE
                                                 ___________________________
 
           There are four macros that are used to build IF structures: these
           are  IF,  ELSEIF, ELSE and ENDIF.  Of these, conditions to govern
                IF,  ELSEIF, ELSE     ENDIF.
                IF,  ELSEIF, ELSE     ENDIF.
                IF,  ELSEIF, ELSE     ENDIF.
           statements are coded on the IF and ELSEIF  macros.  Like  the  IF
           services in many higher-level languages, there are Boolean opera-
           tors  available  (AND, OR, NOT) for building complex expressions:
           however, the conditional statements themselves  are  coded  using
           the actual assembler compare instructions. For example,
 
              IF    (CLC,TAG1(8),NE,6(R2)),THEN
                      :
                -- success code --
                      :
              ELSE
                      :
                -- fail code --
                      :
              ENDIF
 
           will generate:
 
             +            CLC  TAG1(8),6(R2)       generated by IF
             +            BE   failtag             generated by IF
                                   :
                          -- success code --
                                   :
             +            B    endiftag            generated by ELSE
             +failtag     DS   0H                  generated by ELSE
                                   :
                          -- fail code --
                                   :
             +endiftag    DS   0H                  generated by ENDIF
 
           Similarly,
 
              IF    ((CH,R1,EQ,A),OR,(CH,R1,EQ,B)),THEN
                    :
                -- success code --
                    :
              ENDIF
 
           will generate:
 
 
 
 
                                           Chapter 7. The IF Structure    33
 
 
             +              CH   R1,A              first comparison
             +              BE   successtag        branch if test succeeds
             +              CH   R1,B              second comparison
             +              BNE  failtag           branch if test fails
             +successtag    DS   0H                generated by IF
                                     :
                            -- success code --
                                     :
             +failtag       DS   0H                generated by ENDIF
             +endiftag      DS   0H                generated by ENDIF
 
           In  these  examples,  one thing that you may have noticed is that
           the macro expansions will generate tags and branches to  them  as
           may  be  appropriate.  Although  these  tags are used only by the
           macros at assembly time, it is very handy to have them  available
           under TSO TEST.
 
           The  IF  and ELSEIF macros allow you to specify "conditions" in a
           number of ways, which are fully described in "Chapter  2.  Condi-
           tional  Statements" on page 4.  Simply stated, the "condition" of
           the IF statement provides the instruction that will be  used  for
           the  actual comparison and the appropriate condition for the sub-
           sequent branch.  For example, the statement
 
              IF   (CLC,A(6),NE,3(R1)),THEN
 
           will generate the instructions
 
             +            CLC  A(6),3(R1)
             +            BE   failtag
 
           Conditions may be combined on the IF statement using Boolean  ex-
           pressions NOT, AND and OR.  Also, if a condition code is known to
           exist when an IF is executed, only the desired conditional opera-
           tor needs to be coded. For example,
 
              TRT   TEXT,TABLE
              IF    Z,THEN
               MVC   MESSAGE(15),=CL15'TEXT NOT FOUND'
               PUT   SYSPRINT,MESSAGE
              ELSE
                 :
                 :
              ENDIF
 
           In  this example, the TRT instruction will set a "zero" condition
           code if the translate-and-test operation fails.   The  subsequent
           IF  statement  is used to generate a conditional branch without a
           compare instruction.  This form of the IF statement is useful for
           non-comparison instructions that set a condition  code,  such  as
           arithmetic and logical instructions. The user should avoid mixing
           this  form of condition with conditions that generate compare in-
           structions, though, because the order in which  the  instructions
 
           34    Structured Macros Users's Guide
 
 
           are  generated  may cause the condition code to be changed prema-
           turely.
 
           The  ELSEIF  macro  is similar to an ELSE macro followed by an IF
           macro, except the IF nesting level is not changed.   This  allows
           the  user  to test for one condition out of a list of conditions.
           For example:
 
              IF      (CLC,FUNC,EQ,=C'READ'),THEN
                 :
                 :
              ELSEIF  (CLC,FUNC,EQ,=C'WRITE'),THEN
                 :
                 :
              ELSEIF  (CLC,FUNC,EQ,=C'CLOSE'),THEN
                 :
                 :
              ENDIF
 
           This is similar to the CASE structure, except that the CASE macro
           is mainly used to select one out of a sequence of numerically or-
           dered items.  For more information on the CASE macro, See  "Chap-
           ter 9. CASEs and CASE Blocks" on page 33.
 
 
 
 
 
 
 
 
 
 
 
                                           Chapter 7. The IF Structure    35
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           36    Structured Macros Users's Guide
 
 
                                                            CHAPTER 8. LOOPS
                                                            CHAPTER 8. LOOPS
                                                            CHAPTER 8. LOOPS
                                                            CHAPTER 8. LOOPS
                                                            ________________
 
           Variations  of  the LOOP and ENDLOOP macros may be used to create
                               ____     _______
           the most commonly used loop structures. The types of loop  avail-
           able  are:   WHILE loops, where completion tests are performed at
                        _____
           the top of the loop; UNTIL loops, where  completion  checking  is
                                _____
           done  at  the  bottom of the loop; BCT and BXLE loops, where com-
                                              ___     ____
           pletion tests are performed at the end of the  loop;  BXH  loops,
                                                                 ___
           where completion checks are made at the top of the loop; and end-
                                                                        ____
           less  loops,  where completion checks are made within the loop by
           ____
           the programmer's code.
 
           The WHILE and UNTIL loops provide the Assembly language  program-
           mer with the standard loop structures available in any high-level
           language  and the ability to control the loops with any condition
           that is legal in an IF statement.   See "Chapter  2.  Conditional
           Statements"  on  page  4 for a complete description of the condi-
           tions that can be specified with the Structured Macros.  The BCT,
           BXH, and BXLE loop provide support for  the  standard  System/370
           looping statements, while preserving the structured nature of the
           code.
 
           As in the other structures, the LEAVE macro may be used to exit a
           loop if desired. In the case of an endless loop, a LEAVE macro is
           usually the only way to exit the loop.
 
 
                     LOOP      WHILE,condition     |   LOOP      BXH,r1,r2
                          :                        |            :
                     ENDLOOP   WHILE               |   ENDLOOP   BXH
 
                     LOOP      UNTIL               |   LOOP      BXLE
                          :                        |            :
                     ENDLOOP   UNTIL,condition     |   ENDLOOP   BXLE,r1,r2
 
                     LOOP      UNTIL               |   LOOP      BCT
                          :                        |            :
                     ENDLOOP   UNTIL,LEAVE         |   ENDLOOP   BCT,reg
 
             Figure 4.  Types of LOOP macros
 
 
 
 
 
 
                                                      Chapter 8. Loops    37
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           38    Structured Macros Users's Guide
 
 
                                            CHAPTER 9. CASES AND CASE BLOCKS
                                            CHAPTER 9. CASES AND CASE BLOCKS
                                            CHAPTER 9. CASES AND CASE BLOCKS
                                            CHAPTER 9. CASES AND CASE BLOCKS
                                            ________________________________
 
           The  CASE  structure  may be used in place of the "jump-table" or
           "go-to-depending-on" structure and serves the  same  function  as
           the  Pascal  CASE structure.   The macros used to create the CASE
           structure are CASEBLK, CASE and ENDCASE.  The CASEBLK macro opens
           a case block and generates code that selects  a  handler  routine
           based  on  the contents of a register.  The ENDCASE macro denotes
           the end of a CASE block, and will be branched to at  the  end  of
           each  individual  CASE.   CASE macros within the CASE block frame
           code that will handle an individual case, or occurrence.
 
           A common example of the use of a CASE block might appear after  a
           call  to  some  routine  which  may  return one of several return
           codes, each of which must be handled differently, as in  Figure 5
           on page 33.
 
 
             IF  (TREG,R15,NZ),THEN
               CASEBLK REG=R15,MULT=4
 
                 CASE 4
                 -- code handles return code 4
 
                 CASE 12,16
                 -- code handles return codes 12 and 16
 
                 CASE OTHER
                 -- code handles other return codes
 
               ENDCASE
 
             ENDIF
 
             Figure 5.  The CASE Block
 
 
           Please note that since the CASE and CASEBLK macros generate a se-
           ries  of  branches  that are selected by the value in the CASEBLK
           register, it should be used to select one value from  a  list  of
           numerically  ordered  choices.   For comparing character data, or
           selecting from widely separated values, the IF - ELSEIF structure
           should be used.   For more information on  ELSEIF,  see  its  de-
           scription in "Chapter 7. The IF Structure" on page 29.
 
 
 
 
                                      Chapter 9. CASEs and CASE Blocks    39
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           40    Structured Macros Users's Guide
 
 
         |                  CHAPTER 10. PARAMETER LISTS AND STANDARD LINKAGE
                            CHAPTER 10. PARAMETER LISTS AND STANDARD LINKAGE
                            CHAPTER 10. PARAMETER LISTS AND STANDARD LINKAGE
                            CHAPTER 10. PARAMETER LISTS AND STANDARD LINKAGE
                            ________________________________________________
 
         | The Structured Macros provide excellent support for the main pro-
         | gram  being  called and for calling internal and external subrou-
         | tines using standard OS linkage conventions.   A  large  part  of
         | this  is handling standard OS parameter lists.  The standard form
         | for these parameter lists is a sequence of  fullwords,  each  the
         | address  of  a  particular data item.  If a data item is missing,
         | the address pointing to it is filled in with a fullword of zeros.
         | Upon entry to the routine, register 1 should point to  the  first
         | fullword in the parameter list.
 
         | The  handling  of parameter lists consists of two pieces.  First,
         | there must be some way to reference input parameter lists.  These
                                               input parameter lists
                                               input parameter lists
                                               input parameter lists
         | lists are processed by a program or  subroutine  block  and  were
         | created by the invoking program.  Secondly, support is needed for
         | generated  parameter  lists.   These are parameter lists that are
           generated  parameter  lists
           generated  parameter  lists
           generated  parameter  lists
         | created by a program or subroutine block and are then  passed  to
         | an  external  routine or another subroutine.  These functions are
         | intertwined, since a program that calls  an  internal  subroutine
         | may  create a generated parameter list that becomes the input pa-
         | rameter list of the subroutine being called.
 
         | REFERENCING INPUT PARAMETER LISTS
           REFERENCING INPUT PARAMETER LISTS
           REFERENCING INPUT PARAMETER LISTS
           REFERENCING INPUT PARAMETER LISTS
           _________________________________
 
         | The input parameter list for a program  is  referred  to  by  the
         | Structured  Macros  as  the Program Parameter List (or PPL).  The
                                       Program Parameter List
                                       Program Parameter List
                                       Program Parameter List
         | corresponding structure for subroutines is the Subroutine Parame-
                                                          Subroutine Parame-
                                                          Subroutine Parame-
                                                          Subroutine Parame-
         | ter List (or SPL).   The Structured Macros provide  a  number  of
           ter List
           ter List
           ter List
         | options  to control the handling of input parameter lists.  These
         | options are specified as sub-options of the PARMS option.
 
         | The VL|NOVL parameter option identifies the input parameter  list
         | as being either variable or fixed length.
 
         | The  COPY parameter option instructs the macros to copy the input
         | parameter list into the current work area (PWA for  programs  and
         | SWA  for subroutines).  In this case, the PPL (or SPL for subrou-
         | tines) is not the original input parameter list, but  a  copy  of
         | the  original  made  in working storage.   This has several uses.
         | First, it prevents the program from modifying the original param-
         | eter list.  Modifying an input parameter list is not  allowed  by
         | the  standard  linkage  rules.   Second, by copying the parameter
         | list, it is addressed with the work area base register and a sep-
         | arate parameter list register is not required.
 
         | Lastly, the COPY option makes it easier to determine which param-
         | eters were specified on a variable length parameter  list.    The
         | work  area  storage  is  always  large enough to hold the maximum
 
                                                      Standard Linkage    41
 
 
         | length parameter list and is filled with zeros before  the  input
         | parameter  list  is  copied there.   Because of this, the program
         | only needs to test any parameter address for zero to  see  if  it
         | was  specified  in  the original parameter list.  The COPY option
         | requires that the PWA  option  has  been  specified  for  program
         | blocks  and  that the SWA option has been specified on subroutine
         | blocks.
 
         | The COPYERROR parameter option is required if the COPY option  is
         | used  with VL input parameter lists and is used to name the error
         | exit that will be invoked if the  input  parameter  list  is  too
         | large  to  fit  in  the space reserved for it in working storage.
         | This will happen if the parameter list is larger than expected or
         | if it is not a VL parameter list, making it  impossible  for  the
         | Structured  Macros  to  determine the last parameter.   Any error
         | exit in the program can be specified including the unnamed  error
         | exit  and an exit code may be passed to the error exit identifing
         | the type of error to a multi-purpose exit.
 
         | The COUNT parameter option specifies the location of  a  fullword
         | into which the Structured Macros will place the number of parame-
         | ters  in  a  VL input parameter list.  This can be used to verify
         | that the program was called with the correct  number  of  parame-
         | ters.
 
         | The  USING  parameter  option  specifies  a register that will be
         | loaded with the starting address of  the  input  parameter  list.
         | This will either be the original input parameter list, or an area
         | within  the current work area (if COPY was also specified).  Once
         | the register is loaded, a USING is done to provide addressibility
         | on the parameter list.
 
         | The PREFIX option instructs the macros to use a unique  parameter
         | list ID when generating the tag names within the PPL or SPL.  For
         | more  information  about  how  this is used, see "Chapter 11. Lo-
         | cation and Scope of Data Structures" on page 43.
 
         | In order to make use of these options, a description of the input
         | parameter list must be provided.  There are two  mutually  exclu-
         | sive keywords on the BLOCK macro provided for this purpose.
 
         | If  a  mapping macro is already available for the input parameter
         | list, the PARMMAP keyword can be used to specify the  Dsect  name
         | and  length.    This provides a name for a USING on the parameter
         | list, and defines the size of the area that must be reserved  for
         | a COPY.
 
         | If  a  mapping  macro  is not available, the PARMS keyword can be
         | used to specify a list of tags that will be used to map  the  pa-
         | rameter  list.    These tag names will either be used to generate
         | the parameter list Dsect, or will be  mapped  to  the  work  area
         | storage if COPY is being used.
 
 
           42    Structured Macros Users's Guide
 
 
         | Note: Whether  a  parameter list is mapped by a supplied Dsect or
           Note:
           Note:
           Note:
         | tags generated by the PARMS keyword, these tags will not refer to
         | the parameters themselves, but rather to the addresses of the pa-
         | rameters.  This is not a deficiency in the Structured Macros;  it
         | is simply the way that standard OS parameters work.
 
           GENERATING PARAMETER LISTS
           GENERATING PARAMETER LISTS
           GENERATING PARAMETER LISTS
           GENERATING PARAMETER LISTS
           __________________________
 
           Most  external  subroutines (and some internal ones) will require
           some sort of parameter list to pass data between the calling pro-
           gram and the subroutine.
 
           The Structured Macros provide  excellent  support  for  building,
           maintaining,  and  passing  parameter lists.   The PLIST macro is
           used to create or modify a parameter list.  It also loads  regis-
           ter  one  with  the address of the completed list.  The following
           example illustrates some of the capabilities of the PLIST macro.
 
         |    PLIST  (DATA1,,*DATA3,*),PL=(PARMSTOR,4)
 
           This example will build a parameter list of four items at the lo-
         | cation pointed to by PARMSTOR.  First is a simple data item  that
         | will have its address loaded into the parameter list.  The second
         | item  in  the  list  is missing, so its address will be filled in
         | with a full word of zeros.  The third item in the  list  will  be
         | filled  in  with  the  contents  of DATA3 instead of a pointer to
         | DATA3.  This form of indirect addressing is used when the  refer-
         | enced  storage  contains  a pointer to the actual parameter.  The
           asterisk in the fourth position tells the  PLIST  macro  to  skip
           over  that  position  in  the  list and leave the value there un-
           changed.  This is useful if you are modifying  a  parameter  list
           that  was  created  earlier,  and you only want to update certain
           fields.  The fields that are not to be changed can be marked with
           asterisks.  Once the parameter list has been  built,  PLIST  will
           load register one with the address of PARMSTOR.
 
           The  PLIST  macro  allows  the use of constants as well as labels
           when defining parameter lists.  Observe the following example:
 
              PLIST (0,,'HELLO?',=X'FF')
 
           which is equivalent to:
 
              PLIST (=F'0',,=C'HELLO?',=X'FF')
 
           Both examples generate literal constants, and then  fill  in  the
           parameter  list with the addresses of these constants.  Any deci-
           mal self-defining constant will be treated as a full word literal
           and any character string in quotes will be treated as a character
           literal.  Note that any other type of literal (such as hex or bi-
           nary) has to be coded as a literal.  Since decimal and  character
 
                                                      Standard Linkage    43
 
 
           constants  can  be coded as constants instead of as literals, the
           PLIST macro makes generating parameter lists even more painless.
 
           Please  note  in  the  examples above the distinction between the
           first and second parameter in each list.  The first parameter  is
           a decimal constant of zero.  The macros will generate a full word
           of zero and fill in the first position in the parameter list with
           the  address  of  it.    The  second parameter is missing, so the
           macros will put a full word of zeros into the parameter list  it-
           self.  This is an important distinction to remember.
 
           There are two main types of parameter lists: variable length (VL)
           and fixed length (NOVL).  In variable length parameter lists, the
           last  address  in the list has its high bit set to one to mark it
           as the end of the list.  Since the length of fixed length parame-
           ter lists is known in advance,  the  end  does  not  need  to  be
           marked.  The VL or NOVL option on the program block macro is used
         | to  set  up  the default for all parameter lists generated by the
         | program or any of its internal subroutines.   Note that  this  is
         | distinct from the VL parameter option (specified by the PARMS op-
         | tion).    The  VL  parameter option describes the input parameter
         | list.  You can specify a VL (or NOVL) keyword on the PLIST  macro
           to  override  this  default.   Note that all of the super options
           specify VL so that you will get variable length  parameter  lists
           by default.  If the PLIST macro is generating a VL parameter list
           (either  because  of the VL option on the program block or the VL
           keyword on the PLIST macro), the last address  in  the  parameter
           list  will have its high bit set to one.  This occurs even if the
           last parameter has been marked with an asterisk.
 
         | You have many choices as to where the parameter list itself  gets
         | built.   As you have already seen, you can use the PL= keyword to
         | specify a tag and a number of parameters for the parameter  list.
         | This  number  should  represent the size of the storage available
         | for the parameter list.   The number  is  necessary  because  the
         | PLIST macro verifies that there is enough room to hold the param-
         | eter  list.   This prevents PLIST from running over the parameter
         | list storage into other data fields.   If the  tag  has  a  self-
         | defining length attribute, the number field can be omitted.  How-
         | ever,  because  of  the way the assembler interprets lengths, you
         | need to be careful.  To illustrate this:
 
         |   PARMS1  DS  3F
         |   PARMS2  DS  XL(3*4)
 
         | Both of the definitions above reserve enough space for a  parame-
         | ter list at least three items long.  However, the assembler views
         | the  first  tag as having a length of 4 since it is just a series
         | of fullwords.  Therefore, PLIST will assume that this storage lo-
         | cation can hold a parameter list of only one item.    The  second
         | example actually has a length of 12, which is what PLIST will re-
         | quire if you try to build a parameter list of three items here.
 
 
           44    Structured Macros Users's Guide
 
 
           AUTOMATIC PARAMETER LISTS
           AUTOMATIC PARAMETER LISTS
           AUTOMATIC PARAMETER LISTS
           AUTOMATIC PARAMETER LISTS
           _________________________
 
         | If  your  program has a PWA, you can have storage for your gener-
         | ated parameter lists automatically allocated within the PWA.  Any
           parameter lists that do not include a PL= keyword in their  defi-
           nitions  will  be  placed in a special parameter list area in the
           PWA.   This area is only big enough to contain the single largest
           parameter list in the program and is reused when a new  parameter
           list is needed.  For this reason, it is most useful for parameter
           lists  that  are  created, immediately used, and can then be dis-
           carded.
 
           A separate parameter list area is also created for  any  internal
           subroutines  that  generate  parameter lists themselves.  This is
           because a subroutine that generates a  parameter  list  may  have
           been  called  with  one  and that one must remain even though the
         | subroutine is generating new ones.  The subroutine parameter list
         | area is created within the SWA for the subroutine.
 
           If your program does not have a PWA, you can achieve the same ef-
           fect with the PL= keyword on the block macro.   This  keyword  is
           identical  to  the  PL=  keyword on the PLIST, CALLSUB, and CALLX
           macros and defines a default parameter list area for any  parame-
           ter  lists within that enclosing block.  This keyword can be used
           on any type block to create a unique parameter list area for each
           program section.
 
           PERMANENT PARAMETER LISTS
           PERMANENT PARAMETER LISTS
           PERMANENT PARAMETER LISTS
           PERMANENT PARAMETER LISTS
           _________________________
 
           There are still cases where you would want to code PL= for a  pa-
           rameter list.  If your program requires that a subroutine will be
           called  many  times with the same parameter list it would help to
           be able to create it just once, then refer to it as often as nec-
           essary.  Also, it may be desirable to create a parameter list and
           then modify it conditionally before its use.  In either of  these
           cases,  you can use PLIST with the PL= keyword to create the list
           in its own unique location.  This prevents the  list  from  being
           overwritten  by  the  next  parameter  list.   These lists may be
           viewed as permanent since they remain until specifically  written
           over,  while  the automatic parameter lists only remain until the
           storage is needed for the next list.
 
           If a permanent parameter list is needed, you  can  code  a  PLIST
           macro  with  the PL= keyword and define storage for the parameter
           list, most likely in the PWA or SWA.  However, this requires more
           upkeep than the other types of parameter lists.   You  must  make
           sure that enough storage has been reserved to contain all the pa-
           rameters  in  the list and if the number of parameters is changed
           later, the storage definition must be changed.
 
                                                      Standard Linkage    45
 
 
           It would be nice if there was a way to get the Structured  Macros
           to  generate  the  DS commands for you.  That way, if the size of
           the parameter list changed, the storage area  would  change  with
           it.   This would give the advantages of the temporary lists while
           still  allowing  you  to  keep the list around and refer to it by
           name for subroutine calls or modifications to the list.  There is
           such a mechanism in the macros.  It is done with the DS=  keyword
           on  the  PLIST macro.  With the DS= keyword, you can instruct the
           macros to set aside storage for a particular  parameter  list  in
           the  PWA  or in an SWA (of course you can only specify SWA if the
           parameter list is being built in a subroutine that has one.)  For
           example:
 
              PLIST  (DATA1,DATA2,DATA3),PL=PARM1,DS=PWA
              PLIST  (DATA4,DATA5),PL=(PARM2,3),DS=SWA
 
           When the DS= keyword is used, the PLIST macro counts the  parame-
           ters in the list and sets aside just enough storage for them with
           a  label  supplied  by  the PL= keyword.   You can also force the
           macro to allocate a specific amount of space by including a  num-
           ber  in the PL= keyword.  After a parameter list is created using
           the DS= keyword, it can be referred to with just a PL=tag.    One
           caution  on  using this keyword:   Since the PLIST macro actually
           defines the parameter list storage within a partial PWA, the  DS=
           keyword  should  appear  on  the first reference to the parameter
           list that the assembler sees and no others.  All other references
           to the parameter list should just use PL= to specify the tag  for
           that list.
 
         | CALLING SUBROUTINES
           CALLING SUBROUTINES
           CALLING SUBROUTINES
           CALLING SUBROUTINES
           ___________________
 
         | Two macros are provided for calling subroutines.  CALLSUB is used
         | to  call  an  internal subroutine that is included as part of the
         | assembly of the main program.   CALLX is used  to  call  external
         | routines  that have been linked with the main program or that are
         | dynamically loaded.  These external routines may  be  other  pro-
         | grams, or they may be IBM or vendor supplied service routines.
 
         | The  CALLSUB  macro generates a BAL instruction (or BAS if the XA
         | option is being used) to jump to a subroutine  that  the  program
         | has direct addressability to.  The return address will be in reg-
         | ister  14.    Otherwise,  all  registers have the same value upon
         | entry to the subroutine  that  they  had  in  the  main  program.
         | CALLSUB  also  provides the necessary linkage for Dynamic Storage
         | Management if DYN is being used, and  for  subroutines  that  use
         | LOADBASE.   In either of these cases, the contents of register 15
         | are also destroyed by the CALLSUB macro.
 
         | The CALLX macro is for external subroutines and generates a  BALR
         | instruction  (or BASR) with the return address in register 14 and
         | the subroutine address in register 15.  This is the standard for-
 
           46    Structured Macros Users's Guide
 
 
         | mat for external subroutines.  Registers 14 and 15 are  the  only
         | ones destroyed by the CALLX macro.  All others will have the same
         | value in the subroutine that they had in the calling program.
 
         | CALLX  also  differs  from CALLSUB in the way that the subroutine
         | address is specified.  Since CALLSUB is used for internal subrou-
         | tines, the name of the subroutine is  specified  on  the  CALLSUB
         | macro.    To  call  an external subroutine with CALLX, you should
         | specify the address in a register, or give the  CALLX  macro  the
         | address  of  a  location  that contains a pointer to the external
         | routine.
 
           PARAMETER LISTS ON CALLSUB AND CALLX
           PARAMETER LISTS ON CALLSUB AND CALLX
           PARAMETER LISTS ON CALLSUB AND CALLX
           PARAMETER LISTS ON CALLSUB AND CALLX
           ____________________________________
 
           If you are going to build a parameter list and  then  immediately
           issue  a  CALLSUB or CALLX macro, you can combine these functions
           in a single macro.  The CALLSUB and CALLX macros can generate pa-
           rameter lists just as PLIST does, so you can  have  these  macros
           build your parameter list for you.  For example:
 
         |    CALLSUB  SUBONE,(DATA1,*DATA2,100),PL=(PARMS1,3),NOVL
         |    CALLX    (R15),(DATA3,'ERROR')
 
           This  method  of calling subroutines is very simple.  However, it
           should be noted that the parameter list will be  recreated  every
           time the subroutine is called.  If you are going to make repeated
           calls  to  a subroutine with the same parameter list, it would be
           better to create the parameter list once and simply load the  ad-
           dress  of  it  before the subroutine call.  This can be done like
           this:
 
              CALLX   (R15),PL=PARMSTOR
 
           RECOMMENDATIONS
           RECOMMENDATIONS
           RECOMMENDATIONS
           RECOMMENDATIONS
           _______________
 
           To help you better understand the types of  parameter  lists  and
           calls,  here  are some general conventions to remember when using
           the Structured Macros for parameter lists.  These rules  are  not
           enforced  by the macros, but are good programming practice.  When
           reading these rules, remember the distinction  between  permanent
           lists  that  use  the PL= keyword to point to a specific location
           and automatic lists that are defined in  default  parameter  list
           storage.
 
         |     If the PARMS keyword was used to describe the input parameter
         |     list,  you  will  generally want a parameter option of either
         |     COPY or USING, but not both.
 
                                                      Standard Linkage    47
 
 
         |     Since it frees a register that otherwise would be used to map
         |     the parameter list, COPY will probably be the most common op-
         |     tion.
 
         |     If the PARMMAP keyword was used to describe the input parame-
         |     ter list, you will generally want the USING parameter option.
         |     The COPY option may be specified if you want the functions it
         |     provides.
 
               When  using CALLSUB and CALLX, the PL= keyword is only really
               necessary when referring to a permanent  list  created  by  a
               previous PLIST macro.
 
               The  PLIST  macro  is  only needed for creating and modifying
               permanent parameter lists or when the call must be done with-
               out CALLSUB or CALLX (With LINK for example).
 
               Permanent parameter lists should only be created with PLIST.
 
               The * notation for modifying parameters should only  be  used
               in permanent parameter lists.
 
         |     Temporary parameter lists should only be created with CALLSUB
         |     or  CALLX  (Except  when forced to use PLIST because the call
         |     cannot be made with CALLSUB or CALLX).
 
         | EXAMPLE SOURCE
           EXAMPLE SOURCE
           EXAMPLE SOURCE
           EXAMPLE SOURCE
           ______________
 
         | Here is an example to show you some of the various ways in  which
         | parameter lists can be used:
 
 
 
 
 
 
 
 
           48    Structured Macros Users's Guide
 
 
         |    BLOCK   TYPE=PROGRAM,NAME=PROG1,OPTIONS=(*PWA)
         |   *  Call external routine and pass a parameter list
         |     LOAD   EP=PROG2
         |     CALLX  (R0),(MYDATA,'OPEN',),NOVL
         |    ENDBLK  BLOCK=PROG1
 
         |   *  And under a separate assembly, you have
         |    BLOCK   TYPE=PROGRAM,NAME=PROG2,PARMS=(DATA,FUNCTION,OPT)
         |                  OPTIONS=(*PWA,(PARMS,COPY,NOVL))
         |   *  Copy actual parameter data to working storage
         |     L      R1,DATA               Get address of 1st parameter
         |     MVC    DATA1,0(R1)           Save data away
         |   *  Create a permanent list for later use.  Note that FUNCTION conta
         |   *  the address of the parameter we want to pass.
         |     PLIST  (DATA1,*FUNCTION,53),PL=PARM1,DS=PWA
         |   *  Call subroutine using temporary list
         |     CALLSUB SUBONE,(DATA3,,'INIT')
         |   *  Modify permanent list
         |     PLIST  (*,DATA5,*),PL=PARM1
         |   *  Call subroutine using previous list
         |     CALLX  =V(EXTRSUB),PL=PARM1
         |    ENDBLK  BLOCK=PROG2
 
         |    BLOCK   TYPE=SUBROUTINE,NAME=SUBONE,PARMMAP=(SUBPARM,SUBPARML),
         |                  OPTIONS=(*SWA,(PARMS,(USING,R9),VL))
         |   *  Call subroutine using temporary list
         |   *  This list will be created in SWA
         |     CALLX  (R15),(155,'NAME',=X'FF')
         |   *  Create a permanent list within SWA
         |     PLIST  (DATA4,DATA5),PL=SWAPARM,DS=SWA
         |    ENDBLK  BLOCK=SUBONE
         |            SUBPARM DSECT=YES            Generate Dsect for input parm
         |   SUBPARML EQU   *-SUBPARM
 
 
 
 
 
 
 
 
                                                      Standard Linkage    49
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           50    Structured Macros Users's Guide
 
 
         |                 CHAPTER 11. LOCATION AND SCOPE OF DATA STRUCTURES
                           CHAPTER 11. LOCATION AND SCOPE OF DATA STRUCTURES
                           CHAPTER 11. LOCATION AND SCOPE OF DATA STRUCTURES
                           CHAPTER 11. LOCATION AND SCOPE OF DATA STRUCTURES
                           _________________________________________________
 
         | Since  the Structured Macros handle all of the implementation de-
         | tails of PWAs, PSDs, SWAs, etc., a programmer should not have  to
         | reference any of these data areas directly.  However, on the rare
         | occasions that it is necessary, symbols are defined by the Struc-
         | tured Macros that contain unique tags located at the beginning of
         | these structures.  These symbols are listed below:
 
         |      &PWA - Program Work Area           &SWA - Subroutine Work Area
         |      &PSD - Program Static Data         &SSD - Subroutine Static Data
         |      &PPL - Program Parameter List      &SPL - Subroutine Parameter L
 
         | In  order  to  have  these symbols available to your program, you
         | need to include an assembler COPY statement at the  beginning  of
         | your program for the member SMSYMS.  This is necessary because of
         | the  Assembler  H requirement that all global symbols be declared
         | in open code and not from within macros.
 
         | These symbols can be used by any programs that needs to calculate
         | offsets within any of these structures.   However, these  symbols
         | have a much better use when used within subroutines.
 
         | LOCAL SCOPE WITHIN SUBROUTINES
           LOCAL SCOPE WITHIN SUBROUTINES
           LOCAL SCOPE WITHIN SUBROUTINES
           LOCAL SCOPE WITHIN SUBROUTINES
           ______________________________
 
         | One  of the nicer concepts of high-level languages is local scope
         | within subroutines.   This isolates the working  storage  of  the
         | subroutine  from  the main program, and helps to prevent the sub-
         | routine from affecting the program's storage in  unforseen  ways.
         | To some extent, Subroutine Work Area accomplish this goal for as-
         | sembler  programs.    By giving each subroutine its own work area
         | instead having to share work areas within  the  PWA,  the  chance
         | that two subroutines will overlay each other's storage is greatly
         | reduced.
 
         | Another  very nice feature of local scope becomes evident when it
         | comes time to think up names for variables and work areas.  In  a
         | language with local scoping, you can name variables within a sub-
         | routine  without  any regard for what the variables in other sub-
         | routines have been named.  This also makes it easier  to  copy  a
         | subroutine  from  one  program  to another, since the new program
         | does not have to be checked for variable name conflicts.
 
         | Unfortunately, 370 assembler requires that every  tag  be  unique
         | and does not allow for local scoping of names.  However, the sub-
         | routine  data  area symbols described above can be used to accom-
         | plish the same effect.  They contain the name of  a  tag  at  the
         | beginning  of  a  data area, but this can also be thought of as a
         | unique id that can be prefixed to tag names to  distinguish  them
 
                     Chapter 11. Location and Scope of Data Structures    51
 
 
         | from  identically named tags in other subroutines.  To facilitate
         | this use of the symbols, abbreviated versions of them  were  cre-
         | ated.  The short versions are:
 
         |      &SWA = &W
         |      &SSD = &S
         |      &SPL = &P
 
         | With  these tags, a subroutine like the following can be written.
         | Note the use of the PREFIX parameter option to force the  use  of
         | the &P. symbol in the SPL.
 
         |          .
         |     COPY    SMSYMS
         |          .
         |          .
         |          .
         |    EDITDATA    TITLE 'SUBROUTINE TO EDIT PASSED FULLWORD'
         |    *-----------------------------------------------------------------
         |    *  SUBROUTINE  EDITDATA
         |    *
         |    *  ABSTRACT    THIS SUBROUTINE WILL TAKE THE FULLWORD PASSED IN TH
         |    *              FIRST PARAMETER PASSED TO IT, EDIT IT INTO A WORK A
         |    *              AND COPY THE RESULTS INTO THE AREA POINTED TO BY TH
         |    *              SECOND PARAMETER.
         |    *-----------------------------------------------------------------
         |             SPACE 3
         |     BLOCK   NAME=EDITDATA,TYPE=SUBROUTINE,
         |                   OPTIONS=(*SWA,(PARMS,(USING,R9),PREFIX)),
         |                   PARMS=(DATAPTR,RESULT)
         |      L      R1,&P.DATAPTR                | GET ADDR OF FULL WORD.
         |      L      R2,0(,R1)                    | LOAD FULL WORD TO CONVERT.
         |      CVD    R2,&W.DOUBL                  | CONVERT TO DECIMAL.
         |      MVC    &W.MASK,&S.MASK              | COPY EDIT MASK TO WORK ARE
         |      EDIT   &W.MASK,&W.DOUBL             | EDIT DECIMAL NUMBER TO EBC
         |      L      R1,&P.RESULT                 | GET PTR TO RESULT STORAGE.
         |      MVC    0(11,R1),&W.MASK             | COPY RESULT.
         |     ENDBLK  BLOCK=EDITDATA
         |             SSD
         |    &S.MASK  DC    CL'4020202020202020202120'
         |             ENDSSD
         |             SWA
         |    &W.MASK  DC    CL'4020202020202020202120'
         |    &W.DOUBL DS    D
         |             ENDSWA
 
         | Although  this  may  seem strange at first, most programmers will
         | find that the advantages outweigh any inconveniences.
 
 
 
           52    Structured Macros Users's Guide
 
 
                                            CHAPTER 12. MISCELLANEOUS MACROS
                                            CHAPTER 12. MISCELLANEOUS MACROS
                                            CHAPTER 12. MISCELLANEOUS MACROS
                                            CHAPTER 12. MISCELLANEOUS MACROS
                                            ________________________________
 
           There  are  several  macros  packaged  with the Structured Macros
           that, while they are not true structured programming  aids,  per-
           form commonly used functions and relieve some coding effort.
 
           BIT MANIPULATION
           BIT MANIPULATION
           BIT MANIPULATION
           BIT MANIPULATION
           ________________
 
           There  are  macros  provided that perform the 4 most common func-
           tions performed on a bit:  setting (OI), resetting (NI),  invert-
                                      ______________________________________
           ing  (XI)  and testing (TM).  The macros that perform these tasks
           _________      _____________
           are called SBIT, RBIT, IBIT and TBIT, respectively.   Each  macro
                      ________________     _____
           uses the appropriate immediate instruction to operate on a single
           byte;  however,  multiple  bits  within  the  target  byte may be
           changed at once.  For example, the macro
 
              SBIT  FLAGBYTE,(BIT1,BIT2,BIT3)
 
           would generate:
 
             +            OI   FLAGBYTE,BIT1+BIT2+BIT3
 
           There is also a naming convention which is  optional  when  using
           these  macros. If the address of the target byte is not provided,
           the macros assume that the target byte's tag is the first 5 char-
           acters of the flag name. For example, the macro
 
              IBIT  PWAF1OK
 
           would assume the flag was named "PWAF1" and generate:
 
             +            XI   PWAF1,PWAF1OK
 
           The TBIT macro is valid as a "compare" instruction, allowing  the
           use  of  TBIT  in  conditional expressions on IF, LEAVE, LOOP and
           ERREXIT.
 
           TESTING A REGISTER
           TESTING A REGISTER
           TESTING A REGISTER
           TESTING A REGISTER
           __________________
 
           The TREG macro may be used in place  of  the  "LTR"  instruction.
           TREG  always issues a LTR that loads the target register from it-
           self, thus setting the condition code without modifying any  reg-
           isters.  TREG is valid in a conditional expressions.
 
 
                                      Chapter 12. Miscellaneous Macros    53
 
 
           INITIALIZING STORAGE
           INITIALIZING STORAGE
           INITIALIZING STORAGE
           INITIALIZING STORAGE
           ____________________
 
           The  FILL  macro  may  be  used to set areas of storage to a byte
           value, such as spaces or low-values.   There are three  types  of
           FILL  which may be done:  short, the default, for 1 to 256 bytes,
                                     ______
           medium, for up to 4095 bytes, and long, for up to  16  megabytes.
           _______                           _____
           Medium  FILL may use any length constant which the LA instruction
           can handle, while a long FILL must have its length in a register;
           otherwise, medium and long FILL are identical.  A short FILL will
           not destroy any registers, as it uses MVI and  MVC  to  propagate
           its  fill  character, but medium and long FILL both use MVCL, and
           will destroy the contents of R14, R15, R0 and R1.
 
           REGISTER LOADING
           REGISTER LOADING
           REGISTER LOADING
           REGISTER LOADING
           ________________
 
           Often  it  is necessary to load one, two, three, or four bytes of
           data into a register from storage.   The L8, L16,  L24,  and  L32
           macros  allow  this  to be easily accomplished.  For example, the
           instruction
 
              L16   R4,DATA1
 
           will load the low-order two bytes of register four with  the  two
           bytes  at  location  DATA1  and clear the high-order two bytes of
           register four.  These macros clear the  specified  register,  and
           issue an appropriate ICM to load the required data.
 
           Important  note:   Since all of these macros except L32 clear the
           Important  note:
           Important  note:
           Important  note:
           register before doing the ICM, they should never be used to  load
           a  register that is referred to in the address being loaded from.
           To illustrate this:
 
              L16   R2,10(R2)
 
           would generate the following code:
 
             +            SLR  R2,R2                    CLEAR REGISTER
             +            ICM  R2,B'0011',10(R2)        LOAD 16 BITS
 
           In this example, register two is cleared to zero, then is  loaded
           with  the  two bytes at the location pointed to by ten off of the
           contents of register two.  But since register two  has  been  ze-
           roed,  this loads from absolute location ten.  This type of prob-
                                  _____________________
           lem can be very difficult to debug because without looking at the
           macro expansion, it is difficult to understand  exactly  what  is
           going on.
 
 
           54    Structured Macros Users's Guide
 
 
           EXECUTING INSTRUCTIONS
           EXECUTING INSTRUCTIONS
           EXECUTING INSTRUCTIONS
           EXECUTING INSTRUCTIONS
           ______________________
 
           The EX instruction is a very powerful tool in System/370 assembly
           language.    There are many cases where it is the simplest method
           to operate on a variable amount of  data.    However,  there  are
           problems  with using the EX instruction.  Most of these stem from
           the placement of the instruction to be EXecuted.  The instruction
           can be placed inline, right next to the  EX  instruction  with  a
           branch  around  it.   This is convenient, but wasteful because it
           requires unnecessary branch instructions.  The instruction can be
           placed with the static  data,  but  this  causes  more  problems.
           First,  the  EX instruction is removed in the source from the in-
           struction being EXecuted, making  the  program  harder  to  read.
           Second,  the USING environment of the EXecuted instruction may be
           completely different from that of the EX instruction, making  the
           coding of meaningful labels difficult or impossible.
 
           Perhaps  the best solution is to use the LOCTR assembler instruc-
           tion.  This instruction establishes a new  location  counter  for
           whatever  data  follows.   Any data or instruction defined with a
           new location counter will be collected and placed at the  end  of
           the  load module.   This way, the EXecuted instruction can be de-
           fined inline with the current  USING  environment,  but  will  be
           placed at the end of the load module where no branch is needed to
           skip over it.
 
           However,  all  of  these  methods have one problem in common when
           used with the Structured Macros.  They all require  you  to  code
           tags  in  the  body of the program.   Since the Structured Macros
           eliminate the need for tags in the rest of the program, this  can
           upset  the  indentation  scheme and make the program look "messy"
           and difficult to read.
 
           A solution to all of these problems would be to provide  a  macro
           to generate the EX instruction and its object and to generate the
           tags  automatically.    This way, the source could still be coded
           without the use of any tags.  The EXI macro is included with  the
           Structured  Macros  to  provide this function.  It can accept any
           register for the EX instruction, and allows the user  to  specify
           any opcode and one to three operands.  For example:
 
              EXI   R3,(MVC,DEST(0),0(R10))
 
           This  will generate a MVC instruction with the operands specified
           and an EX instruction using register 3 and the MVC.
 
           If the LOCTR option was specified on the program block,  the  EXI
           macro  puts the EXecuted instruction in the PSD (or the SSD if it
           is within a subroutine).  If NOLOCTR was specified, EXI will gen-
           erate the instruction inline with a branch around it.
 
 
                                      Chapter 12. Miscellaneous Macros    55
 
 
           LOADING CONTROL BLOCK ADDRESSES
           LOADING CONTROL BLOCK ADDRESSES
           LOADING CONTROL BLOCK ADDRESSES
           LOADING CONTROL BLOCK ADDRESSES
           _______________________________
 
           There  are  certain  system  control blocks that programmers find
           themselves accessing often.  The LCBA macro is provided  to  give
           you  a  standard  way  of finding these control blocks.  The LCBA
           macro locates the address of  the  specified  control  block  and
           places  it in the specified register.  The mapping macros for any
           control blocks LCBA uses to find the desired  control  block  are
           not  required.  The LCBA macro can be used to load the address of
           the:
 
               current ACEE,
               current ASCB,
               current ASXB,
               CVT,
               current TCB,
               UJT (Clemson dependent),
               and UVT (Clemson dependent).
 
           For example:
 
              LCBA   R8,ACEE
              IF     (Z)
                 -- ACEE not found code --
              ENDIF
              USING  ACEE,R8
                 -- Now have ACEE --
 
         | CONTROLLING STRUCTURED MACRO OPERATION
           CONTROLLING STRUCTURED MACRO OPERATION
           CONTROLLING STRUCTURED MACRO OPERATION
           CONTROLLING STRUCTURED MACRO OPERATION
           ______________________________________
 
         | There are times when a decision must be made in the middle  of  a
         | program  that  needs  to  affect  the operation of the Structured
         | Macros at a later time.   To provide  for  this  capability,  the
         | SMCTRL  macro  was created to set flags that are checked by other
         | macros.
 
         | One example of this use is the reusable PWA  support.    You  use
         | SMCTRL to inform the macros that the PWA should be freed when the
         | current invocation of the program is terminated.
 
 
 
 
 
           56    Structured Macros Users's Guide
 
 
                                          CHAPTER 13. MISCELLANEOUS EXAMPLES
                                          CHAPTER 13. MISCELLANEOUS EXAMPLES
                                          CHAPTER 13. MISCELLANEOUS EXAMPLES
                                          CHAPTER 13. MISCELLANEOUS EXAMPLES
                                          __________________________________
 
           This  section  will provide some examples for pieces of code that
           programmers find themselves writing often.
 
           A SEARCH LOOP
           A SEARCH LOOP
           A SEARCH LOOP
           A SEARCH LOOP
           _____________
 
           While search routines can be as different as the data  structures
           they  are  accessing,  they  are usually similar in their general
           structure.  This is an example of  a  sequential  search  routine
           that looks through a RACF access list.
 
               BLOCK NAME=SEARCH
             *
             *   Set up list pointer and count for search.
             *
                LA   R2,ACL
                LH   R3,ACLCNT
             *
             *   Now loop through the access list (ACLCNT) times.
             *
                LOOP BCT
                 IF  (CLC,USERID(8),EQ,0(R2)),THEN
             *
             *   If compare succeeds, do success code and leave.
             *
                       :
                  -- success code --
                       :
                  LEAVE BLOCK=SEARCH
                 ENDIF
             *
             *  Point to next entry, try again.
             *
                 LA  R2,ACLLEN(,R2)
                ENDLOOP BCT,R3
             *
             *  Entire ACL searched without a hit, do fail code.
             *
                       :
                 -- fail code --
                       :
               ENDBLK BLOCK=SEARCH
                       :
 
 
 
                                    Chapter 13. Miscellaneous Examples    57
 
 
           SCANNING TEXT
           SCANNING TEXT
           SCANNING TEXT
           SCANNING TEXT
           _____________
 
           This routine (lifted from the nesting level pre-processor) uses a
           BXLE  and  a  BXH loop to scan a line of assembler source for its
           opcode.
 
             *
             *   Set up for BXLE loop:
             *     R1 points to start of source code line
             *     R14 contains increment for R1
             *     R15 contains A(end of line) as limit for R1
             *
               LA   R1,LINE                               R1 -> start of line
               LA   R14,1                                 Set increment to 1
               LA   R15,LINE+L'LINE                       R15 -> end of line
 
               LOOP  BXLE                                 Skip past any tags in
                LEAVE LOOP=*,(CLI,0(R1),EQ,X'40')
               ENDLOOP BXLE,R1,R14
 
             *
             *   Now use remaining value in R1 as start for BXH loop.
             *
               LOOP  BXH,R1,R14                           Now scan for opcode
 
                IF   (CLI,0(R1),NE,X'40')
 
                 IF  (CLC,0(6,R1),EQ,=C'BLOCK ')          If 'BLOCK'
                  IC R0,=C'B'                             Set type to 'B'
                  CALLSUB NEST                            Call NEST
 
                 ELSEIF (CLC,0(7,R1),EQ,=C'ENDBLK ')      Elseif 'ENDBLK'
                  IC R0,=C'B'                             Set type to 'B'
                  CALLSUB UNNEST                          Call UNNEST
 
                 ELSEIF                                    ( etc. )
                    :
                 ENDIF
 
             *
             *   If outer IF succeeded, line is processed, so leave.
             *
                 LEAVE  LOOP=*
                ENDIF
 
               ENDLOOP BXH                                End of search loop.
 
 
 
           58    Structured Macros Users's Guide
 
 
           A DCB EODAD EXIT
           A DCB EODAD EXIT
           A DCB EODAD EXIT
           A DCB EODAD EXIT
           ________________
 
           One  way to use a DCB EODAD exit (or SYNAD, EOV and other DCB ex-
           its) would be to "fake out" the macros by coding  a  tag  at  the
           place  your  end-of-file code started and specifying EODAD=tag in
           the  DCB.    This,  however,  becomes  dangerous   when   running
           mixed-AMODE  programs,  since  the EODAD routine would have to be
           the same AMODE as the routine where the GET was issued. To  avoid
           this,  one  can take advantage of the fact that R14 points to the
           instruction following the GET or READ macro whenever a  DCB  exit
           is called by using an implied CALLSUB, as follows:
 
               OPEN  DCB,INPUT
 
               LOOP  UNTIL                         Do 'endless' loop
 
             *
             *  PWAF1EOF gets set if end-of-file was found.
             *
                GET      DCB,RECORD
                LEAVE    LOOP=*,(TBIT,PWAF1EOF,ON)
                CALLSUB  EATREC
 
               ENDLOOP   UNTIL,LEAVE
 
               CLOSE DCB
                      :
                      :
               BLOCK NAME=EOF,TYPE=SUBROUTINE,OPTIONS=*NOSUBOPTS
                SBIT  PWAF1EOF
               ENDBLK BLOCK=EOF
                      :
                      :
             PWAF1        DC   X'00'
             PWAF1EOF     EQU  X'80'
               :
             DCB          DCB  EODAD=EOF,  ...
 
           If  this sample were bimodal, subroutine EOF would have to be the
           same AMODE as the code that issued the GET macro.
 
 
 
 
 
                                    Chapter 13. Miscellaneous Examples    59
 
 
           RETURNING R0 AND R1 WITH ENDBLK
           RETURNING R0 AND R1 WITH ENDBLK
           RETURNING R0 AND R1 WITH ENDBLK
           RETURNING R0 AND R1 WITH ENDBLK
           _______________________________
 
           There  are  many  programming situations where it is desirable to
           return values or pointers to a calling  program  using  registers
           zero and one. Common examples are Sort exits, lookup routines and
           user SVC's.
 
           The Structured Macros provide a method for passing back R0 and/or
           R1  from  a  program  block.   You can use the RTNR0 and/or RTNR1
           options on the program block macro and specify the R0= and/or R1=
           keyword on the ENDBLK for the program and all error exits.
 
              BLOCK NAME=TEST,TYPE=PROGRAM,OPTIONS=*PWA,RTNR0,RTNR1
                    :
                    :
              ENDBLK BLOCK=TEST,RC=0,R0=8,R1=PARMLIST
                    :
              BLOCK NAME=ERR1,TYPE=ERREXIT
                    :
              ENDBLK BLOCK=TEST,RC=8,R0=0,R1=0
 
           If you are using an internal subroutine that has an SWA and would
           like to have the subroutine return a register to its caller,  you
           can use the STRSA macro.
 
 
 
 
 
 
 
 
 
 
 
           60    Structured Macros Users's Guide
 
 
         |                     CHAPTER 14. STRUCTURED MACROS LISTING PROGRAM
                               CHAPTER 14. STRUCTURED MACROS LISTING PROGRAM
                               CHAPTER 14. STRUCTURED MACROS LISTING PROGRAM
                               CHAPTER 14. STRUCTURED MACROS LISTING PROGRAM
                               _____________________________________________
 
         | To  aid  the  programmer, a listing program was written that will
         | analyze the nesting structure of a  program  and  report  on  any
         | problems.    It  also  provides a listing of the original program
         | without the macro expansions that tend to blur the structured na-
         | ture of the program.  Once they have gotten used to it, many pro-
         | grammers use this listing for most of their work, and only  refer
         | to  the assembler listing occasionally.  JCL procedures have been
         | provided that will run this listing program and then feed the as-
         | sembler source into the Level H Assembler.  See "Appendix A. Cat-
         | alogued ASM Procedures At Clemson" for more information.
 
         | OUTPUT OF THE LISTING PROGRAM
           OUTPUT OF THE LISTING PROGRAM
           OUTPUT OF THE LISTING PROGRAM
           OUTPUT OF THE LISTING PROGRAM
           _____________________________
 
         | Below is an example of the output of the  listing  program.    It
         | displays  the original input source, along with the current nest-
         | ing level depth and a diagram of the nesting type  (Block,  Loop,
         | or If).
 
         |   LVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4  15:43 8
 
         |   001  B    | BLOCK   NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) |
         |   001  B    |*                                              |
         |   002  BL   |  LOOP   WHILE,(CR,R4,LT,R5)                   |
         |   003  BLI  |   IF    (C,R3,GE,XYZ)                         |
         |   003  BLI  |    MVC  ABC,XYZ                               |
         |   002  BL   |   ENDIF                                       |
         |   001  B    |  ENDLOOP WHILE                                |
         |   001  B    |  CALLSUB SUB1                                 |
         |   001  B    |*                                              |
         |   000       | ENDBLK  BLOCK=TEST                            |
         |   000       |*                                              |
         |   001  B    | BLOCK   NAME=SUB1,TYPE=SUBROUTINE             |
         |   001  B    |  LR     R1,R2                                 |
         |   000       | ENDBLK  BLOCK=SUB1                            |
         |   000       |*                                              |
         |   000       |         PSD                                   |
         |   000       |         LTORG                                 |
         |   000       |XYZ      DC    F'9'                            |
         |   000       |ABC      DC    F'4'                            |
         |   000       |         ENDPSD                                |
         |   000       |*                                              |
         |   000       |         PWA                                   |
         |   000       |PWAFLAG  DS    18F                             |
         |   000       |         ENDPWA                                |
         |   000       |*                                              |
         |   000       |         END                                   |
 
                         Chapter 14. Structured Macros Listing Program    61
 
 
         | The Structured Macros Listing Program will also point out any ir-
         | regularities  in  the nesting structure of the program.  Below is
         | the listing produced by feeding an incorrect program into it.
 
         |   LVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4  15:43 8
 
         |   001  B    | BLOCK   NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) |
         |   001  B    |*                                              |
         |   002  BI   |  IF     (C,R3,GE,XYZ)                         |
         |   002  BI   |*                                              |
         |   002  BI   | ENDBLK  BLOCK=TEST                            | >E-8 NE
         |   002  BI   |*                                              |
         |   002  BI   |         END                                   |
 
         |   >E-8 ENDING STRUCTURAL LEVEL IS NON-ZERO
 
         | CONTROLLING LISTING PROGRAM OPERATION
           CONTROLLING LISTING PROGRAM OPERATION
           CONTROLLING LISTING PROGRAM OPERATION
           CONTROLLING LISTING PROGRAM OPERATION
           _____________________________________
 
         | To  control  the  operation of the Structured Macros Listing Pro-
         | gram, the SMLIST macro has been provided.    Parameters  on  this
         | macro  are  processed  by  the listing program itself, before the
         | source statements are sent to the assembler.
 
         | Currently,  the  only  parameter  available  is   CONVERT=YES/NO.
         | CONVERT=YES  instructs  the  listing program to convert the input
         | source to all uppercase before feeding it to the assembler.  This
         | allows you to write programs in upper and lower case.  Many  peo-
         | ple find mixed case programs and comments easier to read and this
         | parameter makes it easy to do.
 
         | Although  the assembler requires that its input be in upper case,
         | lower case letters are allowed in text strings.   To prevent  the
         | listing  program  from converting your mixed case text strings to
         | upper case, place them in double quotes  (")  instead  of  single
         | quotes  (').   The listing programs will not convert the text be-
         | tween double quotes and will change the  double  quotes  back  to
         | single quotes before passing the line to the assembler.
 
         | With  this  facility, programmers can write programs like the one
         | below.
 
 
 
 
 
           62    Structured Macros Users's Guide
 
 
         |    TRYLOWER    TITLE 'Example program for Structured Macros'
         |                SMLIST CONVERT=YES
         |    *-----------------------------------------------------------------
         |    *  Program     TRYLOWER
         |    *
         |    *  Abstract    This illustrates the use of lower case in assembler
         |    *              source using the SMLIST CONVERT=YES function of the
         |    *              Structured Macros Listing Program.
         |    *-----------------------------------------------------------------
         |             space 3
         |     block   name=trylower,type=program,options=(*pwa,xa),amode=any,
         |                   rmode=any,r1save=r9
         |      l      r15,4(r9)                    | Get output routine address
         |      la     r1,psdtext                   | Get pointer to text.
         |      balr   r14,r15                      | Call output routine.
         |     endblk  block=trylower
         |             psd
         |    psdtext  dc    cl80"This is a test that is true."
         |             endpsd
         |             pwa
         |             endpwa
 
 
 
 
 
 
 
 
 
 
 
 
                         Chapter 14. Structured Macros Listing Program    63
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           64    Structured Macros Users's Guide
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                             II. STRUCTURED MACROS REFERENCE
                                             II. STRUCTURED MACROS REFERENCE
                                             II. STRUCTURED MACROS REFERENCE
                                             II. STRUCTURED MACROS REFERENCE
                                             _______________________________
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           66    Structured Macros Reference
 
 
                                                           CHAPTER 15. BLOCK
                                                           CHAPTER 15. BLOCK
                                                           CHAPTER 15. BLOCK
                                                           CHAPTER 15. BLOCK
                                                           _________________
 
           Macro:    BLOCK
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to start a block.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   BLOCK
           Syntax:
           Syntax:
           Syntax:
                     [NAME=name][,TYPE=type][,ENVIRON=environ][,keyword[,keyword
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name      Name  of block.  This operand is required for
                     ____
                               program and subroutine blocks.
 
                     type      Type of block.   This keyword  specifies  the
                     ____
                               type of block.  If this keyword is not speci-
                               fied, INLINE is assumed.
 
                               The  type of blocks are ERREXIT, INLINE, PRO-
                               GRAM, and SUBROUTINE.
 
                               An errexit block contains code to be executed
                               when an ERREXIT macro is executed.  This type
                               of block must be coded at block level zero.
 
                               Inline blocks are used to group a section  of
                               code into a logical structure.
 
                               Subroutine  blocks  contain code that is exe-
                               cuted when a  CALLSUB  macro  specifying  its
                               name is executed.  A subroutine block must be
                               coded at block level zero.
 
                               A  program  block is used to contain the main
                               code body of a program.   Program blocks  can
                               only be specified at block level zero.
 
                     environ   Program  environment.  This keyword specifies
                     _______
                               the type of environment the program will  run
                               in.    The  currently  supported environments
                               are: OS for OS linkage, DC  for  IDMS/DC  and
                               PLI for the execution environment of the PL/I
                               Optimizing  Compiler.   This keyword defaults
                               to OS.
 
                     keyword   Indicates linkage and  initialization  to  be
                     _______
                               done.    Using  these keywords will cause the
                               associated ENDBLK to do the reverse  linkage.
                               The  keywords  allowed  depend on the type of
                               block being defined.   (See the  sections  on
                               the  individual block types for more informa-
                               tion on the keywords allowed.)
 
                                                     Chapter 15. BLOCK    67
 
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Too many parameters specified on PL keyword
                         INLINE BLOCK must be contained within PROGRAM, SUB-
                         ROUTINE, or ERREXIT BLOCK
                         PROGRAM BLOCK must be at block nesting level 1
                         PROGRAM BLOCK requires NAME keyword
                         SUBROUTINE BLOCK requires NAME keyword
                         ENVIRON must be less than 5 alphanumeric characters
                         SUBROUTINE  BLOCK  must  follow  ENDBLK for PROGRAM
                         BLOCK and be at block level zero
                         ERREXIT BLOCK must follow ENDBLK for PROGRAM  BLOCK
                         and be at block level zero
                         Maximum nesting level for blocks is 20
                         Invalid BLOCK type <type>
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           68    Structured Macros Reference
 
 
           BLOCK TYPE=ERREXIT
           BLOCK TYPE=ERREXIT
           BLOCK TYPE=ERREXIT
           BLOCK TYPE=ERREXIT
           __________________
 
           The  errexit  block  surrounds code to be performed after a fatal
           error is detected.   It is invoked by the  ERREXIT  macro.    The
           ENDBLK  macro associated with an errexit block generates a branch
           to the ENDBLK code of the most recent program block,  and  allows
           you  to  specify a return code with which the program will termi-
           nate.  This return code overrides any return code that may appear
           on the program block's ENDBLK macro.  One errexit block without a
           name keyword can be associated with a  program  block,  in  which
           case,  a generated name is used.  Therefore, if you have only one
           errexit block, the NAME parameter may be left off  of  the  BLOCK
           and  the  ERREXIT  macros and a name will be automatically gener-
           ated.
 
           Keywords for ERREXIT blocks:
           ____________________________
 
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
                 Specifies the addressing mode  the  block  should  run  in.
                 Amode  switching  code  will be generated if required.  The
                 default is AMODE=ANY which specifies that the errexit  will
                 run in the amode in effect when it is invoked.
 
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
         |       Defines  the  default place to build parameter lists gener-
         |       ated within this block.   Tag defines  the  label  for  the
                                           ___
                 start  of parameter list storage and num is a self-defining
                                                      ___
                 term that represents the maximum number of  parameter  list
                 entries  that  the  storage at tag will hold.  This must be
                                                ___
                 large enough to contain the largest parameter list  in  the
                 block.  If num is not specified, the tag must have a length
                 modifier that is a self-defining term.
 
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
                 Requests that the register(s) named should be saved and re-
                 stored.    The  address  operand  provides the address of a
                                 _______
                 place to save the register(s).  If more than  one  register
                 is  specified, a "STM" instruction is generated: therefore,
                 specification of something like "R14,R12,address" is valid.
                 The SAVE keyword may be used on errexit blocks to  preserve
                 some  or all registers without requiring a standard OS save
                 area.  The SAVE operand is not valid on program blocks, and
                 should not be confused with OPTIONS=SAVE.
 
           Errors:
           Errors:
           Errors:
           Errors:
                 Refer to "Appendix B. Internal Macros  Error  Messages"  on
                 page 123 for macros that start with "##EP".
 
 
 
                                                     Chapter 15. BLOCK    69
 
 
           BLOCK TYPE=INLINE
           BLOCK TYPE=INLINE
           BLOCK TYPE=INLINE
           BLOCK TYPE=INLINE
           _________________
 
           The  inline  block  is  used  to  surround a section of code that
           should be treated as a single unit.  With the inline block, AMODE
           can be changed at the beginning of the block and restored at  the
           end.  Registers can also be saved and restored.  The inline block
           also  allows  the user to define a logical group of code that can
           be exited with the LEAVE macro.
 
           Keywords for INLINE blocks:
           ___________________________
 
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
                 Specifies the addressing mode  the  block  should  run  in.
                 Amode  switching  code  will be generated if required.  The
                 default is AMODE=ANY which specifies that  the  block  will
                 run in the amode in effect when it is entered.
 
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
         |       Defines  the  default place to build parameter lists gener-
         |       ated within this block.   Tag defines  the  label  for  the
                                           ___
                 start  of parameter list storage and num is a self-defining
                                                      ___
                 term that represents the maximum number of  parameter  list
                 entries  that  the  storage at tag will hold.  This must be
                                                ___
                 large enough to contain the largest parameter list  in  the
                 block.  If num is not specified, the tag must have a length
                 modifier that is a self-defining term.
 
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
                 Requests that the register(s) named should be saved and re-
                 stored.    The  address  operand  provides the address of a
                                 _______
                 place to save the register(s). If more than one register is
                 specified, a "STM"  instruction  is  generated:  therefore,
                 specification of something like "R14,R12,address" is valid.
                 The  SAVE  keyword may be used on inline blocks to preserve
                 some or all registers without requiring a standard OS  save
                 area.  The SAVE operand is not valid on program blocks, and
                 should not be confused with OPTIONS=SAVE.
 
           Errors:
           Errors:
           Errors:
           Errors:
                 Refer  to  "Appendix  B. Internal Macros Error Messages" on
                 page 123 for macros that start with "##IP".
 
 
 
 
 
           70    Structured Macros Reference
 
 
           BLOCK TYPE=PROGRAM,ENVIRON=DC
           BLOCK TYPE=PROGRAM,ENVIRON=DC
           BLOCK TYPE=PROGRAM,ENVIRON=DC
           BLOCK TYPE=PROGRAM,ENVIRON=DC
           _____________________________
 
           The  IDMS/DC  program block, like the OS program block, surrounds
           the main body of executable code. Options on the IDMS/DC  program
           block  determine  what type of IDMS/DC linkage is to be used, how
           IDMS/DC macros are to be expanded,  and  end-of-task  information
           for  application  programs (for example, NEXT TASK CODE), as well
           as reentrancy, register equating, and PWA allocation.
 
           Keywords for program blocks with ENVIRON=DC specified:
           ______________________________________________________
 
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
                 Regular options:  These are the  options  for  individually
                 Regular options:
                 Regular options:
                 Regular options:
                 controlling  each  of the BLOCK macro's functions.  The de-
                 fault value for each of these options is the negative  form
                 (NOCSECT, NOREGEQU, etc.) but note that many of the options
                 are included in all of the super options.
 
                 CSECT|NOCSECT:   Indicates that a CSECT card should be gen-
                 ______________
                 erated with the name of the block.   If NOCSECT  is  speci-
                 fied,  you  will  need  to code a USING name,R15 before the
                 BLOCK macro if the LOADBASE option is in affect.
 
                 ID|NOID:  Specifies that a DC should be  generated  at  the
                 ________
                 start  of  the  program, containing the program block name,
                 assembly date, and assembly time.  If the  CPYRGHT  keyword
                 is specified, it will also be DC'ed.
 
                 LOCTR|NOLOCTR:   Cause  the  macros  to  generate LOCTR in-
                 ______________
                 structions for the program, subroutines,  and  static  data
                 areas  to insure proper placement.  This option must be se-
                 lected if the program is using PSDs and SSDs  or  LONG  and
                 LOADBASE.
 
                 LONG|NOLONG:   Indicates  that  CALLSUBs  should generate a
                 ____________
                 BALR (or equivalent) instead of a BAL to allow  subroutines
                 to  establish  a base register.  This option is required if
                 the program has any subroutines that  use  LOADBASE.    The
                 LOCTR option is required if this option is specified.
 
                 MODE|NOMODE:  Enables generation of AMODE and RMODE cards.
                 ____________
 
                 PWA|NOPWA:   Specifies  that  this program will have a PWA.
                 __________
                 The PWA will be acquired  using  #GETSTG  and  freed  using
                 #FREESTG if option RENT is in effect.  If the NORENT option
                 is  in effect, the ENDPWA macro will generate a DS instruc-
                 tion to reserve storage for the PWA within the CSECT.   The
                 PWA  and  ENDPWA macros should be used to define the limits
                 of the PWA.  This option is required  if  the  program  has
                 subroutines that use SWAs.
 
 
                                                     Chapter 15. BLOCK    71
 
 
                 REGEQU|NOREGEQU:  Specifies that register equates are to be
                 ________________
                 generated.
 
                 RENT|NORENT:   Specifies  that the program is reentrant and
                 ____________
                 that the macros should  generate  reentrant  code  wherever
                 necessary.
 
                 RTNR0|NORTNR0:   Indicates  that  register  zero  should be
                 ______________
                 passed back to the caller.   Use the  R0=  keyword  on  the
                 ENDBLK macro for the program block and error exits to spec-
                 ify  the  value  to  be  returned.  This is only valid with
                 OPTIONS=SYSTEM, unless the routine is handling its own  de-
                 linkage  and  needs  a  value in R0 from within the program
                 block.
 
                 RTNR1|NORTNR1:   Indicates  that  register  one  should  be
                 ______________
                 passed  back  to  the  caller.   Use the R1= keyword on the
                 ENDBLK macro for the program block and error exits to spec-
                 ify the value to be  returned.  This  is  only  valid  with
                 OPTIONS=SYSTEM,  unless the routine is handling its own de-
                 linkage and needs a value in R1  from  within  the  program
                 block.
 
                 VL|NOVL:   Forces  all  generated  parameter  lists (PLIST,
                 ________
                 CALLSUB, CALLX) to default to VL unless overridden.
 
                 XA|NOXA:   Generates  support  for  linkage  using  XA  in-
                 ________
                 structions.   If neither XA or 370 is specified, 370 is the
                 default.
 
                 370|NO370:  Generates support for  linkage  using  370  in-
                 __________
                 structions.    If OPTIONS=XA is also specified, OPTIONS=370
                 causes generation of code which determines whether the pro-
                 gram is  running  under  MVS/XA  or  not,  and  will  cause
                 branches  around XA-dependent instructions generated by the
                 Structured Macros such as the amode switches.
 
                 DCMACPRT/NODCMACPRT:   Provides  support  for   the   #MOPT
                 ____________________
                 MACPRNT=ON/OFF  operand, for those IDMS/DC macros that make
                 use of it.
 
                 DCPRGPRT/NODCPRGPRT:   Provides  support  for   the   #MOPT
                 ____________________
                 PRGPRNT=ON/OFF  operand, for those IDMS/DC macros that make
                 use of it.
 
                 SYSTEM or (SYSTEM,module#) /  NOSYSTEM:   Presence  of  the
                 _______________________________________
                 SYSTEM  keyword  causes  IDMS/DC  system-mode linkage to be
                 generated.
 
                 #START/NO#START:  Causes a #START macro to be generated  by
                 ________________
                 the BLOCK macro. Valid only with the SYSTEM option.
 
                 #RTN/NO#RTN:   Causes  a  #RTN macro to be generated by the
                 ____________
                 ENDBLK macro. Valid only with the SYSTEM option.
 
           72    Structured Macros Reference
 
 
                 #RETURN/NO#RETURN:  Causes ENDBLK  to  generate  a  #RETURN
                 __________________
                 macro. Valid only with NOSYSTEM option.
 
                 GETSTK:   Causes  BLOCK  to  generate  a #GETSTK instead of
                 _______
                 #GETSTG. Valid only with SYSTEM and PWA options.
 
                 (NXTTASK,taskcode):  Specifies the IDMS/DC task code  which
                 ___________________
                 should be initiated next.  Valid only with #RETURN option.
 
                 (TYPE,returntype):   Specifies  the  type of program termi-
                 __________________
                 nation (NORMAL, ABORT or CONTINUE). This option  is  gener-
                 ally used only with IDMS/DC #STAE routines. Valid only with
                 #RETURN option.
 
                 (RESINT,interval):  Specifies the resource timeout interval
                 __________________
                 for this task termination.  Valid only with #RETURN option.
 
                 (RESPGM,pgmname):   Specifies  a  resource  timeout handler
                 _________________
                 program, which will be called if the resource  timeout  in-
                 terval  was specified and reached.  Valid only with #RETURN
                 option.
 
                 (EP,entrypoint):  Specifies an entry point name (other than
                 ________________
                 the CSECT name) to be included on the #START macro. If this
                 option is not coded, the entry point name is assumed to  be
                 "#ST"  followed  by the internal program block number (usu-
                 ally 1).  Valid only with SYSTEM and #START options.
 
                 If a type of regular option is specified  more  than  once,
                 the last occurrence (ie. PWA or NOPWA) is used.
 
                 Super  options:   These are provided as combinations of the
                 Super  options:
                 Super  options:
                 Super  options:
                 most popular options. If one or more options is not needed,
                 it should be  specified  as  desired  following  the  super
                 option's specification.
 
                 *NORENT  -  selects options CSECT, ID, LOCTR, MODE, REGEQU,
                 VL and #RETURN.
 
                 *NORENTSYS  -  selects  options  CSECT,  ID,  LOCTR,  MODE,
                 REGEQU, VL, #START, #RTN and SYSTEM.
 
                 *RENT  -  selects  options  CSECT, ID, LOCTR, MODE, REGEQU,
                 RENT, VL and #RETURN.
 
                 *RENTSYS - selects options CSECT, ID, LOCTR, MODE,  REGEQU,
                 RENT, VL, #START, #RTN and SYSTEM.
 
                 *PWA - selects options CSECT, ID, LOCTR, MODE, PWA, REGEQU,
                 RENT, VL and #RETURN.
 
                 *PWASYS  -  selects  options  CSECT,  ID, LOCTR, MODE, PWA,
                 REGEQU, RENT, VL, #START, #RTN and SYSTEM.
 
                                                     Chapter 15. BLOCK    73
 
 
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
                 Specifies the addressing mode.    This  keyword  causes  an
                 AMODE card to be generated by the assembler with the speci-
                 fied  amode.    If  this keyword is not specified, no AMODE
                 card will be generated.
 
           BASEREG= reg | (reg[,reg[,...]])
           BASEREG= reg | (reg[,reg[,...]])
           BASEREG= reg | (reg[,reg[,...]])
           BASEREG= reg | (reg[,reg[,...]])
                 Specifies  the register or registers to be used for program
                 addressability.  The register can not be R0,  R1,  R14,  or
                 R15.    BASEREG will default to R13 if the NORENT option is
                 in effect and the SVAREA keyword is not  specified;  other-
                 wise, it will default to R12.
 
           CPYRGHT= notice
           CPYRGHT= notice
           CPYRGHT= notice
           CPYRGHT= notice
                 Specifies  a quoted string that will be DC'ed if the ID op-
                 tion is in effect.
 
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
         |       Defines the default place to build parameter  lists  gener-
         |       ated  within  this  block.    Tag defines the label for the
                                               ___
                 start of parameter list storage and num is a  self-defining
                                                     ___
                 term  that  represents the maximum number of parameter list
                 entries that the storage at tag will hold.   This  must  be
                                             ___
                 large  enough  to contain the largest parameter list in the
                 block.  If num is not specified, the tag must have a length
                 modifier that is a self-defining term.
 
           PWAREG= R11 | (R11,[reg[,...]])
           PWAREG= R11 | (R11,[reg[,...]])
           PWAREG= R11 | (R11,[reg[,...]])
           PWAREG= R11 | (R11,[reg[,...]])
                 Specifies the register or registers to be used for PWA  ad-
                 dressability.
 
           RMODE= 24 | ANY
           RMODE= 24 | ANY
           RMODE= 24 | ANY
           RMODE= 24 | ANY
                 Specifies the residency mode.
 
           R1SAVE= register
           R1SAVE= register
           R1SAVE= register
           R1SAVE= register
                 The number of the register that register 1 should be copied
                 to.    Program  linkage  (notably  the  use  of  #GETSTG or
                 #GETSTK) sometimes destroys the contents of register 1 from
                 entry.  This keyword is useful for copying the contents  of
                 the parameter register to another register before it is de-
                 stroyed.
 
           SMWA= address
           SMWA= address
           SMWA= address
           SMWA= address
                 Provides the address of a Structured Macro Workarea (SMWA).
                 The  SMWA  is a doubleword of storage which is used to pre-
                 serve addressing mode and a work register while  performing
                 AMODE  switching.  The SMWA keyword is valid only on a PRO-
                 GRAM block, and is  required  when  both  the  370  and  XA
                 options  are in effect, or when AMODE=ANY is specified. The
                 SMWA may reside in the PWA.   If the  program  has  a  PWA,
                 space  for  the SMWA is automatically allocated in the PWA,
                 and this keyword is not necessary.
 
 
           74    Structured Macros Reference
 
 
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
                 Can be used to specify a default set  of  options  for  all
                 subroutine  blocks  associated  with  this  program.    Any
                 options specified on subsequent subroutine blocks  will  be
                 in  addition to these options.  See "BLOCK TYPE=SUBROUTINE"
                 for a description of the valid subroutine block options.
 
                 Errors:
                 Errors:
                 Errors:
                 Errors:
                       Refer to ##PPDC in "Appendix B. Internal Macros Error
                       Messages" on page 123.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                     Chapter 15. BLOCK    75
 
 
           BLOCK TYPE=PROGRAM,ENVIRON=OS
           BLOCK TYPE=PROGRAM,ENVIRON=OS
           BLOCK TYPE=PROGRAM,ENVIRON=OS
           BLOCK TYPE=PROGRAM,ENVIRON=OS
           _____________________________
 
           The program block surrounds the main body of executable code.  It
           can  perform a wide variety of linkage types and initializations,
           including standard save area linkage, register equates, automatic
           allocation of Program Work Area, and Dynamic Storage  Management.
           If  the program block keywords and options are not used to estab-
           lish linkage,  the BLOCK macro call should  follow  linkage  code
           and the associated ENDBLK macro should be followed by the reverse
           linkage.
 
           Keywords for program blocks with ENVIRON=OS specified:
           ______________________________________________________
 
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
                 Regular  options:    These are the options for individually
                 Regular  options:
                 Regular  options:
                 Regular  options:
                 controlling each of the BLOCK macro's functions.   The  de-
                 fault  value for each of these options is the negative form
                 (NOBR14, NOCSECT, etc.) but note that many of  the  options
                 are included in all of the super options.
 
                 BR14|NOBR14:   Determines  whether a program block's ENDBLK
                 ____________
                 macro should generate a BR 14 instruction or not.  The  de-
                 fault is NOBR14, but note that BR14 is included in each su-
                 per option.
 
                 CLEARPWA|NOCLEARPWA:   Specifies  whether the PWA should be
                 ____________________
                 cleared to zeros or not.
 
                 CLRDEBUG|NOCLRDEBUG:  Specifies whether the debug  area  in
                 ____________________
                 the  ESV  should be cleared at entry to this program block.
                 CLRDEBUG requires the ESV option.
 
                 CSECT|NOCSECT:  Indicates that a CSECT card should be  gen-
                 ______________
                 erated  with  the  name  of  the  block  along with a USING
                 name,R15.  If NOCSECT is specified, you will need to code a
                 USING name,R15 before the BLOCK macro if the  LOADBASE  op-
                 tion is in affect.
 
                 DYN|NODYN:    Indicates  that  Dynamic  Storage  Management
                 __________
                 should be used.  With this option, PWA and SWA  storage  is
                 allocated  from the dynamic storage area.  When the DYN op-
                 tion is on, register 11 is used as a base for SWAs and  can
                 not be used by the programmer.
 
                 ERRADDR|NOERRADDR:  Indicates that the ERREXIT macro should
                 __________________
                 use  a  BAS instruction when branching to an errexit block.
                 If a code is specified, it will be defined in the  halfword
                 immediately  following  the BAS instruction.  The effect of
                 the ERRADDR option is that at entry to  an  errexit  block,
                 the  CODEREG has the address of the invoking ERREXIT macro.
                 If NOERRADDR is specified, a BCC instruction  is  generated
 
           76    Structured Macros Reference
 
 
                 by  the  ERREXIT  macro  to invoke an errexit block and the
                 CODEREG is loaded with the code itself.
 
                 (ESV,[parmnum],[esvtag])|NOESV:  Specifies that an Environ-
                 _______________________________
                 ment  Support  Vector is present.   The macros will use the
                 ESV to locate routines to do all environment dependent ser-
                 vices.  Parameter parmnum defaults to 3 and is  the  number
                                   _______
                 of  the  parameter  at input to the program block that con-
                 tains a pointer to the ESV.  If the FNCODE option is in ef-
                 fect, this parameter is only referenced  on  the  "startup"
                 call.   Parameter esvtag defaults to PWAAESV and is the tag
                                   ______
                 to be generated in the PWA for a word into which  the  pro-
                 gram  block  macro  will store the address of the ESV.  The
                 ESV option requires the PWA and RENT options.    The  NOESV
                 option  indicates  that  the macros should call OS services
                 directly.
 
                 (FNCODE,[parmnum],[startcode])|NOFNCODE:  Specifies that  a
                 ________________________________________
                 function  code  is  passed  as a parameter to this program.
                 Parameter parmnum defaults to 2 and is the  number  of  the
                           _______
                 parameter  at  input  to  the program block that contains a
                 pointer to the function code.  Parameter startcode defaults
                                                          _________
                 to AL4(1) and is the value of the  startup  function  code.
                 This  parameter  can be any form that is valid to the right
                 of a DC instruction.   This option  is  ignored  if  option
                 REUSPWA is not in effect.
 
                 ID|NOID:   Specifies  that  a DC should be generated at the
                 ________
                 start of the program, containing the  program  block  name,
                 assembly  date,  and assembly time.  If the CPYRGHT keyword
                 is specified, it will also be DC'ed.
 
                 LOADBASE|NOLOADBASE:  Specifies that program base registers
                 ____________________
                 are to be loaded.  LOADBASE  is  assumed  if  the  BASEREG=
                 keyword is specified.
 
                 LOCTR|NOLOCTR:   Cause  the  macros  to  generate LOCTR in-
                 ______________
                 structions for the program, subroutines,  and  static  data
                 areas  to insure proper placement.  This option must be se-
                 lected if the program is using PSDs and SSDs  or  LONG  and
                 LOADBASE.
 
                 LONG|NOLONG:   Indicates  that  CALLSUBs  should generate a
                 ____________
                 BALR (or equivalent) instead of a BAL to allow  subroutines
                 to  establish  a base register.  This option is required if
                 the program has any subroutines that  use  LOADBASE.    The
                 LOCTR option is required if this option is specified.
 
                 MAIN|NOMAIN:  Indicates that this is a main program and dy-
                 ____________
                 namic  storage should always be obtained if Dynamic Storage
                 Management is being used.   If  NOMAIN  is  specified,  the
                 storage  already  allocated  by the calling program will be
                 used if it is sufficient, otherwise extra storage  will  be
                 obtained.
 
                                                     Chapter 15. BLOCK    77
 
 
                 MODE|NOMODE:  Enables generation of AMODE and RMODE cards.
                 ____________
 
                 OPTSTOR|NOOPSTOR:   Turns on storage optimization to reduce
                 _________________
                 the size of the load module.  If your program has  a  large
                 number of internal subroutines, this can save you a signif-
                 icant  amount  of  storage,  but  will slow down subroutine
                 calls slightly.   This option in only  valid  for  programs
                 with the DYN option.
 
         |       (PARMS[,options...])|NOPARMS:   Indicates that this program
                 _____________________________
         |       has an input parameter  list  and  therefore  register  one
         |       should be preserved during program linkage.  This option is
         |       also used to specify options for handling the input parame-
         |       ter  list.  Any parameter option not specified will take on
         |       its default, "NO" state.  The available  parameter  options
         |       are:
 
         |       COPY|NOCOPY:   Specifies  that  the  input  parameter  list
                 COPY|NOCOPY:
                 COPY|NOCOPY:
                 COPY|NOCOPY:
                 ____________
         |       should be copied to the PWA.  An area large enough to  con-
         |       tain  the  entire list is reserved and the entire parameter
         |       list is copied here at the start of the program.  Any miss-
         |       ing parameters (including those left off the end  of  a  VL
         |       parameter  list)  will  contain an address of zero.  Use of
         |       this option requires the PWA option.
         |       (COPYERROR,errexit[,exitcode])|NOCOPYERROR:  Identifies  an
                 (COPYERROR,errexit[,exitcode])|NOCOPYERROR:
                 (COPYERROR,errexit[,exitcode])|NOCOPYERROR:
                 (COPYERROR,errexit[,exitcode])|NOCOPYERROR:
                 ___________________________________________
         |       error exit and optionally an exit code that will be invoked
         |       if the input parameter list overruns the space reserved for
         |       it  in  the  PWA  during a (PARMS,COPY,VL) operation.  This
         |       suboption is required when  (PARMS,COPY,VL)  is  specified.
         |       If specified, exitcode is passed in the default code regis-
                               ________
         |       ter  R14  and must follow the same restrictions as CODE= on
         |       the ERREXIT macro.   If errexit  is  specified  as  a  null
                                         _______
         |       string, e.g.  (COPYERROR,), the unnamed error exit for this
         |       program block will be invoked in case of a copy failure.
         |       (COUNT,tag)|NOCOUNT:  Specifies that a count of the parame-
                 (COUNT,tag)|NOCOUNT:
                 (COUNT,tag)|NOCOUNT:
                 (COUNT,tag)|NOCOUNT:
                 ____________________
         |       ters actually specified in the input parameter list be made
         |       and  that  the result be placed in the fullword at location
         |       tag.  The use of this option requires the VL  suboption  of
                 ___
         |       PARMS.
         |       PREFIX|NOPREFIX:   Specifies  that  the  tags listed in the
                 PREFIX|NOPREFIX:
                 PREFIX|NOPREFIX:
                 PREFIX|NOPREFIX:
                 ________________
         |       PARMS keyword for this block should be  prefixed  with  the
         |       &PPL  symbol before placing them within the PPL.  This give
         |       all the tags within the PPL a unique prefix so  there  will
         |       not  be  any  collisions with tags within other structures.
         |       If this option is specified, any references to tags  within
         |       the  PPL  from  the  program  will  have  to  be  coded as:
         |       &PPL.tag
                      ___
         |       (USING,reg)|NOUSING:  Specifies that reg should be used  to
                 (USING,reg)|NOUSING:                 ___
                 (USING,reg)|NOUSING:
                 (USING,reg)|NOUSING:
                 ____________________
         |       establish  addressibility on the input parameter list.  The
         |       specified register is loaded with the contents of  register
         |       one  unless  the  COPY  option is also specified.   In this
         |       case, reg will be loaded with the address of the input  pa-
                       ___
         |       rameter list storage in the PWA.
 
           78    Structured Macros Reference
 
 
         |       VL|NOVL:  Specifies that the input parameter list is a var-
                 VL|NOVL:
                 VL|NOVL:
                 VL|NOVL:
                 ________
         |       iable  length (VL) parameter list.  For VL parameter lists,
         |       the COPY option will loop through the parameters instead of
         |       doing a block copy.  If the COPY option is being used,  the
         |       high  order  bit  in  the last item of the copied parameter
         |       list will be cleared.
 
                 PWA|NOPWA:  Specifies that this program will  have  a  PWA.
                 __________
                 The  PWA  will be either GETMAINed or obtained from dynamic
                 storage if option RENT is in effect.  If the NORENT  option
                 is  in effect, the ENDPWA macro will generate a DS instruc-
                 tion to reserve storage for the PWA within the CSECT.   The
                 PWA  and  ENDPWA macros should be used to define the limits
                 of the PWA.  This option is required  if  the  program  has
                 subroutines that use SWAs.
 
                 REGEQU|NOREGEQU:  Specifies that register equates are to be
                 ________________
                 generated.
 
                 RENT|NORENT:   Specifies  that the program is reentrant and
                 ____________
                 that the macros should  generate  reentrant  code  wherever
                 necessary.
 
                 (REUSPWA,[parmnum])|NOREUSPWA:  Specifies that the same PWA
                 ______________________________
                 storage  should  be  used  on multiple calls to the program
                 block.  Parameter parmnum defaults to 1 and is  the  number
                                   _______
                 of  the  parameter  at input to the program block that con-
                 tains a pointer to the PWA anchor.  If the FNCODE option is
                 in effect, the PWA is obtained and its  address  stored  in
                 the  anchor  on  the "startup" call.  If NOFNCODE is in ef-
                 fect, the PWA is obtained and its address stored  when  the
                 anchor at entry contains binary zeros.  The PWA is freed by
                 the  ENDBLK  macro  when  the SMCTRL macro with FREEPWA=YES
                 specified has been executed.   REUSPWA  requires  the  PWA,
                 RENT  and  SAVE options.   NOREUSPWA indicates that the PWA
                 should be obtained and freed each time the program block is
                 called.
 
                 RTNR0|NORTNR0:  Indicates  that  register  zero  should  be
                 ______________
                 passed  back  to  the  caller.   Use the R0= keyword on the
                 ENDBLK macro for the program block and error exits to spec-
                 ify the value to be returned.
 
                 RTNR1|NORTNR1:   Indicates  that  register  one  should  be
                 ______________
                 passed  back  to  the  caller.   Use the R1= keyword on the
                 ENDBLK macro for the program block and error exits to spec-
                 ify the value to be returned.
 
                 SAVE|NOSAVE:   Save  R14-R12  in  the  standard  save  area
                 ____________
                 pointed to by register 13.
 
                 SAVEAREA|NOSAVEAREA:   Obtain  a  save area, do forward and
                 ____________________
                 backward linking, and point R13  to  new  save  area.    If
                 NORENT  was  specified,  the save area will be obtained in-
 
                                                     Chapter 15. BLOCK    79
 
 
                 line.  If RENT was specified, it will be GETMAINed  or  ob-
                 tained from the PWA.  SAVEAREA is assumed if the PWA option
                 is specified.
 
                 VL|NOVL:   Forces  all  generated  parameter  lists (PLIST,
                 ________
                 CALLSUB, CALLX) to default to VL unless overridden.
 
                 XA|NOXA:   Generates  support  for  linkage  using  XA  in-
                 ________
                 structions.   If neither XA or 370 is specified, 370 is the
                 default.
 
                 370|NO370:  Generates support for  linkage  using  370  in-
                 __________
                 structions.    If OPTIONS=XA is also specified, OPTIONS=370
                 causes generation of code which determines whether the pro-
                 gram is  running  under  MVS/XA  or  not,  and  will  cause
                 branches  around XA-dependent instructions generated by the
                 Structured Macros such as the amode switches.
 
                 If a type of regular option is specified  more  than  once,
                 the last occurrence (ie. PWA or NOPWA) is used.
 
                 Super  options:   These are provided as combinations of the
                 Super  options:
                 Super  options:
                 Super  options:
                 most popular options.   If  one  or  more  options  is  not
                 needed, it should be specified as desired following the su-
                 per option's specification.
 
                 *NORENT  -  selects  options  NOPWA,  SAVE, BR14, SAVEAREA,
                 NORENT, ID,  CSECT,  REGEQU,  LOADBASE,  MODE,  VL,  NODYN,
                 NOMAIN,   NOLONG,   LOCTR,   NORTNR0,  NORTNR1,  NOREUSPWA,
                 NOFNCODE, NOESV, NOERRADDR and NOCLRDEBUG.
 
                 *RENT - selects options NOPWA, SAVE, BR14, SAVEAREA,  RENT,
                 ID,  CSECT,  REGEQU,  LOADBASE,  MODE,  VL,  NODYN, NOMAIN,
                 NOLONG,  LOCTR,  NORTNR0,  NORTNR1,  NOREUSPWA,   NOFNCODE,
                 NOESV, NOERRADDR and NOCLRDEBUG.
 
                 *PWA - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA,
                 RENT, ID, CSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN,
                 NOLONG,   LOCTR,  NORTNR0,  NORTNR1,  NOREUSPWA,  NOFNCODE,
                 NOESV, NOERRADDR and NOCLRDEBUG.
 
                 *MAIN  -  selects  options  PWA,  CLEARPWA,   SAVE,   BR14,
                 SAVEAREA, RENT, ID, CSECT, REGEQU, LOADBASE, MODE, VL, DYN,
                 MAIN, NOLONG, LOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE,
                 NOESV, NOERRADDR and NOCLRDEBUG.
 
                 *NOMAIN  -  selects  options  PWA,  CLEARPWA,  SAVE,  BR14,
                 SAVEAREA, RENT, ID, CSECT, REGEQU, LOADBASE, MODE, VL, DYN,
                 NOMAIN,  NOLONG,  LOCTR,   NORTNR0,   NORTNR1,   NOREUSPWA,
                 NOFNCODE, NOESV, NOERRADDR and NOCLRDEBUG.
 
                 *SRVPRC  -  selects  options  PWA,  CLEARPWA,  SAVE,  BR14,
                 SAVEAREA, RENT, ID,  CSECT,  REGEQU,  LOADBASE,  MODE,  XA,
                 NO370,  VL, NODYN, NOMAIN, NOLONG, LOCTR, NORTNR0, NORTNR1,
 
           80    Structured Macros Reference
 
 
                 (REUSPWA,1),  (FNCODE,2,AL4(1)),  (ESV,3,PWAAESV),  ERRADDR
                 and CLRDEBUG.
 
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
                 Specifies  the  addressing  mode.    This keyword causes an
                 AMODE card to be generated by the assembler with the speci-
                 fied amode.  If this keyword is  not  specified,  no  AMODE
                 card will be generated.
 
           BASEREG= reg | (reg[,reg[,...]])
           BASEREG= reg | (reg[,reg[,...]])
           BASEREG= reg | (reg[,reg[,...]])
           BASEREG= reg | (reg[,reg[,...]])
                 Specifies  the register or registers to be used for program
                 addressability.  The register can not be R0,  R1,  R14,  or
                 R15.    BASEREG will default to R13 if the NORENT option is
                 in effect and the SVAREA keyword is not  specified;  other-
                 wise, it will default to R12.
 
           CPYRGHT= notice
           CPYRGHT= notice
           CPYRGHT= notice
           CPYRGHT= notice
                 Specifies  a quoted string that will be DC'ed if the ID op-
                 tion is in effect.
 
           DYNERR= name
           DYNERR= name
           DYNERR= name
           DYNERR= name
                 Specifies the name of the dynamic storage error exit  name.
                 If  DYNERR is not specified and a dynamic storage error oc-
                 curs, an ABEND 0C1 will occur.
 
           DYNSIZE= [+|-]size
           DYNSIZE= [+|-]size
           DYNSIZE= [+|-]size
           DYNSIZE= [+|-]size
                 Defines the amount of storage to be added to the PWA to  be
                 used  for  additional  PWAs and SWAs.   A "+" or "-" can be
                 specified to indicate that the size should be added or sub-
                 tracted from the size calculated by the macros.    If  this
                 keyword is not specified, the size calculated by the macros
                 is used.
 
         | PARMMAP=(dsect[,len])
           PARMMAP=(dsect[,len])
           PARMMAP=(dsect[,len])
           PARMMAP=(dsect[,len])
         |       Defines  the  Dsect  to  be used to map the input parameter
         |       list and its length.  This keyword can be used if the input
         |       parameter list is too  complicated  to  describe  with  the
         |       PARMS  keyword or if the input parameter list is a standard
         |       form described by an existing Dsect.  len is only  required
                                                       ___
         |       if  COPY  is specified with the PARMS option.  This keyword
         |       is mutually exclusive with the PARMS keyword.
 
         | PARMS=(tag[,tag[,...]])
           PARMS=(tag[,tag[,...]])
           PARMS=(tag[,tag[,...]])
           PARMS=(tag[,tag[,...]])
         |       Defines the tags used to  map  the  input  parameter  list.
         |       These  will  be used to generate the Program Parameter List
         |       (PPL) Dsect or to map the input parameter list  storage  in
         |       the  PWA  (if  parameter  option COPY was specified).  This
         |       also defines the size of the input parameter list  for  the
         |       COPY  option.   This keyword is mutually exclusive with the
         |       PARMMAP keyword.
 
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
         |       Defines the default place to build parameter  lists  gener-
         |       ated  within  this  block.    Tag defines the label for the
                                               ___
 
                                                     Chapter 15. BLOCK    81
 
 
                 start of parameter list storage and num is a  self-defining
                                                     ___
                 term  that  represents the maximum number of parameter list
                 entries that the storage at tag will hold.   This  must  be
                                             ___
                 large  enough  to contain the largest parameter list in the
                 block.  If num is not specified, the tag must have a length
                 modifier that is a self-defining term.
 
           PWAREG= R13 | (R13,[reg[,...]])
           PWAREG= R13 | (R13,[reg[,...]])
           PWAREG= R13 | (R13,[reg[,...]])
           PWAREG= R13 | (R13,[reg[,...]])
                 Specifies the register or registers to be used for PWA  ad-
                 dressability.
 
           PWASP= number | symbol
           PWASP= number | symbol
           PWASP= number | symbol
           PWASP= number | symbol
                 Specifies  the number of the subpool in which the PWA is to
                 be GETMAINed.   PWASP may  only  be  specified  on  PROGRAM
                 blocks  with  PWA  included  among the OPTIONS. The default
                 subpool is zero.
 
           RMODE= 24 | ANY
           RMODE= 24 | ANY
           RMODE= 24 | ANY
           RMODE= 24 | ANY
                 Specifies the residency mode.
 
           R1SAVE= register
           R1SAVE= register
           R1SAVE= register
           R1SAVE= register
                 The number of the register that register 1 should be copied
                 to.   Program linkage sometimes destroys  the  contents  of
                 register  1 from entry.  This keyword is useful for copying
                 the contents of the parameter register to another  register
                 before it is destroyed.
 
           SMWA= address
           SMWA= address
           SMWA= address
           SMWA= address
                 Provides the address of a Structured Macro Workarea (SMWA).
                 The  SMWA  is a doubleword of storage which is used to pre-
                 serve addressing mode and a work register while  performing
                 AMODE  switching.  The SMWA keyword is valid only on a PRO-
                 GRAM block, and is  required  when  both  the  370  and  XA
                 options  are in effect, or when AMODE=ANY is specified. The
                 SMWA may reside in the PWA.   If the  program  has  a  PWA,
                 space  for  the SMWA is automatically allocated in the PWA,
                 and this keyword is not necessary.
 
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
                 Can be used to specify a default set  of  options  for  all
                 subroutine  blocks  associated  with  this  program.    Any
                 options specified on subsequent subroutine blocks  will  be
                 in  addition to these options.  See "BLOCK TYPE=SUBROUTINE"
                 for a description of the valid subroutine block options.
 
           SVAREA= tag
           SVAREA= tag
           SVAREA= tag
           SVAREA= tag
                 Can be specified if the NORENT  option  is  in  effect  and
                 specifies  a  relocatable  tag that will be used to address
                 the program save area.
 
           Errors:
           Errors:
           Errors:
           Errors:
                 Refer to ##PPOS in "Appendix B. Internal Macros Error  Mes-
                 sages" on page 123.
 
           82    Structured Macros Reference
 
 
           BLOCK TYPE=PROGRAM,ENVIRON=PLI
           BLOCK TYPE=PROGRAM,ENVIRON=PLI
           BLOCK TYPE=PROGRAM,ENVIRON=PLI
           BLOCK TYPE=PROGRAM,ENVIRON=PLI
           ______________________________
 
           The program block surrounds the main body of executable code.  If
           ENVIRON=PLI  is specified, options can be specified to do various
           initialization and termination functions specific to the OS  PL/I
           Optimizing  Compiler's  execution  time environment including ob-
           taining and freeing a DSA, doing register  equates  and  automat-
           ically defining a DSA within the Program Work Area.
 
           Keywords for program blocks with ENVIRON=PLI specified:
           _______________________________________________________
 
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
                 Regular  options:    These are the options for individually
                 Regular  options:
                 Regular  options:
                 Regular  options:
                 controlling each of the BLOCK macro's functions.   The  de-
                 fault  value for each of these options is the negative form
                 (NOREGEQU, NOCSECT, etc.) but note that many of the options
                 are included in all of the super options.
 
                 CLEARPWA|NOCLEARPWA:  Specifies whether the PWA  should  be
                 ____________________
                 cleared to zeros or not.
 
                 ID|NOID:   Specifies  that  a DC should be generated at the
                 ________
                 start of the program, containing the  program  block  name,
                 assembly  date,  and assembly time.  If the CPYRGHT keyword
                 is specified, it will also be DC'ed.
 
                 LOCTR|NOLOCTR:  Cause the  macros  to  generate  LOCTR  in-
                 ______________
                 structions  for  the  program, subroutines, and static data
                 areas to insure proper placement.  This option must be  se-
                 lected  if  the  program is using PSDs and SSDs or LONG and
                 LOADBASE.
 
                 LONG|NOLONG:  Indicates that  CALLSUBs  should  generate  a
                 ____________
                 BALR  (or equivalent) instead of a BAL to allow subroutines
                 to establish a base register.  This option is  required  if
                 the  program  has  any  subroutines that use LOADBASE.  The
                 LOCTR option is required if this option is specified.
 
                 MODE|NOMODE:  Enables generation of AMODE and RMODE cards.
                 ____________
 
                 PWA:  PWA can not be specified if ENVIRON=PLI is specified,
                 ____
                 but it is implied.  ENVIRON=PLI programs will  have  a  PWA
                 and can take advantage of all of a PWA's features.  The PWA
                 will  be  obtained  in the same manner as and have the same
                 format as a Dynamic Storage Area that is obtained by  PL/I.
                 The PWA and ENDPWA macros should be used to define the lim-
                 its of the PWA.
 
                 REGEQU|NOREGEQU:  Specifies that register equates are to be
                 ________________
                 generated.
 
 
                                                     Chapter 15. BLOCK    83
 
 
                 VL|NOVL:   Forces  all  generated  parameter  lists (PLIST,
                 ________
                 CALLSUB, CALLX) to default to VL unless overridden.
 
                 XA|NOXA:   Generates  support  for  linkage  using  XA  in-
                 ________
                 structions.  If neither XA or 370 is specified, 370 is  the
                 default.
 
                 370|NO370:   Generates  support  for  linkage using 370 in-
                 __________
                 structions.  If OPTIONS=XA is also  specified,  OPTIONS=370
                 causes generation of code which determines whether the pro-
                 gram  is  running  under  MVS/XA  or  not,  and  will cause
                 branches around XA-dependent instructions generated by  the
                 Structured Macros such as the amode switches.
 
                 If  a  type  of regular option is specified more than once,
                 the last occurrence (ie. REGEQU or NOREGEQU) is used.
 
                 Super options:  These are provided as combinations  of  the
                 Super options:
                 Super options:
                 Super options:
                 most popular options. If one or more options is not needed,
                 it  should  be  specified  as  desired  following the super
                 option's specification.
 
                 *STDPLI - selects options CLEARPWA, ID, REGEQU, MODE, NOXA,
                 NO370, VL, LOCTR, NOLONG.
 
           BASEREG= R11 | (R11[,reg[,...]])
           BASEREG= R11 | (R11[,reg[,...]])
           BASEREG= R11 | (R11[,reg[,...]])
           BASEREG= R11 | (R11[,reg[,...]])
                 Specifies the register or registers to be used for  program
                 addressability.    The  first  register must be R11 and the
                 other registers can not  be  R0,  R1,  R12,  R14,  or  R15.
                 BASEREG defaults to R11.
 
           CPYRGHT= notice
           CPYRGHT= notice
           CPYRGHT= notice
           CPYRGHT= notice
                 Specifies  a quoted string that will be DC'ed if the ID op-
                 tion is in effect.
 
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
         |       Defines the default place to build parameter  lists  gener-
         |       ated  within this block.  If this keyword is not specified,
                 the correct amount of storage  will  automatically  be  re-
                 served  and used in the PWA.  Tag defines the label for the
                                               ___
                 start of parameter list storage and num is a  self-defining
                                                     ___
                 term  that  represents the maximum number of parameter list
                 entries that the storage at tag will hold.   This  must  be
                                             ___
                 large  enough  to contain the largest parameter list in the
                 block.  If num is not specified, the tag must have a length
                 modifier that is a self-defining term.
 
           PWAREG= R13 | (R13,[reg[,...]])
           PWAREG= R13 | (R13,[reg[,...]])
           PWAREG= R13 | (R13,[reg[,...]])
           PWAREG= R13 | (R13,[reg[,...]])
                 Specifies the register or registers to be used for PWA  ad-
                 dressability.
 
           RMODE= 24 | ANY
           RMODE= 24 | ANY
           RMODE= 24 | ANY
           RMODE= 24 | ANY
                 Specifies the residency mode.
 
           84    Structured Macros Reference
 
 
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
           SUBOPTS= (option,...)
                 Can  be  used  to  specify a default set of options for all
                 subroutine  blocks  associated  with  this  program.    Any
                 options  specified  on subsequent subroutine blocks will be
                 in  addition to these options.  See "BLOCK TYPE=SUBROUTINE"
                 for a description of the valid subroutine block options.
 
           Errors:
           Errors:
           Errors:
           Errors:
                 Refer to ##PPPLI in "Appendix B. Internal Macros Error Mes-
                 sages" on page 123.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                     Chapter 15. BLOCK    85
 
 
           BLOCK TYPE=SUBROUTINE
           BLOCK TYPE=SUBROUTINE
           BLOCK TYPE=SUBROUTINE
           BLOCK TYPE=SUBROUTINE
           _____________________
 
           The  subroutine  block  contains  code  that  is  reached via the
           CALLSUB macro.  This block must be at block level zero.   Subrou-
           tine  blocks are meant for internal subroutines, not for a called
           program that follows standard OS linkage conventions.
 
           Keywords for subroutine blocks:
           _______________________________
 
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
           OPTIONS= option | (option[,option[,...]])
                 Regular options:  These are the  options  for  individually
                 Regular options:
                 Regular options:
                 Regular options:
                 controlling  each  of the BLOCK macro's functions.  The de-
                 fault value for each of these options is the negative  form
                 (NOSWA, NOCUSTOM, etc.).
 
                 CUSTOM|NOCUSTOM:  Specifies that the return instructions at
                 ________________
                 the  end  of  the subroutine block should not be generated.
                 This option should be used if you are going to  handle  all
                 of  the linkage details yourself.  If this option is speci-
                 fied, no other option or keywords on the  subroutine  block
                 can be specified.
 
                 LOADBASE|NOLOADBASE:   Indicates  that  a base register (or
                 ____________________
                 registers) should be loaded to establish separate  address-
                 ability  to  this subroutine.  The program base register is
                 left  intact  providing  addressability  to  the  program's
                 static data.
 
         |       (PARMS[,options...])|NOPARMS:   Indicates that this subrou-
                 _____________________________
         |       tine has an input parameter list and therefore register one
         |       should be preserved during subroutine linkage.  This option
         |       is also used to specify options for handling the input  pa-
         |       rameter list.  Any parameter option not specified will take
         |       on  its  default,  "NO"  state.    The  available parameter
         |       options are:
 
         |       COPY|NOCOPY:   Specifies  that  the  input  parameter  list
                 COPY|NOCOPY:
                 COPY|NOCOPY:
                 COPY|NOCOPY:
                 ____________
         |       should  be copied to the SWA.  An area large enough to con-
         |       tain the entire list is reserved and the  entire  parameter
         |       list  is  copied  here at the start of the subroutine.  Any
         |       missing parameters (including those left off the end  of  a
         |       VL parameter list) will contain an address of zero.  Use of
         |       this option requires the SWA option.
         |       PREFIX|NOPREFIX:   Specifies  that  the  tags listed in the
                 PREFIX|NOPREFIX:
                 PREFIX|NOPREFIX:
                 PREFIX|NOPREFIX:
                 ________________
         |       PARMS keyword for this block should be  prefixed  with  the
         |       &SPL  symbol before placing them within the SPL.  This give
         |       all the tags within the SPL a unique prefix so  there  will
         |       not  be  any  collisions with tags within other structures.
         |       If this option is specified, any references to tags  within
         |       the  SPL  from  the  subroutine  will  have to be coded as:
         |       &SPL.tag or &P.tag.
                      ___       ___
 
           86    Structured Macros Reference
 
 
         |       (USING,reg)|NOUSING:  Specifies that reg should be used  to
                 (USING,reg)|NOUSING:                 ___
                 (USING,reg)|NOUSING:
                 (USING,reg)|NOUSING:
                 ____________________
         |       establish  addressibility on the input parameter list.  The
         |       specified register is loaded with the contents of  register
         |       one  unless  the  COPY  option is also specified.   In this
         |       case,  reg will be loaded with the address of the input pa-
                        ___
         |       rameter list storage in the SWA.
         |       VL|NOVL:  Specifies that the input parameter list is a var-
                 VL|NOVL:
                 VL|NOVL:
                 VL|NOVL:
                 ________
         |       iable length (VL) parameter list.  For VL parameter  lists,
         |       the COPY option will loop through the parameters instead of
         |       doing  a block copy.  If the COPY option is being used, the
         |       high order bit in the last item  of  the  copied  parameter
         |       list will be cleared.
 
                 SAVEUSING|NOSAVEUSING:    Specifies  that  a  "PUSH  USING"
                 ______________________
                 should be done before the  subroutine  and  a  "POP  USING"
                 should be done after to save and restore the USING environ-
                 ment around the subroutine.  This isolates any changes made
                 to the USING environment in the subroutine from the rest of
                 the program.
 
                 SWA|NOSWA:  Specifies that this subroutine has an SWA.  The
                 __________
                 PWA  option  must be specified on the program block options
                 to use this option.  The SWA will be obtained  out  of  dy-
                 namic  storage  if the DYN option is being used, otherwise,
                 it is allocated within the program's PWA.  R0-R14 are auto-
                 matically saved and restored if this option  is  specified.
                 This option can not be used with the SAVE= keyword.
 
                 Super  options:   These are provided as combinations of the
                 Super  options:
                 Super  options:
                 Super  options:
                 most popular options. If one or more options is not needed,
                 it should be  specified  as  desired  following  the  super
                 option's specification.
 
                 *SWA - selects options SWA, SAVEUSING
 
                 *NOSUBOPTS    -   selects   options   NOSWA,   NOSAVEUSING,
         |       NOLOADBASE, NOCUSTOM, NOPARMS
 
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
           AMODE= 24 | 31 | ANY
                 Specifies the addressing mode  the  block  should  run  in.
                 Amode  switching  code  will be generated if required.  The
                 default is AMODE=ANY which specifies  that  the  subroutine
                 will run in the amode of its caller.
 
                 Restriction:  AMODE 24 or 31 must be specified on a subrou-
                 Restriction:
                 Restriction:
                 Restriction:
                 tine block if it contains inline blocks with AMODE 24 or 31
                 specified.
 
           BASEREG= reg|(reg,...)
           BASEREG= reg|(reg,...)
           BASEREG= reg|(reg,...)
           BASEREG= reg|(reg,...)
                 Defines  the  base  register(s) to be used to establish ad-
                 dressability to this subroutine.   If this keyword  is  not
                 specified,  register 10 is used.  The register(s) specified
                 with this keyword are only used when LOADBASE is in effect.
 
                                                     Chapter 15. BLOCK    87
 
 
         | PARMMAP=(dsect[,len])
           PARMMAP=(dsect[,len])
           PARMMAP=(dsect[,len])
           PARMMAP=(dsect[,len])
         |       Defines the Dsect to be used to  map  the  input  parameter
         |       list and its length.  This keyword can be used if the input
         |       parameter  list  is  too  complicated  to describe with the
         |       PARMS  keyword or if the input parameter list is a standard
         |       form described by an existing Dsect.  len is only  required
                                                       ___
         |       if  COPY  is specified with the PARMS option.  This keyword
         |       is mutually exclusive with the PARMS keyword.
 
         | PARMS=(tag[,tag[,...]])
           PARMS=(tag[,tag[,...]])
           PARMS=(tag[,tag[,...]])
           PARMS=(tag[,tag[,...]])
         |       Defines the tags used to  map  the  input  parameter  list.
         |       These  will  be  used  to generate the Subroutine Parameter
         |       List (SPL) Dsect or to map the input parameter list storage
         |       in the SWA (if parameter option COPY was specified).   This
         |       also  defines  the size of the input parameter list for the
         |       COPY option.  This keyword is mutually exclusive  with  the
         |       PARMMAP keyword.
 
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
           PL= tag|(tag,num)
         |       Defines  the  default place to build parameter lists gener-
         |       ated within this block.   Tag defines  the  label  for  the
                                           ___
                 start  of parameter list storage and num is a self-defining
                                                      ___
                 term that represents the maximum number of  parameter  list
                 entries  that  the  storage at tag will hold.  This must be
                                                ___
                 large enough to contain the largest parameter list  in  the
                 block.  If num is not specified, the tag must have a length
                 modifier that is a self-defining term.
 
           RECUR= number
           RECUR= number
           RECUR= number
           RECUR= number
                 Specifies  the  maximum number of times the subroutine will
                 be called recursively.   This is used  in  Dynamic  Storage
                 Management  to  calculate  the  amount  of space needed for
                 SWAs.  Number should be a self-defining term.
                        ______
 
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
           SAVE= (r1[,r2],address)
                 Requests that the register(s) named should be saved and re-
                 stored.   The address operand provides  the  address  of  a
                               _______
                 place to save the register(s). If more than one register is
                 specified,  a  "STM"  instruction  is generated: therefore,
                 specification of something like "R14,R12,address" is valid.
                 The SAVE keyword may be used on subroutine blocks  to  pre-
                 serve some or all registers without requiring a standard OS
                 save  area.    The  SAVE  operand  is  not valid on program
                 blocks, and should not be confused with OPTIONS=SAVE.
 
           SWAREG= R11|(R11,reg...)
           SWAREG= R11|(R11,reg...)
           SWAREG= R11|(R11,reg...)
           SWAREG= R11|(R11,reg...)
                 Specifies the register or registers to be used for SWA  ad-
                 dressability.   The register(s) specified with this keyword
                 are only used when DYN is in effect.
 
           Errors:
           Errors:
           Errors:
           Errors:
                 Refer to "Appendix B. Internal Macros  Error  Messages"  on
                 page 123 for macros that start with "##SP".
 
           88    Structured Macros Reference
 
 
                                                         CHAPTER 16. CALLSUB
                                                         CHAPTER 16. CALLSUB
                                                         CHAPTER 16. CALLSUB
                                                         CHAPTER 16. CALLSUB
                                                         ___________________
 
           Macro:    CALLSUB
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used to call an internal subroutine with linkage
           Abstract:
           Abstract:
           Abstract:
                     provided by the Structured Macros.   A  parameter  list
                     can be created for the call and its address loaded into
                     register  one,  or  register one can be loaded with the
                     address of a previously created list.
 
           Syntax:   CALLSUB name[,(parms)][,VL|NOVL][,PL=tag|(tag,num)]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Specifies the name of the internal subroutine  to
                     ____
                           be  called.    The  call is performed with a "BAL
                           R14,name" or equivalent instruction.  If the pro-
                               ____
                           gram block option LONG has been selected, a  "BAL
                           R14,R15"  is generated destroying the contents of
                           register 15.   The contents of  register  15  are
                           also destroyed if DYN is used.
 
                     parms A  list  of  the parameters to be included in the
                     _____
                           parameter list that the subroutine will be called
                           with.   A missing parameter  causes  zero  to  be
                           filled  in  for the parameter address.  An * will
                           cause the macro to skip over that parameter,  re-
                           serving  the  space in the parameter list but not
         |                 modifying the data there.  An * before a tag will
         |                 cause the macro to load the parameter  list  with
         |                 the contents of the storage referenced by the tag
         |                 instead of the address of the tag.  This provides
         |                 a form of indirect addressing.  Numeric and char-
                           acter  constants  can  be  coded and will be con-
                           verted  to  fullword   and   character   literals
                           respectively.    If parms is missing, the CALLSUB
                                               _____
                           macro will simply load register one with the  ad-
                           dress specified by PL=.
 
                     VL|NOVL VL specifies that this is a variable length pa-
                     _______
                           rameter  list  and  therefore the high bit of the
                           last address in the list should be  set  to  one.
                           NOVL  says  to not set the bit.  NOVL is normally
                           the default, but all of the super options  estab-
                           lish  VL  as  the  default  so that NOVL might be
                           needed in certain cases.
 
                     tag   Specifies the address of the  parameter  list  to
                     ___
                           used  for  the call to this subroutine.  Register
                           one will be loaded with the address of tag before
                                                                  ___
                           the subroutine is entered.  If a  parameter  list
                           is  being  created  for this subroutine, tag also
                                                                    ___
 
                                                   Chapter 16. CALLSUB    89
 
 
                           specifies where to build it.  If the PL=  keyword
                           is not specified, the parameter list will be cre-
                           ated in the default parameter list storage estab-
                           lished  by an enclosing BLOCK macro, or in PWA or
                           SWA storage if no other default was set up.
 
                     num   Specifies the maximum number  of  the  parameters
                     ___
                           that  the storage at tag can accommodate.  If tag
                                                ___                      ___
                           has a length attribute that  is  a  self-defining
                           term,  this  operand  is not necessary.   This is
                           used to insure that the specified parameter  list
                           will fit into the storage at tag.
                                                        ___
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Can not CALLSUB program block or subroutine in pre-
                         vious program block
 
 
 
 
 
 
 
 
 
 
 
 
 
           90    Structured Macros Reference
 
 
                                                           CHAPTER 17. CALLX
                                                           CHAPTER 17. CALLX
                                                           CHAPTER 17. CALLX
                                                           CHAPTER 17. CALLX
                                                           _________________
 
           Macro:    CALLX
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro used to call an external subroutine with standard
           Abstract:
           Abstract:
           Abstract:
                     OS  linkage.    A parameter list can be created for the
                     call and its address loaded into register one, or  reg-
                     ister  one  can  be loaded with the address of a previ-
                     ously created list.
 
           Syntax:   CALLX addr[,(parms)][,VL|NOVL][,PL=tag|(tag,num)]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     addr  Specifies the address of the external subroutine.
                     ____
                           This   address    can    be    of    the    form:
                           (R15)|=V(name)|tag.  If the tag form is used, tag
                           (R15)|=V(name)|tag          ___               ___
                           (R15)|=V(name)|tag
                           (R15)|=V(name)|tag
                           should  be  the  label  of the address of the ex-
                           ternal subroutine.  The call is performed with  a
                           BALR R14,R15 or equivalent instruction.
 
                     parms A  list  of  the parameters to be included in the
                     _____
                           parameter list that the subroutine will be called
                           with.   A missing parameter  causes  zero  to  be
                           filled  in  for the parameter address.  An * will
                           cause the macro to skip over that parameter,  re-
                           serving  the  space in the parameter list but not
         |                 modifying the data there.  An * before a tag will
         |                 cause the macro to load the parameter  list  with
         |                 the contents of the storage referenced by the tag
         |                 instead of the address of the tag.  This provides
         |                 a form of indirect addressing.  Numeric and char-
                           acter  constants  can  be  coded and will be con-
                           verted  to  fullword   and   character   literals
                           respectively.    If  parms  is missing, the CALLX
                                                _____
                           macro will simply load register one with the  ad-
                           dress specified by PL=.
 
                     VL|NOVL VL specifies that this is a variable length pa-
                     _______
                           rameter  list  and  therefore the high bit of the
                           last address in the list should be  set  to  one.
                           NOVL  says  to not set the bit.  NOVL is normally
                           the default, but all of the super options  estab-
                           lish  VL  as  the  default  so that NOVL might be
                           needed in certain cases.
 
                     tag   Specifies the address of the  parameter  list  to
                     ___
                           used  for  the call to this subroutine.  Register
                           one will be loaded with the address of tag before
                                                                  ___
                           the subroutine is entered.  If a  parameter  list
                           is  being  created  for this subroutine, tag also
                                                                    ___
                           specifies where to build it.  If the PL=  keyword
 
                                                     Chapter 17. CALLX    91
 
 
                           is not specified, the parameter list will be cre-
                           ated in the default parameter list storage estab-
                           lished  by an enclosing BLOCK macro, or in PWA or
                           SWA storage if no other default was set up.
 
                     num   Specifies  the  maximum number of parameters that
                     ___
                           the storage at tag can accommodate.  If tag has a
                                          ___                      ___
                           length attribute that is  a  self-defining  term,
                           this  operand  is not necessary.  This is used to
                           insure that the specified parameter list will fit
                           in the storage at tag.
                                             ___
 
           Errors:   None
           Errors:
           Errors:
           Errors:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           92    Structured Macros Reference
 
 
                                                            CHAPTER 18. CASE
                                                            CHAPTER 18. CASE
                                                            CHAPTER 18. CASE
                                                            CHAPTER 18. CASE
                                                            ________________
 
           Macro:    CASE
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured  macro  used to start the code for a partic-
           Abstract:
           Abstract:
           Abstract:
                     ular case within a case block.    This  macro  must  be
                     coded  between  a  CASEBLK and ENDCASE macro.  The CASE
                     macro is always associated with the innermost CASEBLK.
 
           Syntax:   CASE n[,n[,...]]|OTHER[,CASEBLK=name]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     n     Specifies the case number or numbers  whose  code
                     _
                           follows  the case statement.  OTHER indicates all
                           cases not associated with a particular case.  The
                           case number can not  be  larger  than  the  MULT=
                           value on the associated CASEBLK macro times 100.
 
                     name  Name specified on the associated CASEBLK macro.
                     ____
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         CASE <casenumber> already used
                         No operand was specified on CASE statement
                         OTHER has already been specified in this CASEBLK
                         CASE is not numeric
                         CASE number can not be larger then 'MULT' * 100
                         CASE number must be a multiple of 'MULT'
                         CASEBLK= does not match CASE name
                         CASE  macro  is  not  at same structural level as a
                         CASEBLK macro
 
 
 
 
 
 
 
 
                                                      Chapter 18. CASE    93
 
 
           CHAPTER 19. CASEBLK
           CHAPTER 19. CASEBLK
           CHAPTER 19. CASEBLK
           CHAPTER 19. CASEBLK
           ___________________
 
           Macro:    CASEBLK
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured  macro  used  to  start a case block.   Case
           Abstract:
           Abstract:
           Abstract:
                     blocks can be nested up to twenty deep.
 
           Syntax:   CASEBLK REG=reg[,WREG=wreg][,MULT=1|2|4|8][,NAME=name]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     reg   Specifies the register  that  contains  the  case
                     ___
                           number.
 
                     wreg  Specifies  the  register  that  CASEBLK  can  use
                     ____
                           internally as a work register for address  calcu-
                           lations.   If WREG= is not specified, the REG= is
                           used as a work register.  This destroys the  con-
                           tents  of  REG.    The work register can never be
                           register 0.
 
                     mult  This keyword specifies that all the case  numbers
                     ____
                           on  the  associated CASE macros are a multiple of
                           1, 2, 4, or 8.  1 is the default.
 
                     name  Specifies the name of the case block.
                     ____
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Invalid MULT= specified. Must be 1, 2, 4, or 8.
                         CASEBLK can not be nested more than 20 deep
                         REG= must be specified
 
 
 
 
 
 
 
 
           94    Structured Macros Reference
 
 
         |                                              CHAPTER 20. DEFUCOND
                                                        CHAPTER 20. DEFUCOND
                                                        CHAPTER 20. DEFUCOND
                                                        CHAPTER 20. DEFUCOND
                                                        ____________________
 
         | Macro:    DEFUCOND
           Macro:
           Macro:
           Macro:
 
         | Abstract: Structured macro used to define the name of a user con-
           Abstract:
           Abstract:
           Abstract:
         |           dition  and  identify  the  macro that will process it.
         |           With DEFUCOND the programmer can add special case  con-
         |           ditions to the list of standard conditions available in
         |           conditional  expressions.  For information on writing a
         |           user condition macro, see "User-Defined Conditions"  on
         |           page 7.
 
         | Syntax:   DEFUCOND NAME=name,MACRO=macro
           Syntax:
           Syntax:
           Syntax:
 
         | Operands:
           Operands:
           Operands:
           Operands:
 
         |           name  Name  of  the user condition being defined.  This
                     ____
         |                 name will be used in conditional  expressions  to
         |                 invoke this condition.
 
         |           macro Name  of  the  macro that will perform this user-
                     _____
         |                 defined conditional test.  This macro will be in-
         |                 voked  by  the  Structured  Macros   whenever   a
         |                 conditional  expression  is encountered that con-
         |                 tains the named condition.
 
         | Errors:
           Errors:
           Errors:
           Errors:
 
         |               NAME= must be specified
         |               MACRO= must be specified
 
 
 
 
 
 
 
 
                                                  Chapter 20. DEFUCOND    95
 
 
           CHAPTER 21. ELSE
           CHAPTER 21. ELSE
           CHAPTER 21. ELSE
           CHAPTER 21. ELSE
           ________________
 
           Macro:    ELSE
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to start the else code for an as-
           Abstract:
           Abstract:
           Abstract:
                     sociated  IF  or ELSEIF macro.  An ELSE macro is always
                     associated with the innermost IF structure.
 
           Syntax:   ELSE [IF=name]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Name of associated IF macro.
                     ____
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         IF nesting level is zero
                         ELSE already encountered for this IF
                         NAME= does not match corresponding IF
                         ELSE structural level is not the same as the corre-
                         sponding IF
 
 
 
 
 
 
 
 
 
 
 
           96    Structured Macros Reference
 
 
                                                          CHAPTER 22. ELSEIF
                                                          CHAPTER 22. ELSEIF
                                                          CHAPTER 22. ELSEIF
                                                          CHAPTER 22. ELSEIF
                                                          __________________
 
           Macro:    ELSEIF
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to start the else code for an as-
           Abstract:
           Abstract:
           Abstract:
                     sociated IF or ELSEIF macro.  An ELSEIF macro is always
                     associated  with the innermost IF structure.  An ELSEIF
                     is like an ELSE macro followed by an  IF  macro  except
                     that the IF nesting level stays the same.
 
           Syntax:   ELSEIF cond[,THEN][,IF=name]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     cond  Conditional  expression.  (See "Chapter 2. Condi-
                     ____
                           tional Statements" on page 4.)
 
                     name  Name on associated IF macro.
                     ____
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         ELSEIF must be contained in IF structure
                         ELSE for this IF precedes ELSEIF
                         IF= does not match corresponding IF
                         ELSEIF structural level is not the same  as  corre-
                         sponding IF
                         Refer  to  "Appendix  B. Internal Macros Error Mes-
                         sages" on page 123, for possible condition errors.
 
 
 
 
 
 
 
 
 
                                                    Chapter 22. ELSEIF    97
 
 
           CHAPTER 23. ENDBLK
           CHAPTER 23. ENDBLK
           CHAPTER 23. ENDBLK
           CHAPTER 23. ENDBLK
           __________________
 
           Macro:    ENDBLK
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured  macro used to end a block structure.  Refer
           Abstract:
           Abstract:
           Abstract:
                     to the description of the BLOCK macro for more informa-
                     tion.
 
           Syntax:   ENDBLK [BLOCK=name][,RC=rc][,R0=r0][,R1=r1]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Name on associated BLOCK macro.
                     ____
 
                     rc    Return code.  The return code can be specified as
                     __
                           a symbol or (Rn) where n is the number of a  reg-
                           ister.   The default for RC is (R15).  RC= is ig-
                           nored on the ENDBLK macro of a program block that
                           is using the PLI environment.
 
                     r0    Value to be returned  in  register  zero.    This
                     __
                           keyword requires the RTNR0 option to be in effect
                           and  is  only  valid  on the ENDBLK for a program
                           block and its error exits.   This  value  can  be
                           specified as a symbol or (Rn) where n is the num-
                           ber of a register.  The default for R0 is (R0).
 
                     r1    Value  to  be  returned  in  register one.   This
                     __
                           keyword requires the RTNR1 option to be in effect
                           and is only valid on the  ENDBLK  for  a  program
                           block  and  its  error exits.   This value can be
                           specified as a symbol or (Rn) where n is the num-
                           ber of a register.  The default for R1 is (R1).
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         <RC> invalid on RC=
                         Block nesting level is already zero
                         BLOCK= does not match current block
                         Structural nesting level does not  match  level  at
                         entry to corresponding block
                         Refer  to  "Appendix  B. Internal Macros Error Mes-
                         sages" on page  123  for  macros  that  start  with
                         "##EE", "##IE", "##PE" or "##SE" for other possible
                         errors.
 
 
 
           98    Structured Macros Reference
 
 
                                                         CHAPTER 24. ENDCASE
                                                         CHAPTER 24. ENDCASE
                                                         CHAPTER 24. ENDCASE
                                                         CHAPTER 24. ENDCASE
                                                         ___________________
 
           Macro:    ENDCASE
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to end a case block structure.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   ENDCASE [CASEBLK=name]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Name on associated CASEBLK macro.
                     ____
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         CASEBLK nesting level is zero
                         CASEBLK= does not match CASE name
                         Structural  nesting  level  of ENDCASE is different
                         than corresponding CASEBLK macro
 
 
 
 
 
 
 
 
 
 
 
 
                                                   Chapter 24. ENDCASE    99
 
 
           CHAPTER 25. ENDIF
           CHAPTER 25. ENDIF
           CHAPTER 25. ENDIF
           CHAPTER 25. ENDIF
           _________________
 
           Macro:    ENDIF
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to end an IF structure.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   ENDIF [IF=name]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Name on associated IF macro.
                     ____
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         IF nesting level is zero
                         IF= does not match corresponding IF
                         ENDIF  is  not  at  same structural level as corre-
                         sponding IF
 
 
 
 
 
 
 
 
 
 
 
 
           100    Structured Macros Reference
 
 
                                                         CHAPTER 26. ENDLOOP
                                                         CHAPTER 26. ENDLOOP
                                                         CHAPTER 26. ENDLOOP
                                                         CHAPTER 26. ENDLOOP
                                                         ___________________
 
           Macro:    ENDLOOP
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to end a LOOP structure.  See the
           Abstract:
           Abstract:
           Abstract:
                     LOOP macro for more information.
 
           Syntax:   ENDLOOP [LOOP=name,]
           Syntax:
           Syntax:
           Syntax:
                                 WHILE          |
                                 UNTIL,cond     |
                                 UNTIL,LEAVE    |
                                 BCT,reg        |
                                 BXH            |
                                 BXLE,reg,reg
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Name on associated LOOP macro.
                     ____
 
                     cond  Conditional  expression.  (See "Chapter 2. Condi-
                     ____
                           tional Statements" on page 4.)
 
                     reg   Register to be used on associated instruction.
                     ___
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Additional positional parameters can not be  speci-
                         fied on ENDLOOP <type>
                         Nesting level for loops is 0
                         LOOP= does not match corresponding LOOP
                         <type> does not match type on corresponding LOOP
                         Incorrect   number   of  parameters  specified  for
                         ENDLOOP <type>
                         LOOP type <type> is invalid
                         Incorrect number of parameters specified on ENDLOOP
                         UNTIL,LEAVE
                         ENDLOOP structural level is not  the  same  as  the
                         corresponding LOOP
                         Refer  to  "Appendix  B. Internal Macros Error Mes-
                         sages" on page 123, for possible condition errors.
 
 
 
 
 
                                                  Chapter 26. ENDLOOP    101
 
 
           CHAPTER 27. ENDPSD
           CHAPTER 27. ENDPSD
           CHAPTER 27. ENDPSD
           CHAPTER 27. ENDPSD
           __________________
 
           Macro:    ENDPSD
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro used to define the end of the Program Static Data
           Abstract:
           Abstract:
           Abstract:
                     (PSD).  The ENDPSD macro is used to close either a par-
                     tial  PSD  within  the program code, or the last PSD at
                     the end of the program.
 
           Syntax:   ENDPSD
           Syntax:
           Syntax:
           Syntax:
 
           Operands: None
           Operands:
           Operands:
           Operands:
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         ENDPSD does not correspond to a PSD
                         ENDPSD is not at the same nesting level as PSD
 
 
 
 
 
 
 
 
 
 
 
 
 
           102    Structured Macros Reference
 
 
                                                          CHAPTER 28. ENDPWA
                                                          CHAPTER 28. ENDPWA
                                                          CHAPTER 28. ENDPWA
                                                          CHAPTER 28. ENDPWA
                                                          __________________
 
           Macro:    ENDPWA
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to define the end of the Program Work Area
           Abstract:
           Abstract:
           Abstract:
                     (PWA) or to close a partial PWA.  The ENDPWA macro will
                     define the PWAPLLEN tag to establish the length of  the
                     PWA.    Also,  if  the DYN option is being used, ENDPWA
                     will use the ##ORGS macro  to  reserve  space  for  the
                     SWAs.   If option NORENT is in effect, a DS instruction
                     is generated to reserve storage in the  CSECT  for  the
                     PWA.
 
           Syntax:   ENDPWA
           Syntax:
           Syntax:
           Syntax:
 
           Operands: None
           Operands:
           Operands:
           Operands:
 
           Errors:   None
           Errors:
           Errors:
           Errors:
 
 
 
 
 
 
 
 
 
 
 
 
                                                   Chapter 28. ENDPWA    103
 
 
           CHAPTER 29. ENDSSD
           CHAPTER 29. ENDSSD
           CHAPTER 29. ENDSSD
           CHAPTER 29. ENDSSD
           __________________
 
           Macro:    ENDSSD
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to define the end of the Subroutine Static
           Abstract:
           Abstract:
           Abstract:
                     Data (SSD).  The ENDSSD macro is used to close either a
                     partial SSD within the subroutine code, or the last SSD
                     at the end of the subroutine.
 
           Syntax:   ENDSSD
           Syntax:
           Syntax:
           Syntax:
 
           Operands: None
           Operands:
           Operands:
           Operands:
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         ENDSSD does not correspond to a SSD
                         ENDSSD is not at the same nesting level as SSD
 
 
 
 
 
 
 
 
 
 
 
 
 
           104    Structured Macros Reference
 
 
                                                          CHAPTER 30. ENDSWA
                                                          CHAPTER 30. ENDSWA
                                                          CHAPTER 30. ENDSWA
                                                          CHAPTER 30. ENDSWA
                                                          __________________
 
           Macro:    ENDSWA
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to  define  the end of the Subroutine Work
           Abstract:
           Abstract:
           Abstract:
                     Area (SWA).  It is also used to end a partial SWA defi-
                     nition.  The ENDSWA macro will establish the length  of
                     the  SWA for Dynamic Storage calculations.  ENDSWA also
                     insures double word alignment for  anything  that  will
                     follow the SWA.
 
           Syntax:   ENDSWA
           Syntax:
           Syntax:
           Syntax:
 
           Operands: None
           Operands:
           Operands:
           Operands:
 
           Errors:   None
           Errors:
           Errors:
           Errors:
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                   Chapter 30. ENDSWA    105
 
 
           CHAPTER 31. ERREXIT
           CHAPTER 31. ERREXIT
           CHAPTER 31. ERREXIT
           CHAPTER 31. ERREXIT
           ___________________
 
           Macro:    ERREXIT
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to conditionally cause an errexit
           Abstract:
           Abstract:
           Abstract:
                     block to be executed.
 
           Syntax:   ERREXIT [cond][,CODE=code][,CODEREG=reg][,NAME=name]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Name of errexit block to execute.  If the name is
                     ____
                           omitted the unnamed error exit block for the pro-
                           gram is executed.
 
                     code  Symbol  representing  a value from 0 to 4095.  If
                     ____
                           specified, this code will be passed to the  error
                           exit block in the CODEREG= register.
 
                     reg   Register  used  for  passing error code.  The de-
                     ___
                           fault is R14.
 
                     cond  Conditional expression. (See "Chapter  2.  Condi-
                     ____
                           tional Statements" on page 4.)  If the expression
                           is  true,  the  error  exit is taken.   If an ex-
                           pression is not specified, the error exit is  al-
                           ways taken.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Refer  to  "Appendix  B. Internal Macros Error Mes-
                         sages" on page 123, for possible condition errors.
 
 
 
 
 
 
 
 
           106    Structured Macros Reference
 
 
                                                             CHAPTER 32. EXI
                                                             CHAPTER 32. EXI
                                                             CHAPTER 32. EXI
                                                             CHAPTER 32. EXI
                                                             _______________
 
           Macro:    EXI
           Macro:
           Macro:
           Macro:
 
           Abstract: This  is  the  EXecute Immediate macro.   It is used to
           Abstract:
           Abstract:
           Abstract:
                     generate an EX instruction and the  instruction  to  be
                     executed.  This allows the EXecuted statement to be de-
                     fined  at  the same time the EX instruction is defined,
                     minimizing confusion.  It also insures that  the  USING
                     environment  is the same as that of the EX instruction.
                     The EXecuted instruction will be generated in  the  PSD
                     for  the  program (or SSD for a subroutine) if the pro-
                     gram has selected option LOCTR.  Otherwise, it will  be
                     generated inline with a branch around it.
 
           Syntax:   EXI reg,(opcode,op1[,op2[,op3]])
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     reg   Specifies  the  register to be used in the EX in-
                     ___
                           struction.
 
                     opcode Defines the opcode to be used for  the  EXecuted
                     ______
                           instruction.
 
                     op1-3 Defines  the  operands  for the EXecuted instruc-
                     _____
                           tion.  There can be one, two, or three operands.
 
           Errors:   None
           Errors:
           Errors:
           Errors:
 
 
 
 
 
 
 
 
 
                                                      Chapter 32. EXI    107
 
 
           CHAPTER 33. FILL
           CHAPTER 33. FILL
           CHAPTER 33. FILL
           CHAPTER 33. FILL
           ________________
 
           Macro:    FILL
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro used to fill an area of storage with a character.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   FILL op1[,op2][,LENGTH=len|(len,type)]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     op1   Provides  the  starting address of the storage to
                     ___
                           be cleared.  May be given as an RX-type address.
 
                     op2   Provides a byte other  than  X'00'  to  propagate
                     ___
                           through the storage to be cleared.  May be speci-
                           fied  in  X'nn' or C'c' form (suitable for use by
                           MVI).  If not specified, X'00' is assumed.
 
                     len   Provides the length of the  storage  area  to  be
                     ___
                           cleared.    May  be  a  numeric value, a constant
                           value or a register specification.   The  default
                           is (L'op1,SHORT).
 
                     type  Specifies  the  type  of clearing operation to be
                     ____
                           performed: e.g.  "short", "medium" or "long".
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         FILL  operation  type  invalid:  Must  be   S)hort,
                         M)edium, or L)ong
                         Long form FILL requires R-Form length
                         Length for FILL required but not specified
                         Unable to parse FILL destination
 
           Caution:  If  a  tag  is  defined  in a macro, FILL does not have
           Caution:
           Caution:
           Caution:
                     L'tag resolved for it and gets an assembly error.    To
                       ___
                     correct this, you can code:
 
                        FILL  tag,X'00',LENGTH=L'tag
 
 
 
 
 
           108    Structured Macros Reference
 
 
                                                            CHAPTER 34. IBIT
                                                            CHAPTER 34. IBIT
                                                            CHAPTER 34. IBIT
                                                            CHAPTER 34. IBIT
                                                            ________________
 
           Macro:    IBIT
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro used to invert bit flags in a byte.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   IBIT [byte,]flag|(flag[,flag[,...]])
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     byte  Byte  that  contains  bit(s) to be inverted.   If
                     ____
                           this operand is omitted,  the name of the byte is
                           assumed to be the first five  characters  of  the
                           first flag name.
 
                     flag  Byte  mask  with a binary one in the bit position
                     ____
                           of the mask that corresponds to the bit to be in-
                           verted in the byte.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         No more than eight flags can be specified
                         IBIT macro can have no more than two operands
                         If byte is not specified,  flag  name  must  be  at
                         least six characters long
                         If byte is not specified, the first five characters
                         of all flags must match
 
 
 
 
 
 
 
 
 
                                                     Chapter 34. IBIT    109
 
 
           CHAPTER 35. IF
           CHAPTER 35. IF
           CHAPTER 35. IF
           CHAPTER 35. IF
           ______________
 
           Macro:    IF
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to start an IF structure.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   IF cond[,THEN][,NAME=name]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Name to be associated with IF structure.
                     ____
 
                     cond  Conditional  expression.  (See "Chapter 2. Condi-
                     ____
                           tional Statements" on page 4.)
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         IFs can only be 20 deep
                         Refer to "Appendix B. Internal  Macros  Error  Mes-
                         sages" on page 123, for possible condition errors.
 
 
 
 
 
 
 
 
 
 
 
 
           110    Structured Macros Reference
 
 
                                                            CHAPTER 36. LCBA
                                                            CHAPTER 36. LCBA
                                                            CHAPTER 36. LCBA
                                                            CHAPTER 36. LCBA
                                                            ________________
 
           Macro:    LCBA
           Macro:
           Macro:
           Macro:
 
           Abstract: This  macro loads the address of certain control blocks
           Abstract:
           Abstract:
           Abstract:
                     into a register.  No registers are changed  except  for
                     the register specified.  A zero condition is set if the
                     control  block can not be located.  It is not necessary
                     for the mapping macros  for  the  control  blocks  used
                     internally  by this macros to be included in the source
                     program.
 
           Syntax:   LCBA reg,cb
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     reg   This operand specifies the register to be loaded.
                     ___
                           The register must be specified as R1 through R15.
 
                     cb    One of the following control blocks can be speci-
                     __
                           fied:
 
                           ACEE      The  address  of   the   current   RACF
                           ACEE
                           ACEE
                           ACEE
                                     Accessor  Environment  Element  will be
                                     loaded.  This address will be the  con-
                                     tents  of the TCBSENV field of the cur-
                                     rent  TCB  if  non-zero  and   present;
                                     otherwise, the address will be the con-
                                     tents of the ASXBSENV field of the cur-
                                     rent ASXB.
 
                           ASCB      The  address  of  the  current  Address
                           ASCB
                           ASCB
                           ASCB
                                     Space Control  Block  will  be  loaded.
                                     This address is loaded from PSAAOLD.
 
                           ASXB      The  address  of  the  current  Address
                           ASXB
                           ASXB
                           ASXB
                                     Space Extension Block will  be  loaded.
                                     This address is loaded from ASCBASXB.
 
                           CVT       The  address of the Communications Vec-
                           CVT
                           CVT
                           CVT
                                     tor Table will be loaded.  This address
                                     is loaded from location decimal 16.
 
                           TCB       The address of the current Task Control
                           TCB
                           TCB
                           TCB
                                     Block will be loaded.  This address  is
                                     loaded from PSATOLD.
 
                           UJT       The  address of the User Job Table will
                           UJT
                           UJT
                           UJT
                                     be  loaded.    This  control  block  is
                                     Clemson dependent.  TCBUSER of the cur-
                                     rent  TCB  and  its  parents  TCBs  are
 
                                                     Chapter 36. LCBA    111
 
 
                                     searched to find  the  address  of  the
                                     UJT.
 
                           UVT       The  address  of the User Communication
                           UVT
                           UVT
                           UVT
                                     Vector Table will be loaded.  This con-
                                     trol block is Clemson dependent.   This
                                     address  is  loaded  from the three low
                                     order bytes of CVTUSER.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         <reg> is invalid.  Register must be R1-R15.
                         <cb> is not a supported control block.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           112    Structured Macros Reference
 
 
                                                           CHAPTER 37. LEAVE
                                                           CHAPTER 37. LEAVE
                                                           CHAPTER 37. LEAVE
                                                           CHAPTER 37. LEAVE
                                                           _________________
 
           Macro:    LEAVE
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured macro used to leave a structure.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   LEAVE struc=name[,cond]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     struc Type  of  structure  to leave.   Can be IF, LOOP,
                     _____
                           BLOCK, or CASEBLK.
 
                     name  Name of the structure to leave.    An  *  can  be
                     ____
                           coded  to indicate the current (innermost) struc-
                           ture of the specified type.
 
                     cond  Conditional expression. (See "Chapter  2.  Condi-
                     ____
                           tional Statements" on page 4.)  If the expression
                           is true, the structure is left.  If an expression
                           is  not specified, the structure is left uncondi-
                           tionally.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         SMWA= keyword needs  to  be  specified  on  program
                         block macro
                         Only one keyword can be specified on LEAVE
                         Nesting level for <structure> is zero
                         <name> is not an active <structure> name
                         One keyword must be specified on LEAVE
                         Refer  to  "Appendix  B. Internal Macros Error Mes-
                         sages" on page 123, for possible condition errors.
 
 
 
 
 
 
 
                                                    Chapter 37. LEAVE    113
 
 
           CHAPTER 38. LOOP
           CHAPTER 38. LOOP
           CHAPTER 38. LOOP
           CHAPTER 38. LOOP
           ________________
 
           Macro:    LOOP
           Macro:
           Macro:
           Macro:
 
           Abstract: Structured  macro  used to start a loop structure.  For
           Abstract:
           Abstract:
           Abstract:
                     LOOP WHILE loops, tests are done at the  start  of  the
                     loop.  For LOOP UNTIL loops, tests are done at the bot-
                     tom of the loop.  If the ENDLOOP specifies UNTIL,LEAVE,
                     the  loop  will continue until a LEAVE macro is used to
                     leave the loop.  BCT, BXH, and BXLE loop use the assem-
                     bler instruction by the same name.    BXH  instructions
                     are  generated  at the top of the loop and BXLE and BCT
                     instructions are generated at the bottom of the loop.
 
           Syntax:   LOOP [NAME=name,]
           Syntax:
           Syntax:
           Syntax:
                              WHILE,cond     |
                              UNTIL          |
                              BCT            |
                              BXH,reg,reg    |
                              BXLE
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     name  Name to be associated with loop structure.
                     ____
 
                     cond  Conditional expression. (See "Chapter  2.  Condi-
                     ____
                           tional Statements" on page 4.)
 
                     reg   Register to be used on associated instruction.
                     ___
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Additional  positional parameters can not be speci-
                         fied on LOOP <type>
                         LOOPs can only be nested 20 deep
                         Incorrect number of parameters specified  for  LOOP
                         BXH
                         LOOP type <type> is invalid
                         Refer  to  "Appendix  B. Internal Macros Error Mes-
                         sages" on page 123, for possible condition errors.
 
 
 
 
 
           114    Structured Macros Reference
 
 
                                               CHAPTER 39. L8, L16, L24, L32
                                               CHAPTER 39. L8, L16, L24, L32
                                               CHAPTER 39. L8, L16, L24, L32
                                               CHAPTER 39. L8, L16, L24, L32
                                               _____________________________
 
           Macro:    L8, L16, L24, L32
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used to load a register with one, two, three, or
           Abstract:
           Abstract:
           Abstract:
                     four bytes of data  from  non-aligned  storage.    This
                     macro  clears  the  register and issues the appropriate
                     ICM to accomplish this.
 
           Syntax:   Ln  reg,addr
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     n     Defines the size of the load operation  in  bits.
                     _
                           n  should  be  either  8, 16, 24 or 32 for single
                           _
                           byte, half word, three byte, or  full  word  load
                           respectively.
 
                     reg   Specifies  the register to load.  Warning:  Since
                     ___                                     Warning:  Since
                                                             Warning:  Since
                                                             Warning:  Since
                           this register is  cleared  before  the  load,  it
                           this register is  cleared  before  the  load,  it
                           this register is  cleared  before  the  load,  it
                           this register is  cleared  before  the  load,  it
                           should  not  be  used (directly or indirectly) to
                           should  not  be  used (directly or indirectly) to
                           should  not  be  used (directly or indirectly) to
                           should  not  be  used (directly or indirectly) to
                           specify addr.
                           specify ____.
                           specify     .
                           specify     .
 
                     addr  Specifies the address that register reg should be
                     ____                                      ___
                           loaded from.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Invalid number of operands on L<n> instruction
 
 
 
 
 
 
 
 
 
                                        Chapter 39. L8, L16, L24, L32    115
 
 
           CHAPTER 40. PLIST
           CHAPTER 40. PLIST
           CHAPTER 40. PLIST
           CHAPTER 40. PLIST
           _________________
 
           Macro:    PLIST
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro used to generate or modify a parameter list.  The
           Abstract:
           Abstract:
           Abstract:
                     parameter list can be created in default parameter list
                     storage or routed to a specific location.  Register one
                     is also loaded with the address of the completed list.
 
           Syntax:   PLIST
           Syntax:
           Syntax:
           Syntax:
                     [(parms)][,VL|NOVL][,PL=tag|(tag,num)][,DS=PWA|SWA]
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     parms A  list  of  the parameters to be included in the
                     _____
                           parameter list.  A missing parameter causes  zero
                           to  be filled in for the parameter address.  An *
                           will cause the macro to skip over that parameter,
                           reserving the space in the parameter list but not
         |                 modifying the data there.  An * before a tag will
         |                 cause the macro to load the parameter  list  with
         |                 the contents of the storage referenced by the tag
         |                 instead of the address of the tag.  This provides
         |                 a form of indirect addressing.  Numeric and char-
                           acter  constants  can  be  coded and will be con-
                           verted  to  fullword   and   character   literals
                           respectively.    If  parms  is missing, the PLIST
                                                _____
                           macro will simply load register one with the  ad-
                           dress specified by PL=.
 
                     VL|NOVL VL specifies that this is a variable length pa-
                     _______
                           rameter  list  and  therefore the high bit of the
                           last address in the list should be  set  to  one.
                           NOVL  says  to not set the bit.  NOVL is normally
                           the default, but all of the super options  estab-
                           lish  VL  as  the  default  so that NOVL might be
                           needed in certain cases.
 
                     tag   Specifies the address of the parameter list to be
                     ___
                           created or modified.  If the PL= keyword  is  not
                           specified,  the parameter list will be created in
                           the default parameter list storage established by
                           an enclosing BLOCK macro, or in PWA or SWA  stor-
                           age if no other default was set up.
 
                     num   Specifies  the  maximum  number of the parameters
                     ___
                           that the storage at tag can accommodate.  If  tag
                                               ___                       ___
                           has  a  length  attribute that is a self-defining
                           term, this operand is not  necessary.    This  is
                           used  to insure that the specified parameter list
                           will fit into the storage at tag.
                                                        ___
 
           116    Structured Macros Reference
 
 
                     DS=   Specifies that space for this list should be cre-
                     ___
                           ated in the PWA or SWA with a label of tag.   The
                                                                  ___
                           PL=  keyword is required when using this operand.
                           The size of parms is used to calculate  the  size
                                       _____
                           of  the storage created, unless num was specified
                                                           ___
                           on the PL= keyword.  In this case, the size spec-
                           ified by num is used.
                                    ___
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         First operand of  PL  keyword  is  required  if  DS
                         keyword is specified
                         <ds> is not valid on the DS keyword
                         The  PL  keyword must be specified on this macro or
                         on an enclosing BLOCK macro
                         <tag> is not large enough to contain parameter list
                         Invalid parameter <vl>
                         Too many parameters specified
                         Too many parameters on PL keyword
 
 
 
 
 
 
 
 
 
 
 
 
                                                    Chapter 40. PLIST    117
 
 
           CHAPTER 41. PSD
           CHAPTER 41. PSD
           CHAPTER 41. PSD
           CHAPTER 41. PSD
           _______________
 
           Macro:    PSD
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to  define  the  beginning  of the Program
           Abstract:
           Abstract:
           Abstract:
                     Static Data (PSD).  The PSD macro uses LOCTR to  locate
                     the static data after the instructions for the program.
                     The  PSD  should  be  defined just before the PWA for a
                     particular program block if there is one.
 
           Syntax:   PSD [TYPE=LAST|PARTIAL]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     TYPE= Defines whether this is the PSD  macro  that  de-
                     _____
                           fines  the main body of the PSD at the end of the
                           program (LAST), or a PSD  macro  that  defines  a
                           portion  of  the  PSD from within the body of the
                           program (PARTIAL).   If TYPE= is  not  specified,
                           TYPE=LAST is assumed.  The TYPE=PARTIAL option is
                           included  to  allow macros within the body of the
                           program to define fields in the PSD and have them
                           placed with the static data.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Nested PSD and SSD macros are not allowed
 
 
 
 
 
 
 
 
 
           118    Structured Macros Reference
 
 
                                                             CHAPTER 42. PWA
                                                             CHAPTER 42. PWA
                                                             CHAPTER 42. PWA
                                                             CHAPTER 42. PWA
                                                             _______________
 
           Macro:    PWA
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used to define the beginning of the Program Work
           Abstract:
           Abstract:
           Abstract:
                     Area (PWA).  The PWA macro will  automatically  reserve
                     space  for  a  standard OS save area, the SMWA, and any
                     parameter lists if it is appropriate  for  the  current
                     environment.    Also,  if the DYN option is being used,
                     PWA will set up  the  dynamic  storage  pointers  (NAB,
                     EOS-64).    The PWA should be defined as the last thing
                     associated with a particular program block.
 
           Syntax:   PWA [TYPE=LAST|PARTIAL]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     TYPE= Defines whether this is the PWA  macro  that  de-
                     _____
                           fines  the main body of the PWA at the end of the
                           program (LAST), or a PWA  macro  that  defines  a
                           portion  of  the  PWA from within the body of the
                           program (PARTIAL).   If TYPE= is  not  specified,
                           TYPE=LAST is assumed.  The TYPE=PARTIAL option is
                           included  to  allow macros within the body of the
                           program to define fields in the PWA and also gen-
                           erate the code to initialize them.  So far,  this
                           feature  is only used by the PLIST macro, but can
                           be used by any user macro.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         PWA option should be specified on the program block
                         macro
                         Invalid TYPE <type> specified on PWA macro
 
 
 
 
 
 
 
                                                      Chapter 42. PWA    119
 
 
           CHAPTER 43. RBIT
           CHAPTER 43. RBIT
           CHAPTER 43. RBIT
           CHAPTER 43. RBIT
           ________________
 
           Macro:    RBIT
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro used to reset bit flags in a byte.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   RBIT [byte,]flag|(flag[,flag[,...]])
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     byte  Byte  that  contains bit(s) to be reset.  If this
                     ____
                           operand is omitted,  the name of the byte is  as-
                           sumed  to  be  the  first  five characters of the
                           first flag name.
 
                     flag  Byte mask with a binary one in the  bit  position
                     ____
                           of the mask that corresponds to the bit to be re-
                           set in the byte.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         No more than eight flags can be specified
                         RBIT macro can have no more than two operands
                         If  byte  is  not  specified,  flag name must be at
                         least six characters long
                         If byte is not specified, the first five characters
                         of all flags must match
 
 
 
 
 
 
 
 
 
           120    Structured Macros Reference
 
 
                                                            CHAPTER 44. SBIT
                                                            CHAPTER 44. SBIT
                                                            CHAPTER 44. SBIT
                                                            CHAPTER 44. SBIT
                                                            ________________
 
           Macro:    SBIT
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro used to set bit flags in a byte.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   SBIT [byte,]flag|(flag[,flag[,...]])
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     byte  Byte that contains bit(s) to be set.  If this op-
                     ____
                           erand  is  omitted,   the name of the byte is as-
                           sumed to be the  first  five  characters  of  the
                           first flag name.
 
                     flag  Byte  mask  with a binary one in the bit position
                     ____
                           of the mask that corresponds to the bit to be set
                           in the byte.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         No more than eight flags can be specified
                         SBIT macro can have no more than two operands
                         If byte is not specified,  flag  name  must  be  at
                         least six characters long
                         If byte is not specified, the first five characters
                         of all flags must match
 
 
 
 
 
 
 
 
 
                                                     Chapter 44. SBIT    121
 
 
           CHAPTER 45. SMCTRL
           CHAPTER 45. SMCTRL
           CHAPTER 45. SMCTRL
           CHAPTER 45. SMCTRL
           __________________
 
           Macro:    SMCTRL
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to set internal flags to affect the opera-
           Abstract:
           Abstract:
           Abstract:
                     tion of the Structured Macros.
 
           Syntax:   SMCTRL FREEPWA=yesno
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     yesno Can be YES or NO to set an internal free PWA flag
                     _____
                           on or off.   When this flag  is  on,  the  ENDBLK
                           macro  for  the  program block will free the PWA.
                           This parameter in only valid if the  REUSPWA  op-
                           tion is in effect.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         The  FREEPWA  keyword  is only valid if the REUSPWA
                         option is in effect
                         FREEPWA=<value> is not valid
 
 
 
 
 
 
 
 
 
 
 
           122    Structured Macros Reference
 
 
         |                                                CHAPTER 46. SMLIST
                                                          CHAPTER 46. SMLIST
                                                          CHAPTER 46. SMLIST
                                                          CHAPTER 46. SMLIST
                                                          __________________
 
         | Macro:    SMLIST
           Macro:
           Macro:
           Macro:
 
         | Abstract: Macro  used  to  set  options  for the operation of the
           Abstract:
           Abstract:
           Abstract:
         |           Structured Macros Listing Program.  This macro is proc-
         |           essed by the listing program and not the assembler.
 
         | Syntax:   SMLIST CONVERT=yesno
           Syntax:
           Syntax:
           Syntax:
 
         | Operands:
           Operands:
           Operands:
           Operands:
 
         |           yesno Can be YES or NO to begin or  end  the  automatic
                     _____
         |                 conversion  of  assembler  source  to upper case.
         |                 All non-comment lines will be converted to  upper
         |                 case  with  the  exception of text between double
         |                 quotes.  This text will  remain  unconverted  and
         |                 the  double quotes (") will be replaced with sin-
         |                 gle quotes (') before passing the  source  on  to
         |                 the assembler.
 
         | Errors:
           Errors:
           Errors:
           Errors:
 
         |               INVALID SMLIST STATEMENT
 
 
 
 
 
 
 
 
 
 
                                                   Chapter 46. SMLIST    123
 
 
         | CHAPTER 47. SMSYMS
           CHAPTER 47. SMSYMS
           CHAPTER 47. SMSYMS
           CHAPTER 47. SMSYMS
           __________________
 
         | Macro:    SMSYMS
           Macro:
           Macro:
           Macro:
 
         | Abstract: This  is not a macro, but is a copy member that must be
           Abstract:
           Abstract:
           Abstract:
         |           included at the beginning of any program that uses  the
         |           structure  location  symbols  described in "Chapter 11.
         |           Location and Scope of Data Structures" on page 43.
 
         | Syntax:   COPY SMSYMS
           Syntax:
           Syntax:
           Syntax:
 
         | Operands: None.
           Operands:
           Operands:
           Operands:
 
         | Errors:   None.
           Errors:
           Errors:
           Errors:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           124    Structured Macros Reference
 
 
                                                             CHAPTER 48. SSD
                                                             CHAPTER 48. SSD
                                                             CHAPTER 48. SSD
                                                             CHAPTER 48. SSD
                                                             _______________
 
           Macro:    SSD
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to  define the beginning of the Subroutine
           Abstract:
           Abstract:
           Abstract:
                     Static Data (SSD).  The SSD macro uses LOCTR to  locate
                     the  static  data.   If the subroutine has selected the
                     LOADBASE option, the static data is placed  immediately
                     after the subroutine code in the object module.  If the
                     subroutine is not using LOADBASE, the subroutine static
                     data  is  placed with the program static data.  The SSD
                     should be defined just before the SWA for a  particular
                     subroutine block.
 
           Syntax:   SSD [TYPE=LAST|PARTIAL]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     TYPE= Defines  whether  this  is the SSD macro that de-
                     _____
                           fines the main body of the SSD at the end of  the
                           subroutine (LAST), or an SSD macro that defines a
                           portion  of  the  SSD from within the body of the
                           subroutine (PARTIAL).  If TYPE= is not specified,
                           TYPE=LAST is assumed.  The TYPE=PARTIAL option is
                           included to allow macros within the body  of  the
                           subroutine  to  define fields in the SSD and have
                           them placed with the static data.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Nested PSD and SSD macros are not allowed
 
 
 
 
 
 
 
 
                                                      Chapter 48. SSD    125
 
 
           CHAPTER 49. STRSA
           CHAPTER 49. STRSA
           CHAPTER 49. STRSA
           CHAPTER 49. STRSA
           _________________
 
           Macro:    STRSA
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to store a register's value in the Subrou-
           Abstract:
           Abstract:
           Abstract:
                     tine Work Area (SWA) save area.  If an internal subrou-
                     tine  contains  an  SWA,  registers  are  automatically
                     restored  when  the  subroutine  is  exited.    If  the
                     internal subroutine needs to pass back the value  of  a
                     register,  it  can  use this macro to save a register's
                     current value in the subroutine save area, so  that  it
                     will  not  be  restored  to the original value when the
                     subroutine returns.
 
           Syntax:   STRSA reg
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     reg   Defines the register that should be saved.    Reg
                     ___                                                 ___
                           should be one of the registers R0-R14.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         Invalid register specified - <reg>
                         This  macro  can  only be used in subroutine blocks
                         with the SWA option specified
 
 
 
 
 
 
 
 
 
 
           126    Structured Macros Reference
 
 
                                                             CHAPTER 50. SWA
                                                             CHAPTER 50. SWA
                                                             CHAPTER 50. SWA
                                                             CHAPTER 50. SWA
                                                             _______________
 
           Macro:    SWA
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to  define the beginning of the Subroutine
           Abstract:
           Abstract:
           Abstract:
                     Work Area (SWA).  The SWA macro will automatically  re-
                     serve space for a subroutine save area, a SMWA, any pa-
                     rameter  lists  used by the subroutine, and the Dynamic
                     Storage Management pointers if needed.  The SWA  for  a
                     subroutine  should  be  defined  immediately  after the
                     ENDBLK for that subroutine.  The SWA macro insures that
                     any fields specified within the  SWA  will  be  aligned
                     properly.
 
           Syntax:   SWA [TYPE=LAST|PARTIAL]
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     TYPE= Defines  whether  this  is the SWA macro that de-
                     _____
                           fines the main body of the SWA at the end of  the
                           subroutine (LAST), or an SWA macro that defines a
                           portion  of  the  SWA from within the body of the
                           subroutine (PARTIAL).  If TYPE= is not specified,
                           TYPE=LAST is assumed.  The TYPE=PARTIAL option is
                           included to allow macros within the body  of  the
                           subroutine  to  define fields in the SWA and also
                           generate the code to initialize them.    So  far,
                           this feature is only used by the PLIST macro, but
                           can be used by any user macro.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         SWA  option  was  not  specified  on the subroutine
                         block macro or SWA already defined
                         Invalid TYPE <type> specified on SWA macro
 
 
 
 
 
 
 
                                                      Chapter 50. SWA    127
 
 
           CHAPTER 51. TBIT
           CHAPTER 51. TBIT
           CHAPTER 51. TBIT
           CHAPTER 51. TBIT
           ________________
 
           Macro:    TBIT
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro used to test bit flags in a byte.
           Abstract:
           Abstract:
           Abstract:
 
           Syntax:   TBIT [byte,]flag|(flag[,flag[,...]])
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     byte  Byte  that contains bit(s) to be tested.  If this
                     ____
                           operand is omitted,  the name of the byte is  as-
                           sumed  to  be  the  first  five characters of the
                           first flag name.
 
                     flag  Byte mask with a binary one in the  bit  position
                     ____
                           of  the  mask  that  corresponds to the bit to be
                           tested in the byte.
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         No more than eight flags can be specified
                         TBIT macro can have no more than two operands
                         If byte is not specified,  flag  name  must  be  at
                         least six characters long
                         If byte is not specified, the first five characters
                         of all flags must match
                         This expression requires the Level H assembler
 
 
 
 
 
 
 
 
 
           128    Structured Macros Reference
 
 
                                                            CHAPTER 52. TREG
                                                            CHAPTER 52. TREG
                                                            CHAPTER 52. TREG
                                                            CHAPTER 52. TREG
                                                            ________________
 
           Macro:    TREG
           Macro:
           Macro:
           Macro:
 
           Abstract: Macro  used  to  test a register for zero, positive, or
           Abstract:
           Abstract:
           Abstract:
                     negative.
 
           Syntax:   TREG reg
           Syntax:
           Syntax:
           Syntax:
 
           Operands:
           Operands:
           Operands:
           Operands:
 
                     reg   Register to be tested.
                     ___
 
           Errors:
           Errors:
           Errors:
           Errors:
 
                         TREG macro can have one and only one operand
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                     Chapter 52. TREG    129
 
 
         | CHAPTER 53. ##COND
           CHAPTER 53. ##COND
           CHAPTER 53. ##COND
           CHAPTER 53. ##COND
           __________________
 
         | Macro:    ##COND
           Macro:
           Macro:
           Macro:
 
         | Abstract: This is an "internal" macro for use within other macros
           Abstract:
           Abstract:
           Abstract:
         |           and  not  in  open code.   The ##COND macro will test a
         |           conditional expression and branch  to  the  appropriate
         |           success  or  failure tags.   This macro is intended for
         |           use in user condition macros.  For information on writ-
         |           ing a user condition macro,  see  "User-Defined  Condi-
         |           tions" on page 7.
 
         | Syntax:   ##COND expr,S=stag,F=ftag,L=logic
           Syntax:
           Syntax:
           Syntax:
 
         | Operands:
           Operands:
           Operands:
           Operands:
 
         |           expr  The conditional expression to be evaluated.  This
                     ____
         |                 can  be  any valid conditional expression and can
         |                 contain previously defined user conditions.
 
         |           stag  The name of the tag that marks the  beginning  of
                     ____
         |                 the code to be executed if the condition is true.
 
         |           ftag  The  name  of the tag that marks the beginning of
                     ____
         |                 the code to  be  executed  if  the  condition  is
         |                 false.
 
         |           logic Either P for positive logic (branch to success if
                     _____
         |                 condition  is  true)  or  N  for  negative  logic
         |                 (branch to failure, skipping over success code if
         |                 condition is false).  These last  three  operands
         |                 are  usually  passed  unchanged from the operands
         |                 passed in on the user condition macro that is in-
         |                 voking ##COND.
 
         | Errors:
           Errors:
           Errors:
           Errors:
 
         |               Invalid option <cond> for #TEST condition
         |               Invalid or missing condition expression
         |               Invalid number of parms for <op>
         |               This expression requires the Level H assembler
         |               Invalid condition <cond>
         |               No more than 51 positional parameters can be speci-
         |               fied in a condition
 
 
 
 
           130    Structured Macros Reference
 
 
                            APPENDIX A. CATALOGUED ASM PROCEDURES AT CLEMSON
                            APPENDIX A. CATALOGUED ASM PROCEDURES AT CLEMSON
                            APPENDIX A. CATALOGUED ASM PROCEDURES AT CLEMSON
                            APPENDIX A. CATALOGUED ASM PROCEDURES AT CLEMSON
                            ________________________________________________
 
           There  are  four  catalogued procedures available at Clemson that
           will provide access to the Structured  Macros:  these  are  ASMP,
           ASMPC,  ASMPCL, and ASMPCLG.  These procs will perform a preproc-
           ess; preprocess and assemble; preprocess, assemble, and link;  or
           preprocess, assemble, link, and go respectively.
 
           The  Structured Macro preprocessor (MSC0150$) does not change the
           source input, but analyzes the use of the Structured  Macros  and
           produces  a nesting level report.  Once you have had some time to
           get used to it, the nesting level  report  becomes  very  useful.
           Use //P.SYSIN to provide it with your assembler source.
 
           The assembly step executes the Level H Assembler with the options
           XREF(SHORT),  TERM  and  OBJECT.  A //SYSTERM DD statement is in-
           cluded in the procs, since it appears to be one of the more popu-
           lar assembler  options.  //SYSLIB  concatenates  SYS1.MACLIB  and
           SYS2.STRUC.MACLIB.    Note  that SYS2.MACLIB is not included, and
           must be included manually if desired.
 
           The link-edit step follows the  same  conventions  as  the  other
           Clemson  compile-and-link  procs, in that link-edit control cards
           may be provided via //L.SYSIN. Parms LIST and MAP are provided by
           the proc.
 
           The three procs have the following keyword parameters available:
 
            Keyword:    In Procs:           Default:    Used For:
 
            SYSOUT      All                    A        Listing SYSOUT class
            OBJECT      All but ASMP         DUMMY      ASM SYSPUNCH
            COPT        All but ASMP         <null>     ASM parameters
            LOPT        ASMPCL, ASMPCLG      <null>     Linkedit parameters
            PDS         ASMPCL               <null>     Loadlib          for
           L.SYSLMOD
            NAME        ASMPCL               <null>     Load module name
 
 
 
 
 
 
                     Appendix A. Catalogued ASM Procedures At Clemson    131
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           132    Structured Macros Reference
 
 
                                  APPENDIX B. INTERNAL MACROS ERROR MESSAGES
                                  APPENDIX B. INTERNAL MACROS ERROR MESSAGES
                                  APPENDIX B. INTERNAL MACROS ERROR MESSAGES
                                  APPENDIX B. INTERNAL MACROS ERROR MESSAGES
                                  __________________________________________
 
           The following is a list of error messages that can be produced by
           internal  macros  used  by the Structured Macros.   The character
           preceding the message indicates:  *-informational, 4-warning  and
           8-error.   Words enclosed in angle brackets are replaced with the
           appropriate text when the message is issued.
 
           ##COND
           ##COND
           ##COND
           ##COND
 
                         8-Invalid option <cond> for #TEST condition
                         8-Invalid or missing condition expression
                         8-Invalid number of parms for <op>
                         8-This expression requires the Level H assembler
                         8-Invalid condition <cond>
                         8-Invalid T=
                         8-No more than  51  positional  parameters  can  be
                         specified in a condition
 
           ##EESTD
           ##EESTD
           ##EESTD
           ##EESTD
 
                         8-R0  keyword  can not be specified if option RTNR0
                         is not in effect
                         8-R1 keyword can not be specified if  option  RTNR1
                         is not in effect
                         8-SMWA=  keyword  needs  to be specified on program
                         block
 
           ##EPSTD
           ##EPSTD
           ##EPSTD
           ##EPSTD
 
                         8-AMODE=<amode> is invalid on <type> block, keyword
                         ignored
                         *-AMODE ignored unless XA option specified for pro-
                         gram block
                         8-Invalid number of parameters in SAVE= keyword
 
           ##IESTD
           ##IESTD
           ##IESTD
           ##IESTD
 
                         8-SMWA= keyword needs to be  specified  on  program
                         block macro
 
           ##IGMSG
           ##IGMSG
           ##IGMSG
           ##IGMSG
 
                         4-<kwdname>=<kwd> ignored
 
           ##IPSTD
           ##IPSTD
           ##IPSTD
           ##IPSTD
 
                         8-AMODE=<amode> is invalid on <type> block, keyword
                         ignored
                         *-AMODE ignored unless XA option specified for pro-
                         gram block
 
                           Appendix B. Internal Macros Error Messages    133
 
 
                         8-AMODE  24  or  31 must be specified on containing
                         subroutine
                         8-Invalid number of parameters in SAVE= keyword
 
           ##L
           ##L
           ##L
           ##L
 
                         8-Decimal  self-defining terms are the only type of
                         self-defining terms allowed
                         8-WREG is required if R0,*ADDR is used
 
           ##LA
           ##LA
           ##LA
           ##LA
 
                         8-Decimal self-defining terms are the only type  of
                         self-defining terms allowed
 
           ##MREG
           ##MREG
           ##MREG
           ##MREG
 
                         8-Register specification <reg> is invalid
                         8-Register <reg> specified multiple times
                         8-Register <reg> was not used - internal error
                         8-Invalid type of <type> on ##MREG macro - internal
                         error
 
           ##ORGS
           ##ORGS
           ##ORGS
           ##ORGS
 
                         *-For subroutine <subname> when called from subrou-
                         tine <subname>
 
           ##PEDC
           ##PEDC
           ##PEDC
           ##PEDC
 
                         8-R0= invalid if option RTNR0 not specified
                         8-R1= invalid if option RTNR1 not specified
 
           ##PEOS
           ##PEOS
           ##PEOS
           ##PEOS
 
                         8-R0  keyword  can not be specified if option RTNR0
                         is not in effect
                         8-R1 keyword can not be specified if  option  RTNR1
                         is not in effect
 
           ##PPDC
           ##PPDC
           ##PPDC
           ##PPDC
 
                         8-Invalid option <opt>
                         4-RMODE and AMODE ignored if MODE option not speci-
                         fied
                         4-RMODE  and  AMODE ignored if XA option not speci-
                         fied
                         *-SYSTEM-MODE GETSTG generated
                         *-#GETSTK generated: #GETSTK =(value)
                         8-#START option required if SYSTEM option specified
                         8-#RETURN-related operands not allowed with  SYSTEM
                         option
                         8-#START/#RTN options not allowed with NOSYSTEM op-
                         tion
 
           134    Structured Macros Reference
 
 
                         8-#RETURN option not allowed with SYSTEM option
                         8-EP option not allowed with NOSYSTEM option
                         8-AMODE and RMODE requested are inconsistent
                         8-GETSTK option requires SYSTEM option
                         8-GETSTK option requires PWA option
                         8-MPMODE option requires SYSTEM and #START options
 
           ##PPOS
           ##PPOS
           ##PPOS
           ##PPOS
 
                         8-Invalid option &OPT
                         4-Option DYN assumed because of option MAIN
                         4-Option PWA assumed because of option DYN
                         4-DYNSIZE can not be specified without option DYN
                         8-Name required on program block macro
                         4-RMODE and AMODE ignored if MODE option not speci-
                         fied
                         4-RMODE  and  AMODE ignored if XA option not speci-
                         fied
                         4-SVAREA= ignored when PWA option specified
                         8-First PWAREG must be R13
                         *-SAVEAREA option assumed because of PWA option
                         4-SVAREA= ignored when  RENT  and  SAVEAREA  option
                         specified
                         *-SAVEAREA   option   assumed  because  of  SVAREA=
                         keyword
                         *-Assuming register 1 is saved
                         8-Option REUSPWA requires the PWA,  RENT  and  SAVE
                         options
                         4-Option  FNCODE is ignored when the REUSPWA option
                         is not in effect
                         8-Option ESV requires the PWA and RENT options
                         8-Option CLRDEBUG requires the ESV option
 
           ##PPPLI
           ##PPPLI
           ##PPPLI
           ##PPPLI
 
                         8-Invalid option <opt>
                         8-With ENVIRON=PLI, first BASEREG must be R11
                         8-With ENVIRON=PLI, first PWAREG must be R13
                         8-Name required on program block macro
                         4-RMODE and AMODE ignored if MODE option not speci-
                         fied
                         4-RMODE and AMODE ignored if XA option  not  speci-
                         fied
 
           ##PRMOPT
           ##PRMOPT
           ##PRMOPT
           ##PRMOPT
 
                         8-USING option requires two parameters
                         8-COPYERROR option requires two or three parameters
                         8-<opt> is an invalid suboption of the PARMS option
                         8-PARMS  and PARMMAP keywords require the PARMS op-
                         tion
                         8-PARMS and PARMMAP keywords are mutually exclusive
                         8-Too many parameters specified on PARMMAP keyword
 
                           Appendix B. Internal Macros Error Messages    135
 
 
                         8-Second parameter required on PARMMAP  keyword  if
                         COPY PARMS option is specified
                         8-<type> is invalid
                         8-##PRMOPT does not support <opt> option
                         8-<process> is an invalid value for PROCESS keyword
                         8-The first parameter in PARM options must be PARMS
 
           ##SPSTD
           ##SPSTD
           ##SPSTD
           ##SPSTD
 
                         8-SAVE= invalid if SWA option specified
                         8-SWA option requires PWA option on program block
                         8-SWAREG= can not be specified unless OPTION=SWA is
                         specified
                         8-AMODE= invalid for custom subroutine blocks
                         8-SAVE= invalid for custom subroutine blocks
                         8-CUSTOM must be specified alone
                         8-AMODE=<amode>  is  invalid  on  subroutine block,
                         keyword ignored
                         *-LOADBASE assumed because BASEREG= specified
                         8-BLOCK TYPE=SUBROUTINE requires NAME=
                         8-LOADBASE option requires LONG option  on  program
                         block
                         8-RECUR  keyword  requires  DYN  option  on program
                         block
                         8-R11 must be the first register specified  on  the
                         SWAREG= keyword
                         *-AMODE  ignored unless XA option specified on pro-
                         gram block
                         8-Invalid number of parameters in SAVE= keyword
 
           ##ST
           ##ST
           ##ST
           ##ST
 
                         8-*ADDR form of second operand requires WREG=
 
           ##SUBOPT
           ##SUBOPT
           ##SUBOPT
           ##SUBOPT
 
                         8-<opt> is an invalid option for subroutine block
 
           ##SWREG
           ##SWREG
           ##SWREG
           ##SWREG
 
                         8-SMWA= keyword is required on  the  program  block
                         macro to support this function
 
           ##UCOND
           ##UCOND
           ##UCOND
           ##UCOND
 
                         8-Invalid or undefined user condition name: <cond>
 
           ##UPSTD
           ##UPSTD
           ##UPSTD
           ##UPSTD
 
                         8-SWA  option  was  not specified on the subroutine
                         block macro or SWA already defined
                         8-Invalid type <type> specified on SWA macro
 
           ##WESTD
           ##WESTD
           ##WESTD
           ##WESTD
 
           136    Structured Macros Reference
 
 
                         *-<subname> first from index is <num>
                         *-<num>    CALLSUB    from    <subname>(<num>)   to
                         <subname>(<num>)
 
           ##WPDC
           ##WPDC
           ##WPDC
           ##WPDC
 
                         8-PWA option should be  specified  on  the  program
                         block macro
                         8-Invalid type <type> specified on PWA macro
 
           ##WPOS
           ##WPOS
           ##WPOS
           ##WPOS
 
                         8-PWA  option  should  be  specified on the program
                         block macro
                         8-Invalid type <type> specified on PWA macro
 
           ##WPPLI
           ##WPPLI
           ##WPPLI
           ##WPPLI
 
                         8-PWA option should be  specified  on  the  program
                         block macro
                         8-Invalid type <type> specified on PWA macro
 
 
 
 
 
 
 
 
 
 
 
 
                           Appendix B. Internal Macros Error Messages    137
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           138    Structured Macros Reference
 
 
                                        APPENDIX C. WORK AREA STORAGE LAYOUT
                                        APPENDIX C. WORK AREA STORAGE LAYOUT
                                        APPENDIX C. WORK AREA STORAGE LAYOUT
                                        APPENDIX C. WORK AREA STORAGE LAYOUT
                                        ____________________________________
 
           If  you are using PWAs and SWAs (with or without the DYN option),
           the Structured Macros automatically allocate many fields for you.
           Since the macros also manage these fields,  you  rarely  need  to
           worry  about them.   However, there may be some cases in which it
           would be useful to know the layout of PWA and SWA storage.   That
           is what this appendix describes.
 
           WORK AREA LAYOUT WITH THE DYN OPTION
           WORK AREA LAYOUT WITH THE DYN OPTION
           WORK AREA LAYOUT WITH THE DYN OPTION
           WORK AREA LAYOUT WITH THE DYN OPTION
           ____________________________________
 
           The  DYN  option  is  only  available  for  program  blocks  with
           ENVIRON=OS in effect.
 
           As described in "Chapter 5. Program and Subroutine Work Areas" on
           page 20, the DYN option acquires a single large chunk of  storage
           at the beginning of the program and partitions it as it is needed
           for  internal subroutine SWAs.  The layout of the dynamic storage
           is shown below.
 
 
 
              | PWA  | SWA  | SWA  | - - | PWA  | SWA  | - -  | Free   | 16 Word
 
 
                                                              |        |
                                                             NAB     EOS-64
 
           The first thing in dynamic storage is the main program's PWA fol-
           lowed by any SWAs that happen to be active for that program.   If
           the  main  program  invokes  an  external  subroutine  that  uses
           *NOMAIN, another PWA will be generated for that program  followed
           by its SWAs.  At the end is free storage waiting to be allocated.
           The  current  NAB (Next Available Byte) will contain a pointer to
           the beginning of free storage.  See below to see how to find  the
           current NAB.
 
           While EOS (End Of Storage) actually marks the end of the block of
           storage  that was GETMAINed, a pointer is kept to EOS-64 instead.
           This provides a 16 word (64 byte) "safety zone" for  use  by  the
           internal  subroutine  linkage routines.  These extra bytes insure
           that there will always be at least 16 words left in dynamic stor-
           age when a subroutine is entered.   Because of this  buffer,  the
           subroutine  can save its registers before it has to calculate re-
           maining space and update the pointers.
 
           Within dynamic storage, all PWAs and SWAs start on a double  word
           boundary.  This is to insure that any fields defined within their
           DSECTs as double word will actually have that alignment.
 
 
                                 Appendix C. Work Area Storage Layout    139
 
 
           The  diagram  above shows that dynamic storage is divided up into
           PWAs and SWAs.  The format of a single PWA is shown below.
 
 
 
              | Save Area | EOS-64 | Reserved | NAB | Partial | SMWA | PL | User
              |    (18F)  |        |          |     |  PWA    | (1)  | (2)| Defi
 
 
              |
             R13
 
           Note:
           Note:
           Note:
           Note:
            (1) The SMWA is variable in length.
            (2) The PL storage will be as large as required.
 
           First  is  a 18 word, standard OS save area for this program.  It
           is used anytime the program calls an external subroutine.    This
           could  be  either an IBM service or a separately compiled module.
           By putting the save area at the beginning of the PWA and pointing
           register 13 at it, we can use this register to keep up with  both
           the current save area and the beginning of PWA storage.
 
           After  the  save area is a pointer to EOS-64.  This field defines
           the end of the block of dynamic storage that this PWA resides in.
           This field is filled in even for  a  *NOMAIN  PWA.    The  EOS-64
           pointer  is  used in subroutine linkages to determine if there is
           enough storage left for an SWA.   Following  this  pointer  is  a
           fullword reserved for future use.
 
           Next  comes the NAB (Next Available Byte) for this PWA.  This NAB
           points to the first byte after this PWA.  If there are no  active
           SWAs  following this PWA, the NAB will point to the start of free
           storage.  Otherwise, it will point to the first SWA following the
           PWA.
 
           Following the NAB are any fields  that  were  defined  by  a  PWA
           TYPE=PARTIAL  macro.   These fields may have been defined by user
           macros, or by the DS=PWA keyword  on  the  PLIST  macro.    These
           fields  may be any length.  Also in the partial PWA are parameter
           list fields for any internal subroutines that do not have SWAs.
 
           Following the partial fields is the SMWA (Structured Macros  Work
           Area).    Note that the SMWA can be variable in length or absent.
           If you specify a relocatable address for the SMWA, one  will  not
           be allocated automatically.
 
           Next  is  any  space  reserved  for dynamically defined parameter
           lists in the program block.  These lists are any that do not have
           a PL=tag coded on the PLIST macro or any enclosing block.    Note
           that  only enough space for the largest such list is reserved in-
           stead of for all the lists.  All of these dynamic lists are  cre-
           ated   in  the  same  place.    For  more  information  on  PLIST
           processing, see "Chapter 10. Parameter Lists and  Standard  Link-
           age"  on  page 34.   This field may also be variable in length or
           missing.
 
           140    Structured Macros Reference
 
 
           Finally come any fields that you coded between the PWA and ENDPWA
           macros.  These continue until the end of the PWA.
 
           A  PWA  remains in dynamic storage as long as its program is run-
           ning.  The PWA is followed by any active SWAs for that  program's
           internal  subroutines.  The SWAs are created and destroyed as the
           subroutines are entered and exited.  The format of a  single  SWA
           is shown below.
 
 
 
              | NAB  | R0-R14  | Partial | SMWA   | PL  | User - -    |
              |      |  Save   |  SWA    | (1)    | (2) | Defined     |
 
 
              |
             R11
 
           Note:
           Note:
           Note:
           Note:
            (1) The SMWA for subroutines is not used and is of zero length.
            (2) The PL storage will be as large as required.
 
           The  SWA  looks  very  much like a PWA with a few fields missing.
           The only significant difference is the 15  word  subroutine  save
           area.    Note  that this is an internal subroutine save area, and
           not a standard OS save area.  The NAB for a subroutine points  to
           the first available byte after that subroutine's SWA.  If this is
           the last SWA currently in dynamic storage, this NAB will point to
           the  beginning of free space.  Otherwise, it will contain the ad-
           dress of the next SWA (or PWA) in dynamic storage.
 
           R11 always points to the beginning (i.e. the  NAB)  of  the  cur-
           rently  active subroutine.  If there is no subroutine active, R11
           will point to the NAB from the current PWA.   Therefore, R11  not
           only provides us with a base for our SWA, it always points to the
           most current NAB.
 
           This storage scheme is very easy to maintain and perform linkages
           on.  When an internal subroutine is entered, it uses R15 (this is
           why  R15 is destroyed with the DYN option) to calculate where its
           SWA will go from the current NAB (pointed to by R11).    It  then
           saves its registers in this new SWA and calculates a new NAB.  If
           there is enough room for this SWA, the subroutine will update R11
           to  point  to  its NAB and the linkage is complete.  Adding a new
           PWA is a similar process.  The reverse linkage  is  even  easier.
           Since  the  pointer to the current NAB is kept in a register, the
           act of restoring registers at the end of a subroutine returns the
           dynamic storage environment to the state it  was  in  before  the
           subroutine  was  entered.   The same holds true for eliminating a
           PWA when an *NOMAIN program is exited.
 
 
 
                                 Appendix C. Work Area Storage Layout    141
 
 
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=DC
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=DC
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=DC
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=DC
           __________________________________________
 
           The work area layout for an ENVIRON=DC program is nearly  identi-
           cal  with that of an ENVIRON=OS program: the only differences are
           that the PWA does not contain an 18-word OS savearea, and the PWA
           in an ENVIRON=DC program is addressed by some register other than
           R13 (usually R11).
 
 
 
              | Partial   | SMWA    | PL        | User - -   |
              |  PWA      | (1)     | (2)       | Defined    |
 
 
              |
             R11
 
           Note:
           Note:
           Note:
           Note:
            (1) The SMWA is variable in length.
            (2)  The  PL  storage will be as large as required.  An SWA in a
           NODYN program is represented below.  It is identical to  the  SWA
           for an ENVIRON=OS program with the NODYN option.  field.
 
 
 
              | R0-R14  | Partial | SMWA   | PL  | User - -    |
              |  Save   |  SWA    | (1)    | (2) | Defined     |
 
 
              |
             (3)
 
           Note:
           Note:
           Note:
           Note:
            (1) The SMWA for subroutines is not used and is of zero length.
            (2) The PL storage will be as large as required.
            (3) With NODYN, the SWA will be addressed off of the PWA base.
 
           ENVIRON=DC does not currently support the DYN option.
 
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=OS
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=OS
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=OS
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=OS
           __________________________________________
 
           If the DYN option is not being used, the program can still have a
           PWA.  If this is the case, the PWA is of the following format:
 
 
 
              | Save Area | Partial | SMWA | PL | User - -   |
              |   (18F)   |  PWA    | (1)  | (2)| Defined    |
 
 
              |
             R13
 
           Note:
           Note:
           Note:
           Note:
            (1) The SMWA is variable in length.
            (2) The PL storage will be as large as required.
 
           142    Structured Macros Reference
 
 
           The  PWA for a NODYN program looks very much like the PWA created
           in dynamic storage, except that the pointers used to keep up with
           dynamic storage are not there.  Also, any SWAs  defined  by  this
           program will reside in the partial PWA area.
 
           An  SWA  in  a NODYN program is represented below.  Remember that
           this storage is  actually  allocated  within  the  PWA's  partial
                                                                     _______
           field.
 
 
 
              | R0-R14  | Partial | SMWA   | PL  | User - -    |
              |  Save   |  SWA    | (1)    | (2) | Defined     |
 
 
              |
             (3)
 
           Note:
           Note:
           Note:
           Note:
            (1) The SMWA for subroutines is not used and is of zero length.
            (2) The PL storage will be as large as required.
            (3) With NODYN, the SWA will be addressed off of the PWA base.
 
           The  SWA  within a NODYN program is just like that for a DYN pro-
           gram, except that the NAB is absent.
 
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=PLI
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=PLI
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=PLI
           WORK AREA LAYOUT WITH NODYN AND ENVIRON=PLI
           ___________________________________________
 
           The work area layout for ENVIRON=PLI is the same  as  the  layout
           for  ENVIRON=OS  with  option  NODYN in effect with the exception
           that the save area is replace by a PL/I DSA.  A DSA  starts  with
           an  OS  save area with the first word used for PL/I housekeeping.
           The forward link in the save area is not used.  The save area  if
           followed  by  other  PL/I housekeeping fields.  The format of the
           DSA is described in detail in the execution time logic manual for
           the PL/I Optimizing Compiler.
 
 
 
              | PL/I DSA  | Partial | SMWA | PL | User - -   |
              |           |  PWA    | (1)  | (2)| Defined    |
 
 
              |
             R13
 
           Note:
           Note:
           Note:
           Note:
            (1) The SMWA is variable in length.
            (2) The PL storage will be as large as required.
 
 
 
                                 Appendix C. Work Area Storage Layout    143
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           144    Structured Macros Reference
 
 
                             APPENDIX D. PROGRAM CODE AND STATIC DATA LAYOUT
                             APPENDIX D. PROGRAM CODE AND STATIC DATA LAYOUT
                             APPENDIX D. PROGRAM CODE AND STATIC DATA LAYOUT
                             APPENDIX D. PROGRAM CODE AND STATIC DATA LAYOUT
                             _______________________________________________
 
           The  use of the LOCTR instruction in the Level H Assembler allows
           the Structured Macros to gather  code  under  different  location
           counters  and  place them at the proper point in the load module.
           To preserve the  integrity  of  the  structure  that  the  macros
           produce, a program should be coded in the manner shown below.
 
              BLOCK  TYPE=PROGRAM,NAME=MAINPROG,OPTIONS=(*MAIN,LONG),
                            SUBOPTS=(*SWA,LOADBASE)
                    :
               CALLSUB SUBONE
                    :
              ENDBLK BLOCK=MAINPROG
 
              BLOCK  TYPE=SUBROUTINE,NAME=SUBONE
                    :
               CALLSUB SUBTWO
                    :
              ENDBLK BLOCK=SUBONE
              SWA
               --- SWA Fields for SUBONE ---
              ENDSWA
 
              BLOCK  TYPE=SUBROUTINE,NAME=SUBTWO,RECUR=10
                    :
               CALLSUB SUBTWO
                    :
              ENDBLK BLOCK=SUBTWO
              SSD
               --- Subroutine Static Data for SUBTWO ---
              ENDSSD
              SWA
               --- SWA Fields for SUBTWO ---
              ENDSWA
 
              BLOCK  TYPE=SUBROUTINE,NAME=SUBTHREE,OPTIONS=(NOLOADBASE)
                    :
               CALLSUB SUBTHREE
                    :
              ENDBLK BLOCK=SUBTHREE
              SSD
               --- Subroutine Static Data for SUBTHREE ---
              ENDSSD
 
              PSD
               --- Program Static Data ---
              ENDPSD
              PWA
               --- PWA FIELDS ---
              ENDPWA
 
                      Appendix D. Program Code and Static Data Layout    145
 
 
           Note that not all programs will require all of these options.  If
           SUBTWO  was not recursive, we would not need Dynamic Storage Man-
           agement.   However, it still may be  of  assistance  in  reducing
           storage  needs.  SWAs, SSDs, and the PSD only need to be coded if
           there are fields to define there.  If these areas are  needed  by
           the  macros, they will create them if you have not.  However, the
           PWA and ENDPWA macros must always be coded if the program is  go-
                                      always
                                      always
                                      always
           ing to use the PWA option.
 
           Note: If  the  NOLOCTR  option has been selected, the macros will
           Note:
           Note:
           Note:
           not generate LOCTRs to arrange the code, and the  CSECT  will  be
           arranged as it was coded.
 
           When  the  load  module is actually created by the Assembler, the
           layout of a single CSECT looks like the figure below:
 
 
 
              | Program  | Subroutine  | Partial  | PSD User   | Subroutine  | S
              | Code (1) |  Code (2)   | PSD (3)  | Fields (4) | Code (5)    | (
 
 
 
           (1)   First in the CSECT is the code from the program  block  it-
                 self.
 
           (2)   Following  the program code is the code for any subroutines
                 that did not specify LOADBASE.  This allows  these  subrou-
                 tines to be addressed off of the program's base register.
 
           (3)   The  partial  PSD contains any PSD fields that were defined
                 within the body of the program.  Also included here are the
                 SSDs from the subroutines without LOADBASE.    The  partial
                 PSD along with the PSD user fields are addressed off of the
                 program's base register.
 
           (4)   The  PSD  user fields are any static data coded between the
                 PSD and ENDPSD macros at the end of the program.
 
           (5)   The subroutine  code  for  any  subroutines  that  use  the
                 LOADBASE  option  is placed after the PSD.  If there are no
                 subroutines that use LOADBASE, this area and the  next  one
                 are missing.
 
           (6)   Following  the code for a LOADBASE subroutine is the static
                 data (SSD) for that subroutine.  This data is addressed off
                 of the subroutine's base register.   These last  two  areas
                 can  be repeated any number of times, once for each subrou-
                 tine that uses the LOADBASE option.
 
 
 
           146    Structured Macros Reference
 
 
                                                  APPENDIX E. REGISTER USAGE
                                                  APPENDIX E. REGISTER USAGE
                                                  APPENDIX E. REGISTER USAGE
                                                  APPENDIX E. REGISTER USAGE
                                                  __________________________
 
           With so many things being done by the macros, you may not be sure
           exactly  what  registers are available for general use.  This ap-
           pendix describes the registers used by the Structured Macros.
 
           REGISTER USAGE FOR ENVIRON=DC
           REGISTER USAGE FOR ENVIRON=DC
           REGISTER USAGE FOR ENVIRON=DC
           REGISTER USAGE FOR ENVIRON=DC
           _____________________________
 
           IDMS/DC User Mode Registers And Linkage
           IDMS/DC User Mode Registers And Linkage
           IDMS/DC User Mode Registers And Linkage
           IDMS/DC User Mode Registers And Linkage
           _______________________________________
 
               User mode programs are invoked by:
 
                   A #LINK from RHDCTSKC (task create)
                   A #LINK or #XCTL from another program
 
               User mode registers are used as follows:
 
               R15       Entry point address from caller;  loaded  into  the
               R15
               R15
               R15
                         specified   program  base  register  by  the  BLOCK
                         TYPE=PROGRAM macro. Also used for subroutine  link-
                         age if the LONG option is used.
 
               R14       This is used for returning from subroutine blocks.
               R14
               R14
               R14
 
               R13       Not used.
               R13
               R13
               R13
 
               R12       Default program base register.
               R12
               R12
               R12
 
               R11       Default PWA base register.
               R11
               R11
               R11
 
               R10       Address  of the IDMS/DC CSA on entry, although this
               R10
               R10
               R10
                         register may be used for other things by  the  pro-
                         gram.
 
               R9        Address  of  the  IDMS/DC  task's TCE on entry, al-
               R9
               R9
               R9
                         though this register may be used for  other  things
                         by the program.
 
               R2-R8     Not used.
               R2-R8
               R2-R8
               R2-R8
 
               R1        Address  of parameter list from calling program, if
               R1
               R1
               R1
                         any
 
               R0        Not used.
               R0
               R0
               R0
 
               Registers are always saved across requests for  IDMS/DC  ser-
               vices, except for R14, R15, R0 and R1.
 
                                           Appendix E. Register Usage    147
 
 
               The  assembler program should include an interface, either by
               coding a #BALI macro among your constants  somewhere,  or  by
               specifying INCLUDE IDMSLIB(IDMSBALI) to the linkage editor.
 
               User  mode  programs must return to IDMS/DC using the #RETURN
               macro.  If you use the NO#RETURN  option,  you  must  code  a
               #RETURN  yourself  at  some  point  after the program block's
               ENDBLK macro.
 
           IDMS/DC System Mode Registers And Linkage
           IDMS/DC System Mode Registers And Linkage
           IDMS/DC System Mode Registers And Linkage
           IDMS/DC System Mode Registers And Linkage
           _________________________________________
 
               System mode programs are invoked  by  a  #CALL  from  another
               system-mode program. Should you wish to call an external rou-
               tine, you should use #CALL instead of CALLX.
 
               System mode registers are used as follows:
 
               R15       Entry  point  address  from caller; loaded into the
               R15
               R15
               R15
                         specified  program  base  register  by  the   BLOCK
                         TYPE=PROGRAM  macro. Also used for internal subrou-
                         tine linkage if the LONG option is used.
 
               R14       This is used for returning from subroutine blocks.
               R14
               R14
               R14
 
               R13       Not used.
               R13
               R13
               R13
 
               R12       Program base register.
               R12
               R12
               R12
 
               R11       Default PWA base register, for  PWA's  obtained  by
               R11
               R11
               R11
                         either #GETSTG or #GETSTK.
 
               R10       Address of the IDMS/DC CSA. This should not be mod-
               R10
               R10
               R10
                         ified by the program.
 
               R9        Address  of the IDMS/DC task's TCE. This should not
               R9
               R9
               R9
                         be modified by the program.
 
               R2-R8     Not used.
               R2-R8
               R2-R8
               R2-R8
 
               R1        Address of parameter list from calling program,  if
               R1
               R1
               R1
                         any
 
               R0        Not used.
               R0
               R0
               R0
 
               Registers R13 and R15-R1 are never saved across #CALLs.
 
               Registers  R11,  R12  and R14 are always saved in the current
               TCE's save area stack.
 
 
           148    Structured Macros Reference
 
 
               The caller of a routine is responsible for  specifying  which
               of the remaining registers (R2-R8) are to be saved. For exam-
               ple,
                     #CALL  pgmname,(R2-R8)
               will  cause R2 through R8 to be saved on the TCE stack, along
               with R11, R12 and R14.
 
           REGISTER USAGE FOR ENVIRON=OS
           REGISTER USAGE FOR ENVIRON=OS
           REGISTER USAGE FOR ENVIRON=OS
           REGISTER USAGE FOR ENVIRON=OS
           _____________________________
 
           R15       This register is used for the address of the subroutine
           R15
           R15
           R15
                     when CALLSUB is used with the LONG  Program  Block  op-
                     tion.
 
           R14       This register holds the return address from any subrou-
           R14
           R14
           R14
                     tine block called by the macros.
 
           R13       This  is  the  base register for the PWA.  Although the
           R13
           R13
           R13
                     PWA can have multiple base  registers,  the  first  one
                     must  always be R13 since the standard OS save area for
                     the program is at the beginning of the PWA.  If *NORENT
                     is used and SVAREA= is not specified, R13 is the  first
                     program base as well as pointing to the OS save area.
 
           R12       This  is normally the base register for the program it-
           R12
           R12
           R12
                     self along with any static data.  If the NORENT  option
                     is  being  used and the SVAREA=  keyword was not speci-
                     fied, R13 is used for the base register instead of R12.
                     The BASEREG=  keyword on the Program Block can be  used
                     to  specify a different base register (or multiple base
                     registers).
 
           R11       If the DYN option was specified on the  Program  Block,
           R11
           R11
           R11
                     R11 will be used to establish addressibility on the SWA
                     of  the  current  subroutine.   This register is in use
                     even when no subroutine is currently active.   Although
                     the  Subroutine  Block  allows  you to specify multiple
                     base registers for the SWA,  R11  must  always  be  the
                     first one.
 
           R10       If the LOADBASE options was specified on the Subroutine
           R10
           R10
           R10
                     Block,  R10  will  be used as the base register for the
                     subroutine code.  This register is only  in  use  while
                     the  LOADBASE  subroutine  is  currently  active.   The
                     BASEREG=  keyword on the Subroutine Block can  be  used
                     to  specify a different base register (or multiple base
                     registers).
 
 
 
                                           Appendix E. Register Usage    149
 
 
           REGISTER USAGE FOR ENVIRON=PLI
           REGISTER USAGE FOR ENVIRON=PLI
           REGISTER USAGE FOR ENVIRON=PLI
           REGISTER USAGE FOR ENVIRON=PLI
           ______________________________
 
           R15       This register is used for the address of the subroutine
           R15
           R15
           R15
                     when CALLSUB is used with the LONG  Program  Block  op-
                     tion.
 
           R14       This register holds the return address from any subrou-
           R14
           R14
           R14
                     tine block called by the macros.
 
           R13       This  is  the base register for the PWA.  A PL/I DSA is
           R13
           R13
           R13
                     contained in the first part of the PWA; therefore,  R13
                     is  also  the  base for the DSA.   Although the PWA can
                     have multiple base registers, the first one must always
                     be R13 because PL/I requires that R13 contain a pointer
                     to the DSA.
 
           R12       This is the pointer to PL/I's Task Communications  Area
           R12
           R12
           R12
                     (TCA) and should never be modified by a program.
 
           R11       This is the first program base register for the program
           R11
           R11
           R11
                     itself along with any static data.
 
           R10       If the LOADBASE options was specified on the Subroutine
           R10
           R10
           R10
                     Block,  R10  will  be used as the base register for the
                     subroutine code.  This register is only  in  use  while
                     the  LOADBASE  subroutine  is  currently  active.   The
                     BASEREG= keyword on the Subroutine Block can be used to
                     specify a different base  register  (or  multiple  base
                     registers).
 
 
 
 
 
 
 
 
 
           150    Structured Macros Reference
